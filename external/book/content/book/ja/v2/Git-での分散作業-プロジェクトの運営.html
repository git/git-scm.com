---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ja
  chapter:
    title: Git での分散作業
    number: 5
  section:
    title: プロジェクトの運営
    number: 3
    cs_number: '5.3'
    previous: book/ja/v2/Git-での分散作業-プロジェクトへの貢献
    next: book/ja/v2/Git-での分散作業-まとめ
title: Git - プロジェクトの運営
url: "/book/ja/v2/Git-での分散作業-プロジェクトの運営.html"
---
<h2 id="_プロジェクトの運営">プロジェクトの運営</h2>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>プロジェクトに貢献する方法だけでなく、プロジェクトを運営する方法についても知っておくといいでしょう。
たとえば <code>format-patch</code> を使ってメールで送られてきたパッチを処理する方法や、別のリポジトリのリモートブランチでの変更を統合する方法などです。
本流のリポジトリを保守するにせよパッチの検証や適用を手伝うにせよ、どうすれば貢献者たちにとってわかりやすくなるかを知っておくべきでしょう。</p>
</div>
<div class="sect3">
<h3 id="_トピックブランチでの作業">トピックブランチでの作業</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>新しい機能を組み込もうと考えている場合は、トピックブランチを作ることをおすすめします。トピックブランチとは、新しく作業を始めるときに一時的に作るブランチのことです。
そうすれば、そのパッチだけを個別にいじることができ、もしうまくいかなかったとしてもすぐに元の状態に戻すことができます。
ブランチの名前は、今からやろうとしている作業の内容にあわせたシンプルな名前にしておきます。たとえば <code>ruby_client</code> などといったものです。そうすれば、しばらく時間をおいた後でそれを廃棄することになったときに、内容を思い出しやすくなります。
Git プロジェクトのメンテナは、ブランチ名に名前空間を使うことが多いようです。たとえば <code>sc/ruby_client</code> のようになり、ここでの <code>sc</code> はその作業をしてくれた人の名前を短縮したものとなります。
自分の master ブランチをもとにしたブランチを作成する方法は、このようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch sc/ruby_client master</code></pre>
</div>
</div>
<div class="paragraph">
<p>作成してすぐそのブランチに切り替えたい場合は、<code>checkout -b</code> オプションを使います。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b sc/ruby_client master</code></pre>
</div>
</div>
<div class="paragraph">
<p>受け取った作業はこのトピックブランチですすめ、長期ブランチに統合するかどうかを判断することになります。</p>
</div>
</div>
<div class="sect3">
<h3 id="r_patches_from_email">メールで受け取ったパッチの適用</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>あなたのプロジェクトへのパッチをメールで受け取った場合は、まずそれをトピックブランチに適用して中身を検証します。
メールで届いたパッチを適用するには <code>git apply</code> と <code>git am</code> の二通りの方法があります。</p>
</div>
<div class="sect4">
<h4 id="_apply_によるパッチの適用">apply によるパッチの適用</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p><code>git diff</code> あるいは Unix の <code>diff</code> コマンドで作ったパッチ（パッチの作り方としては推奨できません。次節で理由を説明します）を受け取ったときは、<code>git apply</code> コマンドを使ってパッチを適用します。
パッチが <code>/tmp/patch-ruby-client.patch</code> にあるとすると、このようにすればパッチを適用できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git apply /tmp/patch-ruby-client.patch</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、作業ディレクトリ内のファイルを変更します。
<code>patch -p1</code> コマンドでパッチをあてるのとほぼ同じなのですが、それ以上に「これでもか」というほどのこだわりを持ってパッチを適用するので fuzzy マッチになる可能性が少なくなります。
また、<code>git diff</code> 形式ではファイルの追加・削除やファイル名の変更も扱うことができますが、<code>patch</code> コマンドにはそれはできません。
そして最後に、<code>git apply</code> は「全部適用するか、あるいは一切適用しないか」というモデルを採用しています。一方 <code>patch</code> コマンドの場合は、途中までパッチがあたった中途半端な状態になって困ることがあります。
<code>git apply</code> のほうが、 <code>patch</code> よりも慎重に処理を行うのです。
<code>git apply</code> コマンドはコミットを作成するわけではありません。実行した後で、その変更をステージしてコミットする必要があります。</p>
</div>
<div class="paragraph">
<p>git apply を使って、そのパッチをきちんと適用できるかどうかを事前に確かめることができます。パッチをチェックするには <code>git apply --check</code> を実行します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply</code></pre>
</div>
</div>
<div class="paragraph">
<p>何も出力されなければ、そのパッチはうまく適用できるということです。
このコマンドは、チェックに失敗した場合にゼロ以外の値を返して終了します。スクリプト内でチェックしたい場合などにはこの返り値を使用します。</p>
</div>
</div>
<div class="sect4">
<h4 id="r_git_am">
<code>am</code> でのパッチの適用</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>コードを提供してくれた人が Git のユーザーで、<code>format-patch</code> コマンドを使ってパッチを送ってくれたとしましょう。この場合、あなたの作業はより簡単になります。パッチの中に、作者の情報やコミットメッセージも含まれているからです。
「パッチを作るときには、できるだけ <code>diff</code> ではなく <code>format-patch</code> を使ってね」とお願いしてみるのもいいでしょう。
昔ながらの形式のパッチが届いたときだけは <code>git apply</code> を使わなければならなくなります。</p>
</div>
<div class="paragraph">
<p><code>format-patch</code> で作ったパッチを適用するには <code>git am</code> を使います。技術的なお話をすると、<code>git am</code> は mbox ファイルを読み込む仕組みになっています。mbox はシンプルなプレーンテキスト形式で、一通あるいは複数のメールのメッセージをひとつのテキストファイルにまとめるためのものです。中身はこのようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20</code></pre>
</div>
</div>
<div class="paragraph">
<p>先ほどのセクションでごらんいただいたように、format-patch コマンドの出力結果もこれと同じ形式で始まっていますね。
これは、mbox 形式のメールフォーマットとしても正しいものです。
git send-email を正しく使ったパッチが送られてきた場合、受け取ったメールを mbox 形式で保存して git am コマンドでそのファイルを指定すると、すべてのパッチの適用が始まります。
複数のメールをまとめてひとつの mbox に保存できるメールソフトを使っていれば、送られてきたパッチをひとつのファイルにまとめて git am で一度に適用することもできます。</p>
</div>
<div class="paragraph">
<p>しかし、<code>format-patch</code> で作ったパッチがチケットシステム (あるいはそれに類する何か) にアップロードされたような場合は、まずそのファイルをローカルに保存して、それを <code>git am</code> に渡すことになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am 0001-limit-log-function.patch
Applying: add limit to log function</code></pre>
</div>
</div>
<div class="paragraph">
<p>どんなパッチを適用したのかが表示され、コミットも自動的に作られます。作者の情報はメールの <code>From</code> ヘッダと <code>Date</code> ヘッダから取得し、コミットメッセージは <code>Subject</code> とメールの本文 (パッチより前の部分) から取得します。たとえば、先ほどごらんいただいた mbox の例にあるパッチを適用した場合は次のようなコミットとなります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith &lt;jessica@example.com&gt;
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Commit</code> には、そのパッチを適用した人と適用した日時が表示されます。
<code>Author</code> には、そのパッチを実際に作成した人と作成した日時が表示されます。</p>
</div>
<div class="paragraph">
<p>しかし、パッチが常にうまく適用できるとは限りません。
パッチを作成したときの状態と現在のメインブランチとが大きくかけ離れてしまっていたり、そのパッチが別の (まだ適用していない) パッチに依存していたりなどといったことがあり得るでしょう。
そんな場合は <code>git am</code> は失敗し、次にどうするかを聞かれます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run "git am --resolved".
If you would prefer to skip this patch, instead run "git am --skip".
To restore the original branch and stop patching run "git am --abort".</code></pre>
</div>
</div>
<div class="paragraph">
<p>このコマンドは、何か問題が発生したファイルについて衝突マークを書き込みます。これは、マージやリベースに失敗したときに書き込まれるのとよく似たものです。
問題を解決する方法も同じです。まずはファイルを編集して衝突を解決し、新しいファイルをステージし、<code>git am --resolved</code> を実行して次のパッチに進みます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ （ファイルを編集する）
$ git add ticgit.gemspec
$ git am --resolved
Applying: seeing if this helps the gem</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git にもうちょっと賢く働いてもらって衝突を回避したい場合は、<code>-3</code> オプションを使用します。これは、Git で三方向のマージを行うオプションです。
このオプションはデフォルトでは有効になっていません。適用するパッチの元になっているコミットがあなたのリポジトリ上のものでない場合に正しく動作しないからです。
パッチの元になっているコミットが手元にある場合は、<code>-3</code> オプションを使うと、衝突しているパッチをうまく適用できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここでは、既に適用済みのパッチを適用してみました。
<code>-3</code> オプションがなければ、衝突が発生していたことでしょう。</p>
</div>
<div class="paragraph">
<p>たくさんのパッチが含まれる mbox からパッチを適用するときには、<code>am</code> コマンドを対話モードで実行することもできます。パッチが見つかるたびに処理を止め、それを適用するかどうかの確認を求められます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、「大量にあるパッチについて、内容をまず一通り確認したい」「既に適用済みのパッチは適用しないようにしたい」などの場合に便利です。</p>
</div>
<div class="paragraph">
<p>トピックブランチ上でそのトピックに関するすべてのパッチの適用を済ませてコミットすれば、次はそれを長期ブランチに統合するかどうか (そしてどのように統合するか) を考えることになります。</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="r_checking_out_remotes">リモートブランチのチェックアウト</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>自前のリポジトリを持つ Git ユーザーが自分のリポジトリに変更をプッシュし、そのリポジトリの URL とリモートブランチ名だけをあなたにメールで連絡してきた場合のことを考えてみましょう。そのリポジトリをリモートとして登録し、それをローカルにマージすることになります。</p>
</div>
<div class="paragraph">
<p>Jessica から「すばらしい新機能を作ったので、私のリポジトリの <code>ruby-client</code> ブランチを見てください」といったメールが来たとします。これを手元でテストするには、リモートとしてこのリポジトリを追加し、ローカルにブランチをチェックアウトします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client</code></pre>
</div>
</div>
<div class="paragraph">
<p>「この前のとは違う、別のすばらしい機能を作ったの!」と別のブランチを伝えられた場合は、すでにリモートの設定が済んでいるので単にそのブランチを取得してチェックアウトするだけで確認できます。</p>
</div>
<div class="paragraph">
<p>この方法は、誰かと継続的に共同作業を進めていく際に便利です。
ちょっとしたパッチをたまに提供してくれるだけの人の場合は、パッチをメールで受け取るようにしたほうが時間の節約になるでしょう。全員に自前のサーバーを用意させて、たまに送られてくるパッチを取得するためだけに定期的にリモートの追加と削除を行うなどというのは時間の無駄です。
ほんの数件のパッチを提供してくれる人たちを含めて数百ものリモートを管理することなど、きっとあなたはお望みではないでしょう。
しかし、スクリプトやホスティングサービスを使えばこの手の作業は楽になります。つまり、どのような方式をとるかは、あなたや他のメンバーがどのような方式で開発を進めるかによって決まります。</p>
</div>
<div class="paragraph">
<p>この方式のもうひとつの利点は、コミットの履歴も同時に取得できるということです。
マージの際に問題が起こることもあるでしょうが、そんな場合にも相手の作業が自分側のどの地点に基づくものなのかを知ることができます。適切に三方向のマージが行われるので、<code>-3</code> を指定したときに「このパッチの基点となるコミットにアクセスできればいいなぁ」と祈る必要はありません。</p>
</div>
<div class="paragraph">
<p>継続的に共同作業を続けるわけではないけれど、それでもこの方式でパッチを取得したいという場合は、リモートリポジトリの URL を <code>git pull</code> コマンドで指定することもできます。
これは一度きりのプルに使うものであり、リモートを参照する URL は保存されません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
 * branch            HEAD       -&gt; FETCH_HEAD
Merge made by recursive.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="r_what_is_introduced">何が変わるのかの把握</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>トピックブランチの中に、提供してもらった作業が含まれた状態になりました。
次に何をすればいいのか考えてみましょう。
このセクションでは、これまでに扱ったいくつかのコマンドを復習します。それらを使って、もしこの変更をメインブランチにマージしたらいったい何が起こるのかを調べていきましょう。</p>
</div>
<div class="paragraph">
<p>トピックブランチのコミットのうち、master ブランチに存在しないコミットの内容をひとつひとつレビューできれば便利でしょう。
master ブランチに含まれるコミットを除外するには、ブランチ名の前に <code>--not</code> オプションを指定します。
これは、これまで使ってきた <code>master..contrib</code> という書式と同じ役割を果たしてくれます。
たとえば、誰かから受け取った二つのパッチを適用するために <code>contrib</code> というブランチを作成したとすると、</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better</code></pre>
</div>
</div>
<div class="paragraph">
<p>このようなコマンドを実行すればそれぞれのコミットの内容を確認できます。<code>git log</code> に <code>-p</code> オプションを渡せば、コミットの後に diff を表示させることもできます。これも以前に説明しましたね。</p>
</div>
<div class="paragraph">
<p>このトピックブランチを別のブランチにマージしたときに何が起こるのかを完全な diff で知りたい場合は、ちょっとした裏技を使わないと正しい結果が得られません。
おそらく「こんなコマンドを実行するだけじゃないの?」と考えておられることでしょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff master</code></pre>
</div>
</div>
<div class="paragraph">
<p>このコマンドで表示される diff は、誤解を招きかねないものです。
トピックブランチを切った時点からさらに <code>master</code> ブランチが先に進んでいたとすると、これは少し奇妙に見える結果を返します。
というのも、Git は現在のトピックブランチの最新のコミットのスナップショットと <code>master</code> ブランチの最新のコミットのスナップショットを直接比較するからです。
トピックブランチを切った後に <code>master</code> ブランチ上であるファイルに行を追加したとすると、スナップショットを比較した結果は「トピックブランチでその行を削除しようとしている」状態になります。</p>
</div>
<div class="paragraph">
<p><code>master</code> がトピックブランチの直系の先祖である場合は、これは特に問題とはなりません。しかし二つの歴史が分岐している場合には、diff の結果は「トピックブランチで新しく追加したすべての内容を追加し、<code>master</code> ブランチにしかないものはすべて削除する」というものになります。</p>
</div>
<div class="paragraph">
<p>本当に知りたいのはトピックブランチで変更された内容、つまりこのブランチを master にマージしたときに master に加わる変更です。
これを知るには、Git に「トピックブランチの最新のコミット」と「トピックブランチと master ブランチの直近の共通の先祖」とを比較させます。</p>
</div>
<div class="paragraph">
<p>共通の先祖を見つけだしてそこからの diff を取得するには、このようにします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db</code></pre>
</div>
</div>
<div class="paragraph">
<p>しかし、これでは不便です。そこで Git には、同じことをより手短にやるための手段としてトリプルドット構文が用意されています。
<code>diff</code> コマンドを実行するときにピリオドを三つ打った後に別のブランチを指定すると、「現在いるブランチの最新のコミット」と「指定した二つのブランチの共通の先祖」とを比較するようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff master...contrib</code></pre>
</div>
</div>
<div class="paragraph">
<p>このコマンドは、master との共通の先祖から分岐した現在のトピックブランチで変更された内容のみを表示します。
この構文は、覚えやすいので非常に便利です。</p>
</div>
</div>
<div class="sect3">
<h3 id="_提供された作業の取り込み">提供された作業の取り込み</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>トピックブランチでの作業をメインブランチに取り込む準備ができたら、どのように取り込むかを考えることになります。
さらに、プロジェクトを運営していくにあたっての全体的な作業の流れはどのようにしたらいいでしょうか?
さまざまな方法がありますが、ここではそのうちのいくつかを紹介します。</p>
</div>
<div class="sect4">
<h4 id="_マージのワークフロー">マージのワークフロー</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>シンプルなワークフローのひとつとして、作業を自分の <code>master</code> ブランチに取り込むことを考えます。
ここでは、<code>master</code> ブランチで安定版のコードを管理しているものとします。
トピックブランチでの作業が一段落したら (あるいは誰かから受け取ったパッチをトピックブランチ上で検証し終えたら)、それを master ブランチにマージしてからトピックブランチを削除し、作業を進めることになります。
<code>ruby_client</code> および <code>php_client</code> の二つのブランチを持つ <a href="{{< relurl "book/ja/v2/ch00/rmerwf_a" >}}">いくつかのトピックブランチを含む履歴</a> のようなリポジトリでまず <code>ruby_client</code> をマージしてから <code>php_client</code> もマージすると、歴史は <a href="{{< relurl "book/ja/v2/ch00/rmerwf_b" >}}">トピックブランチをマージした後の状態</a> のようになります。</p>
</div>
<div id="rmerwf_a" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ja/v2/images/merging-workflows-1.png" >}}" alt="いくつかのトピックブランチを含む履歴">
</div>
<div class="title">図 72. いくつかのトピックブランチを含む履歴</div>
</div>
<div id="rmerwf_b" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ja/v2/images/merging-workflows-2.png" >}}" alt="トピックブランチをマージした後の状態">
</div>
<div class="title">図 73. トピックブランチをマージした後の状態</div>
</div>
<div class="paragraph">
<p>これがおそらく一番シンプルなワークフローでしょう。ただし、それが問題になることもあります。大規模プロジェクトや安定しているプロジェクトのように、何を受け入れるかを慎重に決めなければいけない場合です。</p>
</div>
<div class="paragraph">
<p>より重要なプロジェクトの場合は、二段階のマージサイクルを使うこともあるでしょう。
ここでは、長期間運用するブランチが <code>master</code> と <code>develop</code> のふたつあるものとします。<code>master</code> が更新されるのは安定版がリリースされるときだけで、新しいコードはずべて <code>develop</code> ブランチに統合されるという流れです。
これらのブランチは、両方とも定期的に公開リポジトリにプッシュすることになります。
新しいトピックブランチをマージする準備ができたら (<a href="{{< relurl "book/ja/v2/ch00/rmerwf_c" >}}">トピックブランチのマージ前</a>)、それを <code>develop</code> にマージします (<a href="{{< relurl "book/ja/v2/ch00/rmerwf_d" >}}">トピックブランチのマージ後</a>)。そしてリリースタグを打つときに、<code>master</code> を現在の <code>develop</code> ブランチが指す位置に進めます (<a href="{{< relurl "book/ja/v2/ch00/rmerwf_e" >}}">プロジェクトのリリース後</a>)。</p>
</div>
<div id="rmerwf_c" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ja/v2/images/merging-workflows-3.png" >}}" alt="トピックブランチのマージ前">
</div>
<div class="title">図 74. トピックブランチのマージ前</div>
</div>
<div id="rmerwf_d" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ja/v2/images/merging-workflows-4.png" >}}" alt="トピックブランチのマージ後">
</div>
<div class="title">図 75. トピックブランチのマージ後</div>
</div>
<div id="rmerwf_e" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ja/v2/images/merging-workflows-5.png" >}}" alt="トピックブランチのリリース後">
</div>
<div class="title">図 76. プロジェクトのリリース後</div>
</div>
<div class="paragraph">
<p>他の人があなたのプロジェクトをクローンするときには、master をチェックアウトすれば最新の安定版をビルドすることができ、その後の更新を追いかけるのも容易にできるようになります。一方 develop をチェックアウトすれば、さらに最先端の状態を取得することができます。
この考え方を推し進めると、統合用のブランチを用意してすべての作業をいったんそこにマージするようにもできます。
統合ブランチ上のコードが安定してテストを通過すれば、それを develop ブランチにマージします。そしてそれが安定していることが確認できたら master ブランチを先に進めるということになります。</p>
</div>
</div>
<div class="sect4">
<h4 id="_大規模マージのワークフロー">大規模マージのワークフロー</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Git 開発プロジェクトには、常時稼働するブランチが四つあります。<code>master</code>、<code>next</code>、そして新しい作業用の <code>pu</code> (proposed updates) とメンテナンスバックポート用の <code>maint</code> です。
新しいコードを受け取ったメンテナは、まず自分のリポジトリのトピックブランチにそれを格納します。先ほど説明したのと同じ方式です ( <a href="{{< relurl "book/ja/v2/ch00/rmerwf_f" >}}">複数のトピックブランチの並行管理</a> を参照ください)。
そしてその内容を検証し、安全に取り込める状態かさらなる作業が必要かを見極めます。
だいじょうぶだと判断したらそれを <code>next</code> にマージします。このブランチをプッシュすれば、すべてのメンバーがそれを試せるようになります。</p>
</div>
<div id="rmerwf_f" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ja/v2/images/large-merges-1.png" >}}" alt="複数のトピックブランチの並行管理">
</div>
<div class="title">図 77. 複数のトピックブランチの並行管理</div>
</div>
<div class="paragraph">
<p>さらに作業が必要なトピックについては、<code>pu</code> にマージします。
完全に安定していると判断されたトピックについては改めて <code>master</code> にマージされ、<code>next</code> にあるトピックのうちまだ <code>master</code> に入っていないものを再構築します。
つまり、<code>master</code> はほぼ常に前に進み、<code>next</code> は時々リベースされ、<code>pu</code> はそれ以上の頻度でリベースされることになります。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ja/v2/images/large-merges-2.png" >}}" alt="常時稼働する統合用ブランチへのトピックブランチのマージ">
</div>
<div class="title">図 78. 常時稼働する統合用ブランチへのトピックブランチのマージ</div>
</div>
<div class="paragraph">
<p>最終的に <code>master</code> にマージされたトピックブランチは、リポジトリから削除します。
Git 開発プロジェクトでは <code>maint</code> ブランチも管理しています。これは最新のリリースからフォークしたもので、メンテナンスリリースに必要なバックポート用のパッチを管理します。
つまり、Git のリポジトリをクローンするとあなたは四つのブランチをチェックアウトすることができるということです。これらのブランチはどれも異なる開発段階を表し、「どこまで最先端を追いかけたいか」「どのように Git プロジェクトに貢献したいか」によって使い分けることになります。メンテナ側では、新たな貢献を受け入れるためのワークフローが整っています。</p>
</div>
</div>
<div class="sect4">
<h4 id="r_rebase_cherry_pick">リベースとチェリーピックのワークフロー</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>受け取った作業を master ブランチにマージするのではなく、リベースやチェリーピックを使って master ブランチの先端につなげていく方法を好むメンテナもいます。そのほうがほぼ直線的な歴史を保てるからです。
トピックブランチでの作業を終えて統合できる状態になったと判断したら、そのブランチで rebase コマンドを実行し、その変更を現在の master (あるいは <code>develop</code> などの) ブランチの先端につなげます。
うまくいけば、<code>master</code> ブランチをそのまま前に進めてることでプロジェクトの歴史を直線的に進めることができます。</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>あるブランチの作業を別のブランチに移すための手段として、他にチェリーピック (つまみぐい) という方法があります。
Git におけるチェリーピックとは、コミット単位でのリベースのようなものです。
あるコミットによって変更された内容をパッチとして受け取り、それを現在のブランチに再適用します。
トピックブランチでいくつかコミットしたうちのひとつだけを統合したい場合、あるいはトピックブランチで一回だけコミットしたけれどそれをリベースではなくチェリーピックで取り込みたい場合などにこの方法を使用します。
以下のようなプロジェクトを例にとって考えましょう。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ja/v2/images/rebasing-1.png" >}}" alt="チェリーピック前の歴史">
</div>
<div class="title">図 79. チェリーピック前の歴史</div>
</div>
<div class="paragraph">
<p>コミット <code>e43a6</code> を master ブランチに取り込むには、次のようにします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cherry-pick e43a6
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは <code>e43a6</code> と同じ内容の変更を施しますが、コミットの SHA-1 値は新しくなります。適用した日時が異なるからです。
これで、歴史は次のように変わりました。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ja/v2/images/rebasing-2.png" >}}" alt="トピックブランチのコミットをチェリーピックした後の歴史">
</div>
<div class="title">図 80. トピックブランチのコミットをチェリーピックした後の歴史</div>
</div>
<div class="paragraph">
<p>あとは、このトピックブランチを削除すれば取り込みたくない変更を消してしまうことができます。</p>
</div>
</div>
<div class="sect4">
<h4 id="_rerere">Rerere</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>マージやリベースを頻繁に行っているなら、もしくは長く続いているトピックブランチをメンテナンスしているなら、Git の “rerere” という機能が役に立つでしょう。</p>
</div>
<div class="paragraph">
<p>Rerere は “reuse recorded resolution” の略で、コンフリクトを手っ取り早く手動で解消するための方法です。</p>
</div>
<div class="paragraph">
<p>この機能で用いるのは、設定とコマンドの2つです。
まず設定のほうは <code>rerere.enabled</code> という項目を用います。Git のグローバル設定に登録しておくとよいでしょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global rerere.enabled true</code></pre>
</div>
</div>
<div class="paragraph">
<p>一度この設定をしておくと、コンフリクトを手動で解消してマージするたびにその内容がキャッシュに記録され、のちのち使えるようになります。</p>
</div>
<div class="paragraph">
<p>必要に応じてキャッシュを操作することもできます。<code>git rerere</code> コマンドを使うのです。
このコマンドをオプションなしで実行するとキャッシュが検索され、コンフリクトの内容に合致するものがある場合はそれを用いてコンフリクトの解消が試みられます（ただし、<code>rerere.enabled</code> が <code>true</code> に設定されている場合、一連の処理は自動で行われます）。
また、サブコマンドも複数用意されています。それらを使うと、キャッシュされようとしている内容の確認、キャッシュされた内容を指定して削除、キャッシュをすべて削除、などができるようになります。rerere については <a href="{{< relurl "book/ja/v2/ch00/r_rerere" >}}">Rerere</a> で詳しく説明します。</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="r_tagging_releases">リリース用のタグ付け</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>いよいよリリースする時がきました。おそらく、後からいつでもこのリリースを取得できるようにタグを打っておくことになるでしょう。
新しいタグを打つ方法は <a href="{{< relurl "book/ja/v2/ch00/ch02-git-basics" >}}">[ch02-git-basics]</a> で説明しました。
タグにメンテナの署名を入れておきたい場合は、このようにします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon &lt;schacon@gmail.com&gt;"
1024-bit DSA key, ID F721C45A, created 2009-02-09</code></pre>
</div>
</div>
<div class="paragraph">
<p>タグに署名した場合、署名に使用した PGP 鍵ペアの公開鍵をどのようにして配布するかが問題になるかもしれません。
Git 開発プロジェクトのメンテナ達がこの問題をどのように解決したかというと、自分たちの公開鍵を blob としてリポジトリに含め、それを直接指すタグを追加することにしました。
この方法を使うには、まずどの鍵を使うかを決めるために <code>gpg --list-keys</code> を実行します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon &lt;schacon@gmail.com&gt;
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</code></pre>
</div>
</div>
<div class="paragraph">
<p>鍵を直接 Git データベースにインポートするには、鍵をエクスポートしてそれをパイプで <code>git hash-object</code> に渡します。これは、鍵の中身を新しい blob として Git に書き込み、その blob の SHA-1 を返します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>
</div>
</div>
<div class="paragraph">
<p>鍵の中身を Git に取り込めたので、この鍵を直接指定するタグを作成できるようになりました。<code>hash-object</code> コマンドで知った SHA-1 値を指定すればいいのです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git push --tags</code> を実行すると、<code>maintainer-pgp-pub</code> タグをみんなと共有できるようになります。誰かがタグを検証したい場合は、あなたの PGP 鍵が入った blob をデータベースから直接プルで取得し、それを PGP にインポートすればいいのです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show maintainer-pgp-pub | gpg --import</code></pre>
</div>
</div>
<div class="paragraph">
<p>この鍵をインポートした人は、あなたが署名したすべてのタグを検証できるようになります。タグのメッセージに検証手順の説明を含めておけば、<code>git show &lt;tag&gt;</code> でエンドユーザー向けに詳しい検証手順を示すことができます。</p>
</div>
</div>
<div class="sect3">
<h3 id="r_build_number">ビルド番号の生成</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Git では、コミットごとに <em>v123</em> のような単調な番号を振っていくことはありません。もし特定のコミットに対して人間がわかりやすい名前がほしければ、そのコミットに対して <code>git describe</code> を実行します。
Git は、そのコミットに最も近いタグの名前とそのタグからのコミット数、そしてそのコミットの SHA-1 値の一部を使った名前を作成します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git describe master
v1.6.2-rc1-20-g8c5b85c</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、スナップショットやビルドを公開するときにわかりやすい名前をつけられるようになります。
実際、Git そのもののソースコードを Git リポジトリからクローンしてビルドすると、<code>git --version</code> が返す結果はこの形式になります。
タグが打たれているコミットを直接指定した場合は、タグの名前が返されます。</p>
</div>
<div class="paragraph">
<p><code>git describe</code> コマンドは注釈付きのタグ (<code>-a</code> あるいは <code>-s</code> フラグをつけて作成したタグ) を使います。したがって、<code>git describe</code> を使うならリリースタグは注釈付きのタグとしなければなりません。そうすれば、describe したときにコミットの名前を適切につけることができます。
この文字列を checkout コマンドや show コマンドでの対象の指定に使うこともできますが、これは末尾にある SHA-1 値の省略形に依存しているので将来にわたってずっと使えるとは限りません。
たとえば Linux カーネルは、最近 SHA-1 オブジェクトの一意性を確認するための文字数を 8 文字から 10 文字に変更しました。そのため、古い <code>git describe</code> の出力での名前はもはや使えません。</p>
</div>
</div>
<div class="sect3">
<h3 id="r_preparing_release">リリースの準備</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>実際にリリースするにあたって行うであろうことのひとつに、最新のスナップショットのアーカイブを作るという作業があります。
Git を使っていないというかわいそうな人たちにもコードを提供するために。
その際に使用するコマンドは <code>git archive</code> です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git archive master --prefix='project/' | gzip &gt; `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz</code></pre>
</div>
</div>
<div class="paragraph">
<p>tarball を開けば、プロジェクトのディレクトリの下に最新のスナップショットが得られます。まったく同じ方法で zip アーカイブを作成することもできます。
この場合は <code>git archive</code> で <code>--format=zip</code> オプションを指定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git archive master --prefix='project/' --format=zip &gt; `git describe master`.zip</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、あなたのプロジェクトのリリース用にすてきな tarball と zip アーカイブができあがりました。これをウェブサイトにアップロードするなりメールで送ってあげるなりしましょう。</p>
</div>
</div>
<div class="sect3">
<h3 id="r_the_shortlog">短いログ</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>そろそろメーリングリストにメールを送り、プロジェクトに何が起こったのかをみんなに知らせてあげましょう。
前回のリリースから何が変わったのかの変更履歴を手軽に取得するには <code>git shortlog</code> コマンドを使います。
これは、指定した範囲のすべてのコミットのまとめを出力します。たとえば、直近のリリースの名前が v1.0.1 だった場合は、次のようにすると前回のリリース以降のすべてのコミットの概要が得られます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2</code></pre>
</div>
</div>
<div class="paragraph">
<p>v1.0.1 以降のすべてのコミットの概要が、作者別にまとめて得られました。これをメーリングリストに投稿するといいでしょう。</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>