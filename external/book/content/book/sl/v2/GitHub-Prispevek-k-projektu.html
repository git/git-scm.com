---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: sl
  chapter:
    title: GitHub
    number: 6
  section:
    title: Prispevek k projektu
    number: 2
    cs_number: '6.2'
    previous: book/sl/v2/GitHub-Namestitev-in-konfiguracija-računa
    next: book/sl/v2/GitHub-Vzdrževanje-projekta
title: Git - Prispevek k projektu
---
<h2 id="_prispevek_k_projektu">Prispevek k projektu</h2>
<div class="paragraph">
<p>Sedaj, ko je vaš račun nastavljen, pojdimo skozi nekaj podrobnosti, ki bi vam bile lahko koristile pri prispevku k obstoječemu projektu.</p>
</div>
<div class="sect3">
<h3 id="_vejitev_projektov">Vejitev projektov</h3>
<div class="paragraph">
<p>
Če želite prispevati obstoječemu projektu, do katerega nimate pravic potiskanja, lahko naredite »vejitev« (angl. <em>fork</em>) projekta.
Ko razvejite projekt, bo GitHub naredil kopijo projekta, ki ni v celoti vaša; obstoji v vašem imenskem prostoru in nanj lahko potiskate.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Opomba</div>
</td>
<td class="content">
<div class="paragraph">
<p>Zgodovinski izraz za vejitev je bil nekoliko negativen v kontekstu, kar pomeni, da je nekdo usmeril odprtokodni projekt v drugačno smer in včasih ustvaril konkurenčni projekt ter razdvojil ljudi, ki so prispevali.
Na GitHubu je »vejitev« enostavno isti projekt v vašem imenskem prostoru, kar vam omogoča, da javno naredite spremembe k projektu kot način prispevka na bolj odprti način.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>V tem primeru projektom ni treba skrbeti za dodajanje uporabnikov kot sodelavcev, da se jim da dostop potiskanja.
Ljudje lahko vejijo projekt, vanj potiskajo in prispevajo svoje spremembe nazaj v originalni repozitorij z ustvarjanjem zahtevka potega, ki ga bomo pokrili v nadaljevanju.
To odpre temo diskusije s pregledom kode in lastnik ter sodelujoči lahko komunicirata o spremembi, dokler lastnik ni z njo zadovoljen ter jo nato lahko združi v projekt.</p>
</div>
<div class="paragraph">
<p>Da vejite projekt, obiščite spletno stran projekta in kliknite na gumb »Fork« na zgornji desni strani.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/forkbutton.png" >}}" alt="Gumb »Fork«">
</div>
<div class="title">Slika 88. Gumb »Fork«</div>
</div>
<div class="paragraph">
<p>Po nekaj sekundah boste pripeljani na novo stran projekta s svojo lastno kopijo kode.</p>
</div>
</div>
<div class="sect3">
<h3 id="ch06-github_flow">Potek GitHub</h3>
<div class="paragraph">
<p>
GitHub je zasnovan okoli posebnega načina sodelovanja, osredotočenega na zahtevke potegov (angl. <em>pull requests</em>).
Ta način delovanja deluje, bodisi če sodelujete z močno povezano ekipo v enem skupnem repozitoriju ali pa z globalno razpršenim podjetjem ali omrežjem tujcev, ki prispevajo k projektu prek desetin razvejitev.
Osredotočen je na potek dela <a href="{{< relurl "book/sl/v2/ch00/_topic_branch" >}}">Tematske veje</a>, ki je predstavljen v <a href="{{< relurl "book/sl/v2/ch00/ch03-git-branching" >}}">Veje Git</a>.</p>
</div>
<div class="paragraph">
<p>Takole deluje na splošno:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Razvejite projekt.</p>
</li>
<li>
<p>Ustvarite tematsko vejo iz veje <code>master</code>.</p>
</li>
<li>
<p>Naredite nekaj potrditev za izboljšanje projekta.</p>
</li>
<li>
<p>To vejo potisnite v svoj projekt GitHub.</p>
</li>
<li>
<p>Odprite zahtevek potega na GitHubu.</p>
</li>
<li>
<p>Razpravljajte in po potrebi še naprej delajte potrditve.</p>
</li>
<li>
<p>Lastnik projekta združi ali zapre zahtevek potega.</p>
</li>
<li>
<p>Sinhronizirajte posodobljeni <code>master</code> nazaj v svojo razvejitev.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To je v bistvu potek dela upravitelja integracije, ki je predstavljen v <a href="{{< relurl "book/sl/v2/ch00/_integration_manager" >}}">Potek dela s povezovalnim upraviteljem</a>, vendar namesto uporabe elektronske pošte za komuniciranje in pregledovanje sprememb, ekipe uporabljajo orodja na spletnem mestu GitHub.</p>
</div>
<div class="paragraph">
<p>Pojdimo skozi primer predlaganja spremembe v projektu odprte kode, gostujočem na GitHubu, s pomočjo tega poteka.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Namig</div>
</td>
<td class="content">
<div class="paragraph">
<p>Namesto spletnega vmesnika GitHub lahko za večino stvari uporabite uradno orodje <strong>GitHub CLI</strong>.
Orodje lahko uporabljate na sistemih Windows, macOS in Linux.
Za navodila za namestitev in priročnik obiščite <a href="https://cli.github.com/">domačo stran GitHub CLI</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h4 id="_ustvarjanje_zahtevka_potega">Ustvarjanje zahtevka potega</h4>
<div class="paragraph">
<p>Tony išče kodo, ki bi jo lahko izvajal na svojem programabilnem mikrokrmilniku Arduino, in je našel odlično programsko datoteko na GitHubu na <a href="https://github.com/schacon/blink" class="bare" target="_blank" rel="noopener">https://github.com/schacon/blink</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/blink-01-start.png" >}}" alt="Projekt, ki mu želimo prispevati">
</div>
<div class="title">Slika 89. Projekt, ki mu želimo prispevati</div>
</div>
<div class="paragraph">
<p>Edini problem je, da je utripanje prehitro.
Menimo, da je veliko lepše počakati 3 sekunde namesto 1 med vsako spremembo stanja.
Torej izboljšajmo program in ga predložimo nazaj v projekt kot predlagano spremembo.</p>
</div>
<div class="paragraph">
<p>Najprej kliknemo gumb »Fork«, kot je že omenjeno, da dobimo lastno kopijo projekta.
Naše uporabniško ime tukaj je »tonychacon«, torej je naša kopija tega projekta na <code><a href="https://github.com/tonychacon/blink" class="bare">https://github.com/tonychacon/blink</a></code>, kjer ga lahko urejamo.
Lokalno ga bomo klonirali, ustvarili tematsko vejo, naredili spremembo v kodi in nazadnje to spremembo potisnili nazaj na GitHub.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git clone https://github.com/tonychacon/blink <b class="conum">(1)</b>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <b class="conum">(2)</b>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino (macOS) <b class="conum">(3)</b>
# If you're on a Linux system, do this instead:
# $ sed -i 's/1000/3000/' blink.ino <b class="conum">(3)</b>

$ git diff --word-diff <b class="conum">(4)</b>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'Change delay to 3 seconds' <b class="conum">(5)</b>
[slow-blink 5ca509d] Change delay to 3 seconds
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <b class="conum">(6)</b>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -&gt; slow-blink</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Klonirajte svojo razvejitev projekta lokalno.</p>
</li>
<li>
<p>Ustvarite opisno tematsko vejo.</p>
</li>
<li>
<p>Naredite spremembo v kodi.</p>
</li>
<li>
<p>Preverite, da je sprememba dobra.</p>
</li>
<li>
<p>Potrdite spremembo v tematski veji.</p>
</li>
<li>
<p>Potisnite novo tematsko vejo nazaj v svojo razvejitev GitHub.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Če se vrnemo na svojo razvejitev projekta na GitHubu, lahko vidimo, da je GitHub opazil, da smo potisnili novo tematsko vejo in nam predstavi velik zelen gumb, s katerim lahko preverimo svoje spremembe in odpremo zahtevek potega na originalni projekt.</p>
</div>
<div class="paragraph">
<p>Namesto tega lahko greste na stran »Branches« na <code>https://github.com/&lt;user&gt;/&lt;project&gt;/branches</code>, da najdete svojo vejo, in od tam odprete nov zahtevek potega.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/blink-02-pr.png" >}}" alt="Gumb za zahtevek potega">
</div>
<div class="title">Slika 90. Gumb za zahtevek potega</div>
</div>
<div class="paragraph">
<p>
Če kliknemo ta zeleni gumb, bomo videli zaslon, ki nas prosi, da dodelimo svojemu zahtevku potega naslov in opis.
Skoraj vedno se splača v to vložiti nekaj truda, saj dober opis pomaga lastniku originalnega projekta ugotoviti, kaj ste poskušali storiti, ali so vaše predlagane spremembe pravilne in ali bi sprejetje sprememb izboljšalo izvirni projekt.</p>
</div>
<div class="paragraph">
<p>Prav tako vidimo seznam potrditev v svoji tematski veji, ki so »naprej« od glavne veje <code>master</code> (v tem primeru samo ena) in združeno razliko vseh sprememb, ki bodo narejene, če bo ta veja združena s strani lastnika projekta.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/blink-03-pull-request-open.png" >}}" alt="Stran za ustvarjanje zahtevka potega">
</div>
<div class="title">Slika 91. Stran za ustvarjanje zahtevka potega</div>
</div>
<div class="paragraph">
<p>Ko pritisnete gumb »Create pull request« na tej strani, bo lastnik projekta, ki ste ga razvejali, prejel obvestilo, da nekdo predlaga spremembo in bo dobil povezavo do strani, ki vsebuje vse te informacije.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Opomba</div>
</td>
<td class="content">
<div class="paragraph">
<p>Čeprav se zahtevki potega pogosto uporabljajo za javne projekte, kot je ta, ko ima sodelujoči pripravljeno celotno spremembo, se pogosto uporablja tudi v notranjih projektih <em>na začetku</em> razvojnega cikla.
Ker lahko v tematsko vejo še naprej potiskate tudi <strong>po</strong> odprtju zahtevka potega, se ta pogosto odpre zgodaj in uporablja kot način iteracije dela kot skupine znotraj konteksta, namesto da se odpre na koncu postopka.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h4 id="_iteracija_na_zahtevku_potega">Iteracija na zahtevku potega</h4>
<div class="paragraph">
<p>V tem trenutku lahko lastnik projekta pregleda predlagano spremembo in jo združi, zavrne, ali nanjo komentira.
Recimo, da mu je ideja všeč, vendar bi raje imel malo daljši čas za izklop kot vklop luči.</p>
</div>
<div class="paragraph">
<p>Medtem ko se lahko ta pogovor odvija preko e-pošte v potekih dela, predstavljenih v poglavju <a href="{{< relurl "book/sl/v2/ch00/ch05-distributed-git" >}}">Porazdeljeni Git</a>, se na GitHubu to zgodi na spletu.
Lastnik projekta lahko pregleda združeno razliko (angl. <em>diff</em>) in pusti komentar, tako da klikne na katero koli od vrstic.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/blink-04-pr-comment.png" >}}" alt="Komentar na določeni vrstici kode v zahtevku potega">
</div>
<div class="title">Slika 92. Komentar na določeni vrstici kode v zahtevku potega</div>
</div>
<div class="paragraph">
<p>Ko vzdrževalec napiše ta komentar, bo oseba, ki je odprla zahtevek potega (in vsakdo drug, ki spremlja ta repozitorij), prejela obvestilo.
Kasneje bomo opisali, kako lahko prilagodite ta obvestila, vendar če ima Tony vklopljena obvestila po e-pošti, bi prejel e-poštno sporočilo takole:</p>
</div>
<div id="_email_notification" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/blink-04-email.png" >}}" alt="Komentarji poslani kot e-poštna obvestila">
</div>
<div class="title">Slika 93. Komentarji poslani kot e-poštna obvestila</div>
</div>
<div class="paragraph">
<p>Kdor koli lahko tudi pusti splošne komentarje na zahtevku potega.
Na sliki <a href="{{< relurl "book/sl/v2/ch00/_pr_discussion" >}}">Stran za diskusijo zahtevka potega</a> lahko vidimo primer, ko lastnik projekta komentira vrstico kode in nato pusti splošen komentar v razdelku za razpravo.
Vidite lahko, da so komentarji kode prav tako vključeni v pogovor.</p>
</div>
<div id="_pr_discussion" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/blink-05-general-comment.png" >}}" alt="Stran za diskusijo zahtevka potega">
</div>
<div class="title">Slika 94. Stran za diskusijo zahtevka potega</div>
</div>
<div class="paragraph">
<p>Sedaj lahko sodelujoči vidi, kaj mora storiti, da bo njegova sprememba sprejeta.
Na srečo je to zelo preprosto.
Kjer bi morali preko e-pošte ponovno uvrstiti svojo serijo in jo ponovno poslati na seznam za pošiljanje, lahko preko GitHuba preprosto spet potrdite na svoji tematski veji in jo potisnete, kar bo samodejno posodobilo zahtevek potega.
Na sliki <a href="{{< relurl "book/sl/v2/ch00/_pr_final" >}}">Končni zahtevek potega</a> lahko vidite tudi, da je bil star komentar kode zložen v posodobljenem zahtevku potega, saj je bil narejen na vrstici, ki je bila od takrat spremenjena.</p>
</div>
<div class="paragraph">
<p>Dodajanje potrditev k obstoječemu zahtevku potega ne sproži obvestila, zato se Tony odloči, da bo pustil komentar, da obvesti lastnika projekta, da je izvedel zahtevano spremembo.</p>
</div>
<div id="_pr_final" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/blink-06-final.png" >}}" alt="Končni zahtevek potega">
</div>
<div class="title">Slika 95. Končni zahtevek potega</div>
</div>
<div class="paragraph">
<p>Zanimivo je opaziti, da če kliknete na zavihek »Files Changed« na tem zahtevku potega, boste dobili »združeno« razliko — torej skupno razliko, ki bi jo v glavno vejo uvedli, če bi bila ta tematska veja združena.
V pojmu <code>git diff</code> vam to v bistvu avtomatično prikaže <code>git diff master…​&lt;branch&gt;</code> za vejo, na kateri temelji ta zahtevek potega.
Za več informacij o tej vrsti razlike si oglejte razdelek <a href="{{< relurl "book/sl/v2/ch00/_what_is_introduced" >}}">Določanje, kaj se uvaja</a>.</p>
</div>
<div class="paragraph">
<p>Druga stvar, ki jo boste opazili, je, da GitHub preveri, ali se zahtevek potega združi brez težav, in ponudi gumb za izvedbo združevanja na strežniku.
Ta gumb se prikaže le, če imate dostop za pisanje v repozitoriju in če je mogoča trivialna združitev.
Če nanj kliknete, bo GitHub izvedel združitev »non-fast-forward«, kar pomeni, da bo ustvaril potrditev združitve, tudi če <strong>bi lahko</strong> združitev bila hitro previta naprej.</p>
</div>
<div class="paragraph">
<p>Če želite, lahko preprosto povlečete vejo navzdol in jo lokalno združite.
Če to vejo združite v vejo <code>master</code> in jo potisnete na GitHub, bo zahtevek potega samodejno zaprt.</p>
</div>
<div class="paragraph">
<p>To je osnovni potek dela, ki ga uporablja večina projektov na GitHubu.
Ustvarijo se tematske veje, nanje se odprejo zahtevki potegov, sledi razprava, morda se na veji opravi še več dela, dokler zahtevek ni zaprt ali združen.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Opomba</div>
</td>
<td class="content">
<div class="title">Ne samo razvejitve</div>
<div class="paragraph">
<p>Pomembno je omeniti, da lahko odprete zahtevek potega med dvema vejama v istem repozitoriju.
Če delate z nekom na določeni funkciji in imata oba dostop zapisovanja v projekt, lahko potisnete tematsko vejo v repozitorij in odprete zahtevek potega na vejo <code>master</code> tega projekta, da sprožite postopek pregleda kode in razprave.
Ni potrebe po ustvarjanju razvejitve projekta.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_napredni_zahtevki_potegov">Napredni zahtevki potegov</h3>
<div class="paragraph">
<p>Zdaj, ko smo pokrili osnove sodelovanja v projektu na GitHubu, si oglejmo nekaj zanimivih nasvetov in trikov o zahtevkih potegov, tako da boste lahko bolj učinkovito uporabljali to funkcionalnost.</p>
</div>
<div class="sect4">
<h4 id="_zahtevki_potegov_kot_popravki">Zahtevki potegov kot popravki</h4>
<div class="paragraph">
<p>Pomembno je razumeti, da se mnogi projekti ne osredotočajo na zahtevke potegov kot vrste popolnih popravkov, ki se lahko uporabijo brezhibno po vrstnem redu, kot to velja za projekte, ki temeljijo na elektronski pošti.
Večina projektov na GitHubu razmišlja o vejah zahtevkov potegov kot o iterativnih pogovorih o predlagani spremembi, ki se končajo s skupno razliko, ki se uporablja z združevanjem.</p>
</div>
<div class="paragraph">
<p>To je pomembna razlika, saj se sprememba po navadi predlaga, preden se koda šteje za popolno, kar je pri popravkih po serijah, ki temeljijo na elektronski pošti, veliko manj pogosto.
To omogoča prejšnji pogovor z vzdrževalci, da bi prišli do prave rešitve, ki je bolj prizadevanje skupnosti.
Ko se z zahtevkom potega predlaga koda in vzdrževalci ali skupnost predlagajo spremembo, se serija popravkov ponavadi ne prenese na novo, temveč se razlika pošlje kot novo potrditev na veji, kar pomaga pri nadaljnjem pogovoru ob ohranjanju konteksta prejšnjega dela.</p>
</div>
<div class="paragraph">
<p>Na primer, če se vrnete in si ponovno ogledate sliko <a href="{{< relurl "book/sl/v2/ch00/_pr_final" >}}">Končni zahtevek potega</a>, boste opazili, da predlagatelj ni preklopil svoje potrditve in poslal novega zahtevka potega.
Namesto tega je dodal nove potrditve in jih potisnil v obstoječo vejo.
Tako lahko, če se v prihodnosti vrnete in si ogledate ta zahtevek potega, enostavno najdete celoten kontekst odločitev.
Pritisk na gumb »Merge« na spletnem mestu namenoma ustvari potrditev združitve, ki se sklicuje na zahtevek potega, tako da se je enostavno vrniti in preučiti prvotni pogovor, če je to potrebno.</p>
</div>
</div>
<div class="sect4">
<h4 id="_v_koraku_s_povratnim_tokom">V koraku s povratnim tokom</h4>
<div class="paragraph">
<p>Če vaš zahtevek potega zastara ali se na drugačen način ne združi gladko, ga boste želeli popraviti, da ga lahko vzdrževalec enostavno združi.
GitHub bo to preizkusil za vas in vam sporočil na dnu vsakega zahtevka potega, ali je združevanje trivialno ali ne.</p>
</div>
<div id="_pr_fail" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/pr-01-fail.png" >}}" alt="Zahtevek potega se ne združi gladko">
</div>
<div class="title">Slika 96. Zahtevek potega se ne združi gladko</div>
</div>
<div class="paragraph">
<p>Če vidite kaj takega, kot je prikazano na sliki <a href="{{< relurl "book/sl/v2/ch00/_pr_fail" >}}">Zahtevek potega se ne združi gladko</a>, boste želeli popraviti svojo vejo, da se obarva zeleno in vzdrževalcu ne bo treba opravljati dodatnega dela.</p>
</div>
<div class="paragraph">
<p>Imate dve glavni možnosti, da to storite.
Lahko ponovno bazirate svojo vejo na vrhu ciljne veje (običajno veje <code>master</code> repozitorija, ki ste ga klonirali), ali pa ciljno vejo združite v svojo vejo.</p>
</div>
<div class="paragraph">
<p>Večina razvijalcev na GitHubu se odloči za slednjo možnost iz istih razlogov, ki smo jih pravkar obravnavali v prejšnjem odstavku.
Pomembna je zgodovina in končno združevanje, zato ponovno baziranje ne prinaša veliko drugega kot nekoliko bolj čisto zgodovino, v zameno pa je <strong>veliko</strong> težje in bolj nagnjeno k napakam.</p>
</div>
<div class="paragraph">
<p>Če želite združiti ciljno vejo, da bo vaš zahtevek potega združljiv, dodate izvirni repozitorij kot nov oddaljeni vir, ga prenesete, združite glavno vejo tega repozitorija v svojo tematsko vejo, odpravite morebitne težave in ga nazadnje znova naložite v isto vejo, na kateri ste odprli zahtevek potega.</p>
</div>
<div class="paragraph">
<p>Na primer, recimo, da je prvotni avtor v primeru »tonychacon«, ki smo ga uporabljali prej, naredil spremembo, ki bi povzročila konflikt v zahtevku potega.
Pojdimo skozi te korake.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git remote add upstream https://github.com/schacon/blink <b class="conum">(1)</b>

$ git fetch upstream <b class="conum">(2)</b>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -&gt; upstream/master

$ git merge upstream/master <b class="conum">(3)</b>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <b class="conum">(4)</b>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <b class="conum">(5)</b>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -&gt; slow-blink</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Dodajte izvorni repozitorij kot daljavo poimenovano <code>upstream</code>.</p>
</li>
<li>
<p>Pridobite najnovejše delo iz tega oddaljenega vira.</p>
</li>
<li>
<p>Združite glavno vejo tega repozitorija v vašo tematsko vejo.</p>
</li>
<li>
<p>Popravite konflikt, ki se je pojavil.</p>
</li>
<li>
<p>Potisnite nazaj na isto tematsko vejo.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ko to storite, bo zahtevek potega samodejno posodobljen in ponovno preverjen, če se gladko združi.</p>
</div>
<div id="_pr_merge_fix" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/pr-02-merge-fix.png" >}}" alt="Zahtevek potega se sedaj združi gladko">
</div>
<div class="title">Slika 97. Zahtevek potega se sedaj združi gladko</div>
</div>
<div class="paragraph">
<p>Ena od odličnih lastnosti Gita je, da to lahko storite neprekinjeno.
Če imate zelo dolgotrajen projekt, lahko enostavno združujete s ciljno vejo znova in znova ter se ukvarjate le s konflikti, ki so se pojavili od zadnjega združevanja, kar olajša postopek.</p>
</div>
<div class="paragraph">
<p>Če absolutno želite preurediti vejo, da jo očistite, to zagotovo lahko storite, vendar močno priporočamo, da ne potisnete prisilno preko veje, na kateri je že odprt zahtevek potega.
Če so jo druge osebe povlekle in nanjo dodale več dela, se srečate z vsemi težavami, ki so opisane v razdelku <a href="{{< relurl "book/sl/v2/ch00/_rebase_peril" >}}">Nevarnosti ponovnega baziranja</a>.
Namesto tega potisnite ponovno bazirano vejo v novo vejo na GitHubu in odprite povsem nov zahtevek potega, ki se sklicuje na starega, nato pa zaprite izvirnega.</p>
</div>
</div>
<div class="sect4">
<h4 id="_reference">Reference</h4>
<div class="paragraph">
<p>Vaše naslednje vprašanje je morda »Kako se sklicujem na stari zahtevek potega?«.
Izkazalo se je, da obstaja veliko načinov za sklicevanje na druge stvari skoraj povsod, kjer lahko pišete na GitHubu.</p>
</div>
<div class="paragraph">
<p>Začnimo s tem, kako se sklicevati na drugi zahtevek potega ali težavo.
Vse zahtevke potegov in težave imajo dodeljene številke in so edinstvene v projektu.
Na primer, ne morete imeti zahtevka potega #3 in težave #3.
Če se želite sklicevati na kateri koli zahtevek potega ali težavo od drugod, lahko preprosto vstavite #&lt;številka&gt; v kateri koli komentar ali opis.
Lahko pa ste bolj natančni, če je težava ali zahtevek potega drugje; napišite <code>uporabniško_ime#&lt;num&gt;</code>, če se sklicujete na težavo ali zahtevek potega v razvejitvi repozitorija, v katerem ste, ali <code>uporabniško_ime/repo#&lt;num&gt;</code> za sklicevanje na kaj v drugem repozitoriju.</p>
</div>
<div class="paragraph">
<p>Poglejmo primer.
Recimo, da smo preuredili vejo v prejšnjem primeru, ustvarili nov zahtevek potega in zdaj se želimo v novem sklicevati na stari zahtevek potega.
Želimo se tudi sklicevati na težavo v razvejitvi repozitorija in težavo v popolnoma drugem projektu.
Opis lahko izpolnite enako kot v razdelku <a href="{{< relurl "book/sl/v2/ch00/_pr_references" >}}">Navzkrižno sklicevanje v zahtevku potega</a>.</p>
</div>
<div id="_pr_references" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/mentions-01-syntax.png" >}}" alt="Navzkrižno sklicevanje v zahtevku potega">
</div>
<div class="title">Slika 98. Navzkrižno sklicevanje v zahtevku potega</div>
</div>
<div class="paragraph">
<p>Ko bomo oddali ta zahtevek potega, bomo videli, da se bo vse to prikazalo tako kot na sliki <a href="{{< relurl "book/sl/v2/ch00/_pr_references_render" >}}">Navzkrižne reference, upodobljene v zahtevku potega</a>.</p>
</div>
<div id="_pr_references_render" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/mentions-02-render.png" >}}" alt="Navzkrižne reference, upodobljene v zahtevku potega">
</div>
<div class="title">Slika 99. Navzkrižne reference, upodobljene v zahtevku potega</div>
</div>
<div class="paragraph">
<p>Opazite, da se je celoten URL na GitHubu, ki smo ga vnesli, skrajšal le na informacije, ki so potrebne.</p>
</div>
<div class="paragraph">
<p>Če Tony zdaj zapre prvotni zahtevek potega, lahko vidimo, da je GitHub avtomatično ustvaril sledilni dogodek v časovnici zahtevka potega, ker smo ga omenili v novem zahtevku.
To pomeni, da lahko kdorkoli, ki obišče ta zahtevek potega, vidi, da je zaprt, in enostavno poveže nazaj s tistim, ki ga je nadomestil.
Povezava bo videti nekako tako kot na sliki <a href="{{< relurl "book/sl/v2/ch00/_pr_closed" >}}">Povezava nazaj na nov zahtevek potega na zaprti časovnici zahtevka potega</a>.</p>
</div>
<div id="_pr_closed" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/mentions-03-closed.png" >}}" alt="Povezava nazaj na nov zahtevek potega na zaprti časovnici zahtevka potega">
</div>
<div class="title">Slika 100. Povezava nazaj na nov zahtevek potega na zaprti časovnici zahtevka potega</div>
</div>
<div class="paragraph">
<p>Poleg številk težav lahko na enak način kot referenčne oznake uporabimo tudi identifikatorje SHA-1 določenih potrditev.
Pri tem je treba navesti celotnih 40 znakov identifikatorja SHA-1, vendar bo GitHub v komentarju takoj ustvaril povezavo do ustrezne potrditve.
Kot pri težavah lahko tudi pri potrditvah v drugih razvejitvah ali repozitorijih uporabimo enak način referenciranja potrditev.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_github_flavored_markdown">GitHub Flavored Markdown</h3>
<div class="paragraph">
<p>Povezovanje na druge težave je samo začetek zanimivih stvari, ki jih lahko storite s skoraj vsakim besedilnim poljem na GitHubu.
V opisih težav in zahtevkov potegov, komentarjih, komentarjih v kodi in še več, lahko uporabite, kar imenujemo »GitHub Flavored Markdown«.
Markdown je podoben pisanju v navadnem besedilu, vendar je prikazan bogato.</p>
</div>
<div class="paragraph">
<p>Za primer, kako so lahko videti komentarji ali besedilo napisani z Markdownom, si oglejte sliko <a href="{{< relurl "book/sl/v2/ch00/_example_markdown" >}}">Primer GitHub Flavored Markdown, kot je napisan in upodobljen</a>.</p>
</div>
<div id="_example_markdown" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/markdown-01-example.png" >}}" alt="Primer GitHub Flavored Markdown, kot je napisan in upodobljen">
</div>
<div class="title">Slika 101. Primer GitHub Flavored Markdown, kot je napisan in upodobljen</div>
</div>
<div class="paragraph">
<p>GitHub Flavored Markdown dodaja več stvari, ki jih lahko storite poleg osnovne sintakse Markdowna.
Vse te dodatne funkcije so lahko resnično uporabne pri ustvarjanju koristnih komentarjev ali opisov težav in zahtevkov potegov.</p>
</div>
<div class="sect4">
<h4 id="_seznami_opravil">Seznami opravil</h4>
<div class="paragraph">
<p>Prva resnično uporabna funkcija specifična za GitHub Markdown, še posebej za uporabo pri zahtevkih potegov, je seznam opravil.
Seznam opravil je seznam polj z oznakami za stvari, ki jih želite opraviti.
Postavitev seznama v težavo ali zahtevek potega običajno pomeni, da želite te stvari opraviti, preden štejete element za dokončanega.</p>
</div>
<div class="paragraph">
<p>Seznam opravil lahko ustvarite tako:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-markdown" data-lang="markdown">- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če to vključimo v opis zahtevka potega ali težave, bomo videli, da se bo prikazal kot na <a href="{{< relurl "book/sl/v2/ch00/_eg_task_lists" >}}">Seznami opravil, upodobljeni v komentarju Markdown</a>.</p>
</div>
<div id="_eg_task_lists" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/markdown-02-tasks.png" >}}" alt="Seznami opravil, upodobljeni v komentarju Markdown">
</div>
<div class="title">Slika 102. Seznami opravil, upodobljeni v komentarju Markdown</div>
</div>
<div class="paragraph">
<p>To se pogosto uporablja pri zahtevkih potegov, da bi označili, kaj vse bi radi dokončali na veji, preden bo zahtevek potega pripravljen za združevanje.
Res odličen del je, da lahko preprosto kliknete polja z oznakami, da posodobite komentar — ne potrebujete urejanja Markdowna neposredno za označevanje opravil.</p>
</div>
<div class="paragraph">
<p>Poleg tega bo GitHub iskal sezname opravil v vaših težavah in zahtevkih potegov ter jih prikazal kot metapodatke na straneh, ki jih naštevajo.
Na primer, če imate zahtevek potega z nalogami in si ogledate pregledno stran vseh zahtevkov potegov, lahko vidite, kako daleč je že opravljeno.
To pomaga ljudem razbiti zahtevke potegov na podnaloge in drugim ljudem pomagati pri spremljanju napredka veje.
Primer tega lahko vidite na sliki <a href="{{< relurl "book/sl/v2/ch00/_task_list_progress" >}}">Povzetek seznama opravil na seznamu zahtevkov potegov</a>.</p>
</div>
<div id="_task_list_progress" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/markdown-03-task-summary.png" >}}" alt="Povzetek seznama opravil na seznamu zahtevkov potegov">
</div>
<div class="title">Slika 103. Povzetek seznama opravil na seznamu zahtevkov potegov</div>
</div>
<div class="paragraph">
<p>Ti seznami so izjemno uporabni, ko odprete zahtevek potega zgodaj in ga uporabite za spremljanje svojega napredka pri izvedbi funkcionalnosti.</p>
</div>
</div>
<div class="sect4">
<h4 id="_delčki_kode">Delčki kode</h4>
<div class="paragraph">
<p>V komentarje lahko dodate tudi delčke kode.
To je še posebej uporabno, če želite nekaj predstaviti, kar <em>bi lahko</em> poskusili pred dejansko izvedbo kot potrditev na vaši veji.
Pogosto se to uporablja tudi za dodajanje primerne kode o tem, kaj ne deluje, ali kaj bi lahko ta zahtevek potega implementiral.</p>
</div>
<div class="paragraph">
<p>Da dodate delček kode, ga morate »ograditi« v leve črtice.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-markdown" data-lang="markdown">```java
for(int i=0 ; i &lt; 5 ; i++)
{
   System.out.println("i is : " + i);
}
```</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če dodate ime jezika, kot smo to storili z <code>java</code>, bo GitHub poskusil tudi poudariti sintakso delčka kode.
V zgornjem primeru bo prikazan kot <a href="{{< relurl "book/sl/v2/ch00/_md_code" >}}">Primer upodobljene ograjene kode</a>.</p>
</div>
<div id="_md_code" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/markdown-04-fenced-code.png" >}}" alt="Primer upodobljene ograjene kode">
</div>
<div class="title">Slika 104. Primer upodobljene ograjene kode</div>
</div>
</div>
<div class="sect4">
<h4 id="_citiranje">Citiranje</h4>
<div class="paragraph">
<p>Če se odzivate na majhen del dolgega komentarja, lahko selektivno citirate iz drugega komentarja tako, da vrstice predhodno označite z znakom <code>&gt;</code>.
Dejansko je tako običajno in uporabno, da obstaja bližnjica na tipkovnici.
Če v komentarju označite besedilo, na katero želite neposredno odgovoriti, in pritisnete tipko <code>r</code>, bo besedilo citirano v polju za komentarje.</p>
</div>
<div class="paragraph">
<p>Citati so videti nekako takole:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-markdown" data-lang="markdown">&gt; Whether 'tis Nobler in the mind to suffer
&gt; The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ko je komentar prikazan, bo videti nekako tako kot na sliki <a href="{{< relurl "book/sl/v2/ch00/_md_quote" >}}">Prikazan primer citiranja</a>.</p>
</div>
<div id="_md_quote" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/markdown-05-quote.png" >}}" alt="Prikazan primer citiranja">
</div>
<div class="title">Slika 105. Prikazan primer citiranja</div>
</div>
</div>
<div class="sect4">
<h4 id="_emodži">Emodži</h4>
<div class="paragraph">
<p>Končno lahko v svojih komentarjih uporabljate tudi emodžije.
To se dejansko precej pogosto uporablja v komentarjih, ki jih vidite v mnogih težavah in zahtevkih potegov na GitHubu.
Na GitHubu je na voljo tudi pomočnik za emodžije.
Če vnesete komentar in začnete z znakom <code>:</code>, bo pomočnik za samodokončanje pomagal najti tisto, kar iščete.</p>
</div>
<div id="_md_emoji_auto" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/markdown-06-emoji-complete.png" >}}" alt="Samodokončanje emodžijev v delovanju">
</div>
<div class="title">Slika 106. Samodokončanje emodžijev v delovanju</div>
</div>
<div class="paragraph">
<p>Emodžiji imajo obliko <code>:&lt;ime&gt;:</code> kjerkoli v komentarju.
Na primer, napišete lahko nekaj takega:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-markdown" data-lang="markdown">I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ko je prikazano, bi bilo videti nekako tako kot na sliki <a href="{{< relurl "book/sl/v2/ch00/_md_emoji" >}}">Komentiranje z veliko emodžiji</a>.</p>
</div>
<div id="_md_emoji" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/markdown-07-emoji.png" >}}" alt="Komentiranje z veliko emodžiji">
</div>
<div class="title">Slika 107. Komentiranje z veliko emodžiji</div>
</div>
<div class="paragraph">
<p>Čeprav to ni izjemno koristno, vseeno doda element zabave in čustev v medij, v katerem je sicer težko izraziti čustva.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Opomba</div>
</td>
<td class="content">
<div class="paragraph">
<p>Danes obstaja precej spletnih storitev, ki uporabljajo emodžije.
Odličen pripomoček za hitro iskanje emodžijev, ki izražajo, kar želite povedati, lahko najdete na tej spletni strani:</p>
</div>
<div class="paragraph">
<p><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" class="bare" target="_blank" rel="noopener">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h4 id="_slike">Slike</h4>
<div class="paragraph">
<p>To ni tehnično GitHub Flavored Markdown, vendar pa je izjemno koristno.
Poleg dodajanja slikovnih povezav Markdown v komentarje, kar lahko zahteva iskanje in vdelavo URL-jev, vam GitHub omogoča, da slike povlečete in spustite v tekstovna področja, da jih vdelate.</p>
</div>
<div id="_md_drag" class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/markdown-08-drag-drop.png" >}}" alt="Povlecite in spustite slike, da jih naložite in avtomatsko vdelate">
</div>
<div class="title">Slika 108. Povlecite in spustite slike, da jih naložite in avtomatsko vdelate</div>
</div>
<div class="paragraph">
<p>Če pogledate na sliko <a href="{{< relurl "book/sl/v2/ch00/_md_drag" >}}">Povlecite in spustite slike, da jih naložite in avtomatsko vdelate</a>, lahko vidite majhen namig »Parsed as Markdown« nad besedilnim poljem.
Če nanj kliknete, se vam bo prikazal celoten seznam vsega, kar lahko storite z Markdownom na GitHubu.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_fetch_and_push_on_different_repositories">Poskrbite, da bo vaš javni repozitorij GitHub posodobljen</h3>
<div class="paragraph">
<p>Ko enkrat razvejite repozitorij GitHub, bo vaš repozitorij (vaša »razvejitev«) obstajal neodvisno od izvirnega.
Zlasti, ko izvorni repozitorij dobi nove potrditve, vas GitHub obvesti s sporočilom, kot je:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">This branch is 5 commits behind progit:master.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vendar pa vaš repozitorij na GitHubu ne bo nikoli samodejno posodobljen s strani GitHuba; to je nekaj, kar morate storiti sami.
Na srečo je to zelo enostavno.</p>
</div>
<div class="paragraph">
<p>Ena možnost za to ne zahteva nobene konfiguracije.
Na primer, če ste si različico naredili iz <code><a href="https://github.com/progit/progit2.git" class="bare">https://github.com/progit/progit2.git</a></code>, lahko ohranite svojo vejo <code>master</code> posodobljeno na ta način:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master <b class="conum">(1)</b>
$ git pull https://github.com/progit/progit2.git <b class="conum">(2)</b>
$ git push origin master <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Če ste na drugi veji, se vrnite na <code>master</code>.</p>
</li>
<li>
<p>Pridobite spremembe iz <code><a href="https://github.com/progit/progit2.git" class="bare">https://github.com/progit/progit2.git</a></code> in jih združite v <code>master</code>.</p>
</li>
<li>
<p>Potisnite vašo vejo <code>master</code> na <code>origin</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To deluje, vendar je malo dolgočasno vsakič preverjati URL pridobivanja.
To lahko avtomatizirate z nekaj konfiguracije:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add progit https://github.com/progit/progit2.git <b class="conum">(1)</b>
$ git fetch progit <b class="conum">(2)</b>
$ git branch --set-upstream-to=progit/master master <b class="conum">(3)</b>
$ git config --local remote.pushDefault origin <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Dodajte izvorni repozitorij in mu dajte ime.
Tukaj smo izbrali, da ga bomo imenovali <code>progit</code>.</p>
</li>
<li>
<p>Pridobite referenco na veji <code>master</code> repozitorija <code>progit</code>.</p>
</li>
<li>
<p>Nastavite vašo vejo <code>master</code> za prenašanje iz oddaljenega repozitorija <code>progit</code>.</p>
</li>
<li>
<p>Določite privzeti repozitorij za potiskanje na <code>origin</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ko to storite, postane potek dela veliko preprostejši:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master <b class="conum">(1)</b>
$ git pull <b class="conum">(2)</b>
$ git push <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Če ste bili na drugi veji, se vrnite na <code>master</code>.</p>
</li>
<li>
<p>Prenesite spremembe iz <code>progit</code> in jih združite v <code>master</code>.</p>
</li>
<li>
<p>Potisnite vašo vejo <code>master</code> na <code>origin</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ta pristop je lahko uporaben, vendar ima svoje pomanjkljivosti.
Git bo tiho opravil to delo za vas, vendar vas ne bo opozoril, če naredite potrditev na <code>master</code>, povlečete spremembe iz <code>progit</code> in jih potisnete na <code>origin</code> — vse te operacije so veljavne s temi nastavitvami.
Zato se morate izogibati neposrednemu potrjevanju v <code>master</code>, saj ta veja dejansko pripada povratnemu toku (angl. <em>upstream</em>) repozitorija.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>