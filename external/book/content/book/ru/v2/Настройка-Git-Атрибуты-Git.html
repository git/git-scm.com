---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ru
  chapter:
    title: Настройка Git
    number: 8
  section:
    title: Атрибуты Git
    number: 2
    cs_number: '8.2'
    previous: book/ru/v2/Настройка-Git-Конфигурация-Git
    next: book/ru/v2/Настройка-Git-Хуки-в-Git
title: Git - Атрибуты Git
url: "/book/ru/v2/Настройка-Git-Атрибуты-Git.html"
---
<h2 id="_атрибуты_git">Атрибуты Git</h2>
<div class="paragraph">
<p>
Некоторые из настроек могут быть применены к каталогу, поэтому Git применяет их только к подкаталогам или набору файлов.
Настройки, зависящие от пути, называются атрибутами и могут быть установлены либо в файле <code>.gitattributes</code> в любом из каталогов проекта (обычно, в корневом каталоге), либо в файле <code>.git/info/attributes</code>, если вы не хотите хранить их в репозитории вместе с вашим проектом.</p>
</div>
<div class="paragraph">
<p>Используя атрибуты, вы можете настраивать различные стратегии слияния для отдельных файлов или каталогов вашего проекта, указать Git как сравнивать бинарные файлы, настраивать фильтры добавления или извлечения данных из репозитория.
В этом разделе вы узнаете о некоторых атрибутах, которые можно установить для заданных путей в вашем проекте и рассмотрите несколько практических примеров.</p>
</div>
<div class="sect3">
<h3 id="_бинарные_файлы">Бинарные файлы</h3>
<div class="paragraph">
<p>
Интересная возможность атрибутов Git, которая может вам пригодиться, заключается в указании файлов, которые следует считать бинарными (особенно, когда определить это не представляется возможным), и определении инструкций как именно Git должен обрабатывать эти файлы.
Например, некоторые текстовые файлы могут генерироваться автоматически и отследить изменения в них невозможно, в то же время, отследить изменения некоторых бинарных файлов вполне возможно.
Далее вы увидите как объяснить Git где какой файл.</p>
</div>
<div class="sect4">
<h4 id="_идентификация_бинарных_файлов">Идентификация бинарных файлов</h4>
<div class="paragraph">
<p>Некоторые файлы выглядят как текстовые, но работать с ними нужно как с бинарными данными.
Например, проекты Xcode на macOS содержат файл с расширением <code>.pbxproj</code>, который по сути является набором данных JSON (текстовое представление данных JavaScript), сохранённым на диск IDE и содержащим различные настройки проекта.
Технически — это текстовый файл (потому как все данные в UTF-8), фактически — легковесная база данных; отслеживание изменений в нём бесполезно, а слияние изменений — сделанных двумя людьми — невозможно, поэтому вы вряд ли захотите обрабатывать его как текстовый файл.
Файл предназначен для чтения машиной, а не человеком.
Вот почему его следует рассматривать как бинарный.</p>
</div>
<div class="paragraph">
<p>Чтобы Git начал обрабатывать все <code>pbxproj</code> файлы как бинарные, добавьте в файл <code>.gitattributes</code> следующую строку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>*.pbxproj binary</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь, Git не будет конвертировать или исправлять CRLF в этом файле; не будет пытаться определить изменения или выводить их на экран при выполнении команд <code>git show</code> или <code>git diff</code>.</p>
</div>
</div>
<div class="sect4">
<h4 id="_сравнение_бинарных_файлов">Сравнение бинарных файлов</h4>
<div class="paragraph">
<p>Возможности атрибутов Git так же можно использовать для эффективного сравнения бинарных файлов.
Сделать это можно указав Git каким образом конвертировать бинарные данные в текстовый формат, чтобы затем сравнить их обычным способом.</p>
</div>
<div class="paragraph">
<p>Этот подход решает одну из самых досадных проблем, известных человечеству: контроль версий документов Microsoft Word.
Все уже знают, что Word — самый ужасный редактор из всех, но, как ни странно, продолжают его использовать.
Если вы хотите контролировать версии документов Word, то поместите их в Git репозиторий и периодически делайте коммиты; но как это решает проблему?
Если вы просто выполните команду <code>git diff</code>, то увидите следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 88839c4..4afcb7c 100644
Binary files a/chapter1.docx and b/chapter1.docx differ</code></pre>
</div>
</div>
<div class="paragraph">
<p>Нельзя просто взять и сравнить два файла не читая их и не сравнивая вручную, так?
Это становится возможным при использовании атрибутов Git.
Добавьте в файл <code>.gitattributes</code> следующую строку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">*.docx diff=word</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это говорит Git, что нужно использовать фильтр  «word» при просмотре изменений файлов, соответствующих шаблону <code>.docx</code>.
Что такое «word» фильтр?
Вам следует его настроить.
Нужно сконфигурировать Git на использование программы <code>docx2txt</code> для конвертации документов Word в текстовые, которые можно корректно сравнивать.</p>
</div>
<div class="paragraph">
<p>Для начала, нужно установить программу <code>docx2txt</code>; вы можете скачать её здесь <a href="https://sourceforge.net/projects/docx2txt" class="bare" target="_blank" rel="noopener">https://sourceforge.net/projects/docx2txt</a>.
Следуйте инструкциям из файла <code>INSTALL</code> для её установки и настройки запуска из командной строки.
Затем следует написать скрипт обёртку для конвертации вывода программы в формат, понятный Git.
Создайте файл <code>docx2txt</code> в любом доступном для запуска месте и добавьте в него следующее содержимое (прим. пер.: применимо для Linux и Mac):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">#!/bin/bash
docx2txt.pl "$1" -</code></pre>
</div>
</div>
<div class="paragraph">
<p>Не забудьте добавить права запуска для созданного файла.
Наконец, настройте Git на использование созданного скрипта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config diff.word.textconv docx2txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь Git знает, что при сравнении двух коммитов, имена файлов в которых заканчиваются на <code>.docx</code>, он должен обработать эти файлы с помощью фильтра «word», который определён как программа <code>docx2txt</code>.
Это позволяет автоматически генерировать текстовые версии файлов Word и только потом их сравнивать.</p>
</div>
<div class="paragraph">
<p>Для примера, первый раздел этой книги был сохранён в формате Word и добавлен в Git репозиторий.
Затем был добавлен новый абзац.
Вот что покажет команда <code>git diff</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 0b013ca..ba25db5 100644
--- a/chapter1.docx
+++ b/chapter1.docx
@@ -2,6 +2,7 @@
 This chapter will be about getting started with Git. We will begin at the beginning by explaining some background on version control tools, then move on to how to get Git running on your system and finally how to get it setup to start working with. At the end of this chapter you should understand why Git is around, why you should use it and you should be all setup to do so.
 1.1. About Version Control
 What is "version control", and why should you care? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. For the examples in this book you will use software source code as the files being version controlled, though in reality you can do this with nearly any type of file on a computer.
+Testing: 1, 2, 3.
 If you are a graphic or web designer and want to keep every version of an image or layout (which you would most certainly want to), a Version Control System (VCS) is a very wise thing to use. It allows you to revert files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In addition, you get all this for very little overhead.
 1.1.1. Local Version Control Systems
 Many people's version-control method of choice is to copy files into another directory (perhaps a time-stamped directory, if they're clever). This approach is very common because it is so simple, but it is also incredibly error prone. It is easy to forget which directory you're in and accidentally write to the wrong file or copy over files you don't mean to.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git кратко сообщает нам, что была добавлена строка «Testing: 1, 2, 3.».
Решение не идеальное — изменения форматирования не отображаются — но это работает.</p>
</div>
<div class="paragraph">
<p>Проблему сравнения файлов изображений можно решить аналогичным образом.
Один из способов реализации заключается в передаче изображения на фильтр для извлечения EXIF информации — метаданных, которые сохраняются для большинства форматов изображений.
Скачав и установив программу <code>exiftool</code>, вы сможете использовать её для конвертации изображений в текстовые метаданные, изменение которых будет являться текстовым представлением изменений изображений.
Добавьте следующую строку в ваш файл <code>.gitattributes</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">*.png diff=exif</code></pre>
</div>
</div>
<div class="paragraph">
<p>Настройте Git на использование этой программы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config diff.exif.textconv exiftool</code></pre>
</div>
</div>
<div class="paragraph">
<p>Заменив картинку и выполнив команду <code>git diff</code>, вы увидите что-то похожее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>diff --git a/image.png b/image.png
index 88839c4..4afcb7c 100644
--- a/image.png
+++ b/image.png
@@ -1,12 +1,12 @@
 ExifTool Version Number         : 7.74
-File Size                       : 70 kB
-File Modification Date/Time     : 2009:04:21 07:02:45-07:00
+File Size                       : 94 kB
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
 File Type                       : PNG
 MIME Type                       : image/png
-Image Width                     : 1058
-Image Height                    : 889
+Image Width                     : 1056
+Image Height                    : 827
 Bit Depth                       : 8
 Color Type                      : RGB with Alpha</code></pre>
</div>
</div>
<div class="paragraph">
<p>Легко заметить, что размеры изображения и файла изменились.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="r_keyword_expansion">Разворачивание ключевых слов</h3>
<div class="paragraph">
<p>
Разработчики часто хотят использовать разворачивание ключевых слов в стиле SVN или CVS.
Основная проблема в Git — это невозможность изменять файлы с информацией о коммите после его совершения, так как Git сначала вычисляет контрольную сумму.
Однако, вы можете добавить текст в файл после извлечения и убрать его перед добавлением файла в коммит.
Атрибуты Git позволяют это сделать двумя способами.</p>
</div>
<div class="paragraph">
<p>Для начала, вы можете автоматически добавлять SHA-1-хеш объекта в поле <code>$Id$</code>.
Если установить этот атрибут для одного или нескольких файлов, то каждый раз при извлечении ветки Git будет заменять это поле на SHA-1-хеш объекта.
Важно заметить, что это SHA-1-хеш не коммита, а самого объекта.
Добавьте следующую строку в ваш файл <code>.gitattributes</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">*.txt ident</code></pre>
</div>
</div>
<div class="paragraph">
<p>Добавьте ссылку на <code>$Id$</code> в тестовый файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo '$Id$' &gt; test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>При последующих извлечениях Git будет добавлять SHA-1-хеш объекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm test.txt
$ git checkout -- test.txt
$ cat test.txt
$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $</code></pre>
</div>
</div>
<div class="paragraph">
<p>Однако, этот результат имеет ограниченное применение.
Если вы использовали подстановку ключевых слов в CVS или Subversion, то вы могли включать метку времени, а SHA-1-хеш не так полезен, потому что вы не можете сказать какой из двух хешей старше, а какой новее просто взглянув на них.</p>
</div>
<div class="paragraph">
<p>Оказывается, вы можете написать свои фильтры для выполнения подстановок в файлах в момент коммита/извлечения.
Эти фильтры называются «clean» и «smudge».
В файле <code>.gitattributes</code> вы можете установить фильтр для конкретных путей, а затем указать скрипты для обработки файлов при извлечении («smudge», смотри <a href="{{< relurl "book/ru/v2/ch00/rfilters_a" >}}">Фильтр «smudge» применяется при извлечении</a>) и при индексировании («clean», смотри <a href="{{< relurl "book/ru/v2/ch00/rfilters_b" >}}">Фильтр «clean» применяется при индексации</a>).
С помощью этих фильтров можно делать всевозможные операции.</p>
</div>
<div id="rfilters_a" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/smudge.png" >}}" alt="Фильтр «smudge» применяется при извлечении">
</div>
<div class="title">Рисунок 143. Фильтр «smudge» применяется при извлечении</div>
</div>
<div id="rfilters_b" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/clean.png" >}}" alt="Фильтр «clean» применяется при индексации">
</div>
<div class="title">Рисунок 144. Фильтр «clean» применяется при индексации</div>
</div>
<div class="paragraph">
<p>Исходное сообщение коммита является простым примером как передать весь ваш код на С программе <code>indent</code> перед коммитом.
Это можно настроить путём указания фильтра «indent» в файле <code>.gitattributes</code> для файлов <code>*.c</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>*.c filter=indent</code></pre>
</div>
</div>
<div class="paragraph">
<p>Затем скажите Git что должен делать фильтр «indent» на стадиях smudge и clean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global filter.indent.clean indent
$ git config --global filter.indent.smudge cat</code></pre>
</div>
</div>
<div class="paragraph">
<p>В таком случае, Git будет обрабатывать файлы программой <code>indent</code> все файлы по маске <code>*.c</code> перед тем, как добавить их в индекс; и наоборот, обрабатывать эти же файлы программой <code>cat</code> при их извлечении.
По сути, программа <code>cat</code> ничего не делает: она возвращает те же данные, что и получает на вход.
Указанная комбинация позволяет эффективно обрабатывать файлы с исходным кодом на С программой <code>indent</code> перед коммитом.</p>
</div>
<div class="paragraph">
<p>Другой интересный пример — это подстановка ключевого слова <code>$Date$</code> в стиле системы контроля ревизий.
Чтобы правильно это реализовать, вам нужен простой скрипт, который получает имя файла, определяет дату последнего коммита и вставляет её в файл.
Ниже приведён небольшой пример такого скрипта на Ruby:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby
data = STDIN.read
last_date = `git log --pretty=format:"%ad" -1`
puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Всё, что делает скрипт — это получает дату последнего коммита с помощью команды <code>git log</code>, заменяет результатом все подстроки <code>$Date$</code> и возвращает итоговый результат; вы можете написать аналогичный скрипт на любом языке.
Назовите файл со скриптом, например, <code>expand_date</code> и сохраните в каталоге с программами.
Теперь, нужно настроить Git фильтр (назовите его <code>dater</code>) и укажите ему использовать ваш скрипт <code>expand_date</code> при извлечении файлов.
Вместе с этим, мы будем использовать регулярное выражение Perl для очистки перед коммитом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config filter.dater.smudge expand_date
$ git config filter.dater.clean 'perl -pe "s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/"'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Указанная Perl команда очищает любое значение в строке, где она видит <code>$Date$</code>, чтобы вернуть файл в изначальное состояние.
Теперь фильтр готов и вы можете проверить его добавив ключевое слово <code>$Date$</code> в файл и настроив Git атрибут, чтобы для вашего файла применялся созданный фильтр:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">date*.txt filter=dater</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo '# $Date$' &gt; date_test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если добавить в коммит последние изменения, а затем извлечь файл, то вы увидите корректную подстановку ключевого слова:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add date_test.txt .gitattributes
$ git commit -m "Test date expansion in Git"
$ rm date_test.txt
$ git checkout date_test.txt
$ cat date_test.txt
# $Date: Tue Apr 21 07:26:52 2009 -0700$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как вы могли заметить, описанный подход предоставляет большие возможности.
Однако, вам стоит быть осторожным, так как файл <code>.gitattributes</code> включается в коммит и распространяется вместе с проектом, а драйвер (в данном случае <code>dater</code>) нет, поэтому он не будет работать везде.
Учитывайте это при разработке фильтров оставляя возможность работы без них — так вы сохраните проект в рабочем состоянии.</p>
</div>
</div>
<div class="sect3">
<h3 id="_экспорт_репозитория">Экспорт репозитория</h3>
<div class="paragraph">
<p>
Атрибуты Git так же позволяют вам делать некоторые интересные вещи при экспорте вашего проекта.</p>
</div>
<div class="sect4">
<h4 id="_export_ignore"><code>export-ignore</code></h4>
<div class="paragraph">
<p>Вы можете указать Git игнорировать определённые файлы и каталоги при создании архива.
Если в вашем проекте есть файл или каталог, которые вам нужны, но вы не хотите включать их в архив при экспорте, то можно присвоить им атрибут <code>export-ignore</code>.</p>
</div>
<div class="paragraph">
<p>Например, у вас есть несколько файлов в каталоге <code>test/</code> и совершенно нет смысла включать их в архив вашего проекта.
В этом случае достаточно добавить следующую строку в файл <code>.gitattributes</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">test/ export-ignore</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь, при создании архива проекта командой <code>git archive</code>, каталог <code>test/</code> не будет включен в архив.</p>
</div>
</div>
<div class="sect4">
<h4 id="_export_subst"><code>export-subst</code></h4>
<div class="paragraph">
<p>При создании архива так же доступна подстановка по ключевым словам и поддерживается использование форматирования <code>git log</code> для файлов, отмеченных атрибутом <code>export-subst</code>.</p>
</div>
<div class="paragraph">
<p>Например, если вы хотите добавить в проект файл с именем <code>LAST_COMMIT</code>, в который при экспорте будут автоматически сохраняться метаданные последнего коммита, то измените файлы <code>.gitattributes</code> и <code>LAST_COMMIT</code> следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">LAST_COMMIT export-subst</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'Last commit date: $Format:%cd by %aN$' &gt; LAST_COMMIT
$ git add LAST_COMMIT .gitattributes
$ git commit -am 'adding LAST_COMMIT file for archives'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь, при создании архива проекта командой <code>git archive</code>, в него будет включён файл со следующим содержанием:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git archive HEAD | tar xCf ../deployment-testing -
$ cat ../deployment-testing/LAST_COMMIT
Last commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon</code></pre>
</div>
</div>
<div class="paragraph">
<p>В качестве подстановок можно использовать, например, сообщение коммита и <code>git notes</code>, а <code>git log</code> может делать простой перенос слов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo '$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$' &gt; LAST_COMMIT
$ git commit -am 'export-subst uses git log'\''s custom formatter

git archive uses git log'\''s `pretty=format:` processor
directly, and strips the surrounding `$Format:` and `$`
markup from the output.
'
$ git archive @ | tar xfO - LAST_COMMIT
Last commit: 312ccc8 by Jim Hill at Fri May 8 09:14:04 2015 -0700
       export-subst uses git log's custom formatter

         git archive uses git log's `pretty=format:` processor directly, and
         strips the surrounding `$Format:` and `$` markup from the output.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Полученный архив подходит для использования, но как и любой экспортированный архив не годится для дальнейшей разработки.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_стратегии_слияния">Стратегии слияния</h3>
<div class="paragraph">
<p>
Используя атрибуты Git можно применять разные стратегии слияния для разных типов файлов вашего проекта.
Одна из полезных опций — это указать Git не сливать изменения в определённых файлах в случае конфликта, при этом использовать вашу версию файла.</p>
</div>
<div class="paragraph">
<p>Это полезно в случае, когда ветка разошлась или у вас специализированная ветка, при этом вы хотите иметь возможность сливать изменения, но игнорировать определённые файлы.
Предположим, что у вас есть файл с настройками базы данных <code>database.xml</code>, содержимое которого в разных ветках отличается, при этом вы хотите сливать изменения из другой ветки не меняя этот файл.
Для этого нужно добавить следующий атрибут:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">database.xml merge=ours</code></pre>
</div>
</div>
<div class="paragraph">
<p>А затем определить фиктивную стратегию слияния <code>ours</code>, выполнив команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.ours.driver true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если вы сольёте изменения из другой ветки, то вместо конфликта слияния для файла <code>database.xml</code> вы увидите что-то вроде этого:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge topic
Auto-merging database.xml
Merge made by recursive.</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае файл <code>database.xml</code> всегда остаётся неизменным.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>