---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ru
  chapter:
    title: Инструменты Git
    number: 7
  section:
    title: Продвинутое слияние
    number: 8
    cs_number: '7.8'
    previous: book/ru/v2/Инструменты-Git-Раскрытие-тайн-reset
    next: book/ru/v2/Инструменты-Git-Rerere
title: Git - Продвинутое слияние
url: "/book/ru/v2/Инструменты-Git-Продвинутое-слияние.html"
---
<h2 id="r_advanced_merging">Продвинутое слияние</h2>
<div class="paragraph">
<p>Обычно выполнять слияния в Git довольно легко.
Git упрощает повторные слияния с одной и той же веткой, таким образом, позволяя вам иметь очень долго живущую ветку, и вы можете сохранять её всё это время в актуальном состоянии, часто разрешая маленькие конфликты, а не доводить дело до одного большого конфликта по завершению всех изменений.</p>
</div>
<div class="paragraph">
<p>Однако, иногда всё же будут возникать сложные конфликты.
В отличие от других систем управления версиями, Git не пытается быть слишком умным при разрешении конфликтов слияния.
Философия Git заключается в том, чтобы быть умным, когда слияние разрешается однозначно, но если возникает конфликт, он не пытается сумничать и разрешить его автоматически.
Поэтому, если вы слишком долго откладываете слияние двух быстрорастущих веток, вы можете столкнуться с некоторыми проблемами.</p>
</div>
<div class="paragraph">
<p>В этом разделе мы рассмотрим некоторые из возможных проблем и инструменты, которые предоставляет Git, чтобы помочь вам справиться с этими более сложными ситуациями.
Мы также рассмотрим некоторые другие нестандартные типы слияний, которые вы можете выполнять, и вы узнаете как можно откатить уже выполненные слияния.</p>
</div>
<div class="sect3">
<h3 id="_конфликты_слияния">Конфликты слияния</h3>
<div class="paragraph">
<p>Мы рассказали некоторые основы разрешения конфликтов слияния в <a href="{{< relurl "book/ru/v2/ch00/r_basic_merge_conflicts" >}}">Основные конфликты слияния</a>, для работы с более сложными конфликтами Git предоставляет несколько инструментов, которые помогут вам понять, что произошло и как лучше обойтись с конфликтом.</p>
</div>
<div class="paragraph">
<p>Во-первых, если есть возможность, перед слиянием, в котором может возникнуть конфликт, позаботьтесь о том, чтобы ваша рабочая копия была без локальных изменений.
Если у вас есть несохранённые наработки, либо припрячьте их, либо сохраните их во временной ветке.
Таким образом, вы сможете легко отменить <strong>любые</strong> изменения, которые сделаете в рабочем каталоге.
Если при выполнении слияния вы не сохраните сделанные изменения, то некоторые из описанных ниже приёмов могут привести к утрате этих наработок.</p>
</div>
<div class="paragraph">
<p>Давайте рассмотрим очень простой пример.
Допустим, у нас есть файл с исходниками на Ruby, выводящими на экран строку 'hello world'.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>В нашем репозитории, мы создадим новую ветку по имени <code>whitespace</code> и выполним замену всех окончаний строк в стиле Unix на окончания строк в стиле DOS.
Фактически, изменения будут внесены в каждую строку, но изменятся только пробельные символы.
Затем мы заменим строку «hello world» на «hello mundo».</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'Convert hello.rb to DOS'
[whitespace 3270f76] Convert hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'Use Spanish instead of English'
[whitespace 6d338d2] Use Spanish instead of English
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь мы переключимся обратно на ветку <code>master</code> и добавим к функции некоторую документацию.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'Add comment documenting the function'
[master bec6336] Add comment documenting the function
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь мы попытаемся слить в текущую ветку <code>whitespace</code> и в результате получим конфликты, так как изменились пробельные символы.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="sect4">
<h4 id="r_abort_merge">Прерывание слияния</h4>
<div class="paragraph">
<p>В данный момент у нас есть несколько вариантов дальнейших действий.
Во-первых, давайте рассмотрим как выйти из этой ситуации.
Если вы, возможно, не были готовы к конфликтам и на самом деле не хотите связываться с ними, вы можете просто отменить попытку слияния, используя команду <code>git merge --abort</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эта команда пытается откатить ваше состояние до того, что было до запуска слияния.
Завершиться неудачно она может только в случаях, если перед запуском слияния у вас были не припрятанные или не зафиксированные изменения в рабочем каталоге, во всех остальных случаях всё будет хорошо.</p>
</div>
<div class="paragraph">
<p>Если по каким-то причинам вы обнаружили себя в ужасном состоянии и хотите просто начать всё сначала, вы можете также выполнить <code>git reset --hard HEAD</code> (либо вместо <code>HEAD</code> указав то, куда вы хотите откатиться).
Но помните, что это откатит все изменения в рабочем каталоге, поэтому удостоверьтесь, что никакие из них вам не нужны.</p>
</div>
</div>
<div class="sect4">
<h4 id="_игнорирование_пробельных_символов">Игнорирование пробельных символов</h4>
<div class="paragraph">
<p>В данном конкретном случае конфликты связаны с пробельными символами.
Мы знаем это, так как это простой пример, но в реальных ситуациях это также легко определить при изучении конфликта, так как каждая строка в нём будет удалена и добавлена снова.
По умолчанию Git считает все эти строки изменёнными и поэтому не может слить файлы.</p>
</div>
<div class="paragraph">
<p>Стратегии слияния, используемой по умолчанию, можно передать аргументы, и некоторые из них предназначены для соответствующей настройки игнорирования изменений пробельных символов.
Если вы видите, что множество конфликтов слияния вызваны пробельными символами, то вы можете прервать слияние и запустить его снова, но на этот раз с опцией <code>-Xignore-all-space</code> или <code>-Xignore-space-change</code>.
Первая опция игнорирует изменения в любом <strong>количестве</strong> существующих пробельных символов, вторая игнорирует вообще все изменения пробельных символов.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Поскольку в этом примере реальные изменения файлов не конфликтуют, то при игнорировании изменений пробельных символов всё сольётся хорошо.</p>
</div>
<div class="paragraph">
<p>Это значительно облегчает жизнь, если кто-то в вашей команде любит временами заменять все пробелы на табуляции или наоборот.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_manual_remerge">Ручное слияние файлов</h4>
<div class="paragraph">
<p>Хотя Git довольно хорошо обрабатывает пробельные символы, с другими типами изменений он не может справиться автоматически, но существуют другие варианты исправления.
Например, представим, что Git не умеет обрабатывать изменения пробельных символов и нам нужно сделать это вручную.</p>
</div>
<div class="paragraph">
<p>То что нам действительно нужно — это перед выполнением самого слияния прогнать сливаемый файл через программу <code>dos2unix</code>.
Как мы будем делать это?</p>
</div>
<div class="paragraph">
<p>Во-первых, мы перейдём в состояние конфликта слияния.
Затем нам необходимо получить копии <em>нашей</em> версии файла, <em>их</em> версии файла (из ветки, которую мы сливаем) и <em>общей</em> версии (от которой ответвились первые две).
Затем мы исправим либо их версию, либо нашу и повторим слияние только для этого файла.</p>
</div>
<div class="paragraph">
<p>Получить эти три версии файла, на самом деле, довольно легко.
Git хранит все эти версии в индексе в разных «состояниях», каждое из которых имеет ассоциированный с ним номер.
Состояние 1 — это общий предок, состояние 2 — ваша версия и состояния 3 взято из <code>MERGE_HEAD</code> — версия, которую вы сливаете («их» версия).</p>
</div>
<div class="paragraph">
<p>Вы можете извлечь копию каждой из этих версий конфликтующего файла с помощью команды <code>git show</code> и специального синтаксиса.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если вы хотите что-то более суровое, то можете также воспользоваться служебной командой <code>ls-files -u</code> для получения SHA-1 хешей для каждого из этих файлов.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Выражение <code>:1:hello.rb</code> является просто сокращением для поиска такого SHA-1 хеша.</p>
</div>
<div class="paragraph">
<p>Теперь, когда в нашем рабочем каталоге присутствует содержимое всех трёх состояний, мы можем вручную исправить их, чтобы устранить проблемы с пробельными символами и повторно выполнить слияние с помощью малоизвестной команды <code>git merge-file</code>, которая делает именно это.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь у нас есть корректно слитый файл.
На самом деле, данный способ лучше, чем использование опции <code>ignore-all-space</code>, так как в его рамках вместо игнорирования изменений пробельных символов перед слиянием выполняется корректное исправление таких изменений.
При слиянии с <code>ignore-all-space</code> мы в результате получим несколько строк с окончаниями в стиле DOS, то есть в одном файле смешаются разные стили окончания строк.</p>
</div>
<div class="paragraph">
<p>Если перед коммитом изменений вы хотите посмотреть какие в действительности были различия между состояниями, то можете воспользоваться командой <code>git diff</code>, сравнивающей содержимое вашего рабочего каталога, которое будет зафиксировано как результат слияния, с любым из трёх состояний.
Давайте посмотрим на все эти сравнения.</p>
</div>
<div class="paragraph">
<p>Чтобы сравнить результат слияния с тем, что было в вашей ветке до слияния, или другими словами увидеть, что привнесло данное слияние, вы можете выполнить <code>git diff --ours</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Итак, здесь мы можем легко увидеть что же произошло с нашей веткой, какие изменения в действительности внесло слияние в данный файл — изменение только одной строки.</p>
</div>
<div class="paragraph">
<p>Если вы хотите узнать чем результат слияния отличается от сливаемой ветки, то можете выполнить команду <code>git diff --theirs</code>.
В этом и следующем примере мы используем опцию <code>-w</code> для того, чтобы не учитывать изменения в пробельных символах, так как мы сравниваем результат с тем, что есть в Git, а не с нашим исправленным файлом <code>hello.theirs.rb</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>И, наконец, вы можете узнать как изменился файл по сравнению сразу с обеими ветками с помощью команды <code>git diff --base</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данный момент мы можем использовать команду <code>git clean</code> для того, чтобы удалить не нужные более дополнительные файлы, созданные нами для выполнения слияния.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="r_checking_out_conflicts">Использование команды <code>checkout</code> в конфликтах</h4>
<div class="paragraph">
<p>Возможно, нас по каким-то причинам не устраивает необходимость выполнения слияния в текущий момент, или мы не можем хорошо исправить конфликт и нам необходимо больше информации.</p>
</div>
<div class="paragraph">
<p>Давайте немного изменим пример.
Предположим, что у нас есть две долгоживущих ветки, каждая из которых имеет несколько коммитов, что при слиянии приводит к справедливому конфликту.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) Update README
* 9af9d3b Create README
* 694971d Update phrase to 'hola world'
| * e3eb223 (mundo) Add more tests
| * 7cff591 Create initial testing script
| * c3ffff1 Change text to 'hello mundo'
|/
* b7dcc89 Initial hello world code</code></pre>
</div>
</div>
<div class="paragraph">
<p>У нас есть три уникальных коммита, которые присутствуют только в ветке <code>master</code> и три других, которые присутствуют в ветке <code>mundo</code>.
Если мы попытаемся слить ветку <code>mundo</code>, то получим конфликт.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Мы хотели бы увидеть в чем состоит данный конфликт.
Если мы откроем конфликтующий файл, то увидим нечто подобное:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>В обеих сливаемых ветках в этот файл было добавлено содержимое, но в некоторых коммитах изменялись одни и те же строки, что и привело к конфликту.</p>
</div>
<div class="paragraph">
<p>Давайте рассмотрим несколько находящихся в вашем распоряжении инструментов, которые позволяют определить как возник этот конфликт.
Возможно, не понятно как именно вы должны исправить конфликт и вам требуется больше информации.</p>
</div>
<div class="paragraph">
<p>Полезным в данном случае инструментом является команда <code>git checkout</code> с опцией <code>--conflict</code>.
Она заново выкачает файл и заменит маркеры конфликта.
Это может быть полезно, если вы хотите восстановить маркеры конфликта и попробовать разрешить его снова.</p>
</div>
<div class="paragraph">
<p>В качестве значения опции <code>--conflict</code> вы можете указывать <code>diff3</code> или <code>merge</code> (последнее значение используется по умолчанию).
Если вы укажете <code>diff3</code>, Git будет использовать немного другую версию маркеров конфликта — помимо «нашей» и «их» версий файлов будет также отображена «базовая» версия, и таким образом вы получите больше информации.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --conflict=diff3 hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>После того, как вы выполните эту команду, файл будет выглядеть так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если вам нравится такой формат вывода, то вы можете использовать его по умолчанию для будущих конфликтов слияния, установив параметру <code>merge.conflictstyle</code> значение <code>diff3</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.conflictstyle diff3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Команде <code>git checkout</code> также можно передать опции <code>--ours</code> и <code>--theirs</code>, которые позволяют действительно быстро выбрать одну из версий файлов, не выполняя слияния совсем.</p>
</div>
<div class="paragraph">
<p>Это может быть действительно полезным при возникновении конфликтов в бинарных файлах (в этом случае вы можете просто выбрать одну из версий), или при необходимости слить из другой ветки только некоторые файлы (в этом случае вы можете выполнить слияние, а затем перед коммитом переключить нужные файлы на требуемые версии).</p>
</div>
</div>
<div class="sect4">
<h4 id="r_merge_log">История при слиянии</h4>
<div class="paragraph">
<p>Другой полезный инструмент при разрешении конфликтов слияния — это команда <code>git log</code>.
Она поможет вам получить информацию о том, что могло привести к возникновению конфликтов.
Временами может быть очень полезным просмотреть историю, чтобы понять почему в двух ветках разработки изменялась одна и та же область кода.</p>
</div>
<div class="paragraph">
<p>Для получения полного списка всех уникальных коммитов, которые были сделаны в любой из сливаемых веток, мы можем использовать синтаксис «трёх точек», который мы изучили в <a href="{{< relurl "book/ru/v2/ch00/r_triple_dot" >}}">Три точки</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right HEAD...MERGE_HEAD
&lt; f1270f7 Update README
&lt; 9af9d3b Create README
&lt; 694971d Update phrase to 'hola world'
&gt; e3eb223 Add more tests
&gt; 7cff591 Create initial testing script
&gt; c3ffff1 Change text to 'hello mundo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это список всех шести коммитов, включённых в слияние, с указанием также ветки разработки, в которой находится каждый из коммитов.</p>
</div>
<div class="paragraph">
<p>Мы также можем сократить его, попросив предоставить нам более специализированную информацию.
Если мы добавим опцию <code>--merge</code> к команде <code>git log</code>, то она покажет нам только те коммиты, в которых изменялся конфликтующий в данный момент файл.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right --merge
&lt; 694971d Update phrase to 'hola world'
&gt; c3ffff1 Change text to 'hello mundo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если вы выполните эту команду с опцией <code>-p</code>, то получите только список изменений файла, на котором возник конфликт.
Это может быть <strong>действительно</strong> полезным для быстрого получения информации, которая необходима, чтобы понять почему что-либо конфликтует и как наиболее правильно это разрешить.</p>
</div>
</div>
<div class="sect4">
<h4 id="_комбинированный_формат_изменений">Комбинированный формат изменений</h4>
<div class="paragraph">
<p>Так как Git добавляет в индекс все успешные результаты слияния, то при вызове <code>git diff</code> в состоянии конфликта слияния будет отображено только то, что сейчас конфликтует.
Это может быть полезно, так как вы сможете увидеть какие ещё конфликты нужно разрешить.</p>
</div>
<div class="paragraph">
<p>Если вы выполните <code>git diff</code> сразу после конфликта слияния, то получите информацию в довольно своеобразном формате.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Такой формат называется «комбинированным» («Combined Diff»), для каждого различия в нём содержится два раздела с информацией.
В первом разделе отображены различия строки (добавлена она или удалена) между «вашей» веткой и содержимым вашего рабочего каталога, а во втором разделе содержится то же самое, но между «их» веткой и рабочим каталогом.</p>
</div>
<div class="paragraph">
<p>Таким образом, в данном примере вы можете увидеть строки <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> и <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> в файле в вашем рабочем каталоге, хотя они отсутствовали в сливаемых ветках.
Это вполне оправдано, потому что, добавляя их, инструмент слияния предоставляет вам дополнительную информацию, но предполагается, что мы удалим их.</p>
</div>
<div class="paragraph">
<p>Если мы разрешим конфликт и снова выполним команду <code>git diff</code>, то получим ту же информацию, но в немного более полезном представлении.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом выводе указано, что строка «hola world» при слиянии присутствовала в «нашей» ветке, но отсутствовала в рабочей копии, строка «hello mundo» была в «их» ветке, но не в рабочей копии, и, наконец, «hola mundo» не была ни в одной из сливаемых веток, но сейчас присутствует в рабочей копии.
Это бывает полезно просмотреть перед коммитом разрешения конфликта.</p>
</div>
<div class="paragraph">
<p>Такую же информацию вы можете получить и после выполнения слияния с помощью команды <code>git log</code>, узнав таким образом как был разрешён конфликт.
Git выводит информацию в таком формате, если вы выполните <code>git show</code> для коммита слияния или вызовете команду <code>git log -p</code> с опцией <code>--cc</code> (без неё данная команда не показывает изменения для коммитов слияния).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="r_undoing_merges">Отмена слияний</h3>
<div class="paragraph">
<p>Теперь когда вы знаете как создать коммит слияния, вы можете сделать его по ошибке.
Одна из замечательных вещей в работе с Git — это то, что ошибки совершать не страшно, так как есть возможность исправить их (и в большинстве случаев сделать это просто).</p>
</div>
<div class="paragraph">
<p>Коммит слияния не исключение.
Допустим, вы начали работать в тематической ветке, случайно слили её в <code>master</code>, и теперь ваша история коммитов выглядит следующим образом:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/undomerge-start.png" >}}" alt="Случайный коммит слияния">
</div>
<div class="title">Рисунок 137. Случайный коммит слияния</div>
</div>
<div class="paragraph">
<p>Есть два подхода к решению этой проблемы, в зависимости от того, какой результат вы хотите получить.</p>
</div>
<div class="sect4">
<h4 id="_исправление_ссылок">Исправление ссылок</h4>
<div class="paragraph">
<p>Если нежелаемый коммит слияния существует только в вашем локальном репозитории, то простейшее и лучшее решение состоит в перемещении веток так, чтобы они указывали туда куда вам нужно.
В большинстве случаев, если вы после случайного <code>git merge</code> выполните команду <code>git reset --hard HEAD~</code>, то указатели веток восстановятся так, что будут выглядеть следующим образом:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/undomerge-reset.png" >}}" alt="История после `git reset --hard HEAD~`">
</div>
<div class="title">Рисунок 138. История после <code>git reset --hard HEAD~</code>
</div>
</div>
<div class="paragraph">
<p>Мы рассматривали команду <code>reset</code> ранее в <a href="{{< relurl "book/ru/v2/ch00/r_git_reset" >}}">Раскрытие тайн reset</a>, поэтому вам должно быть не сложно разобраться с тем, что здесь происходит.
Здесь небольшое напоминание: <code>reset --hard</code> обычно выполняет три шага:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Перемещает ветку, на которую указывает HEAD.
В данном случае мы хотим переместить <code>master</code> туда, где она была до коммита слияния (<code>C6</code>).</p>
</li>
<li>
<p>Приводит индекс к такому же виду что и HEAD.</p>
</li>
<li>
<p>Приводит рабочий каталог к такому же виду, что и индекс.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Недостаток этого подхода состоит в изменении истории, что может привести к проблемам в случае совместно используемого репозитория.
Загляните в <a href="{{< relurl "book/ru/v2/ch00/r_rebase_peril" >}}">Опасности перемещения</a>, чтобы узнать что именно может произойти; кратко говоря, если у других людей уже есть какие-то из изменяемых вами коммитов, вы должны отказаться от использования <code>reset</code>.
Этот подход также не будет работать, если после слияния уже был сделан хотя бы один коммит; перемещение ссылки фактически приведёт к потере этих изменений.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_reverse_commit">Отмена коммита</h4>
<div class="paragraph">
<p>Если перемещение указателей ветки вам не подходит, Git предоставляет возможность сделать новый коммит, который откатывает все изменения, сделанные в другом.
Git называет эту операцию «восстановлением» («revert»), в данном примере вы можете вызвать её следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Опция <code>-m 1</code> указывает какой родитель является «основной веткой» и должен быть сохранен.
Когда вы выполняете слияние в <code>HEAD</code> (<code>git merge topic</code>), новый коммит будет иметь двух родителей: первый из них <code>HEAD</code> (<code>C6</code>), а второй — вершина ветки, которую сливают с текущей (<code>C4</code>).
В данном случае, мы хотим отменить все изменения, внесённые слиянием родителя #2 (<code>C4</code>), и сохранить при этом всё содержимое из родителя #1 (<code>C6</code>).</p>
</div>
<div class="paragraph">
<p>История с коммитом восстановления (отменой коммита слияния) выглядит следующим образом:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/undomerge-revert.png" >}}" alt="История после `git revert -m 1`">
</div>
<div class="title">Рисунок 139. История после <code>git revert -m 1</code>
</div>
</div>
<div class="paragraph">
<p>Новый коммит <code>^M</code> имеет точно такое же содержимое как <code>C6</code>, таким образом, начиная с него всё выглядит так, как будто слияние никогда не выполнялось, за тем лишь исключением, что «теперь уже не слитые» коммиты всё также присутствуют в истории <code>HEAD</code>.
Git придёт в замешательство, если вы вновь попытаетесь слить <code>topic</code> в ветку <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge topic
Already up-to-date.</code></pre>
</div>
</div>
<div class="paragraph">
<p>В ветке <code>topic</code> нет ничего, что ещё недоступно из ветки <code>master</code>.
Плохо, что в случае добавления новых наработок в <code>topic</code>, при повторении слияния Git добавит <em>только</em> те изменения, которые были сделаны после отмены слияния:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/undomerge-revert2.png" >}}" alt="История с плохим слиянием">
</div>
<div class="title">Рисунок 140. История с плохим слиянием</div>
</div>
<div class="paragraph">
<p>Лучшим решением данной проблемы является откат коммита отмены слияния, так как теперь вы хотите внести изменения, которые были отменены, а <strong>затем</strong> создание нового коммита слияния:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/undomerge-revert3.png" >}}" alt="История после повторения отменённого слияния">
</div>
<div class="title">Рисунок 141. История после повторения отменённого слияния</div>
</div>
<div class="paragraph">
<p>В этом примере, <code>M</code> и <code>^M</code> отменены.
В коммите <code>^^M</code>, фактически, сливаются изменения из <code>C3</code> и <code>C4</code>, а в <code>C8</code> — изменения из  <code>C7</code>, таким образом, ветка <code>topic</code> полностью слита.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_другие_типы_слияний">Другие типы слияний</h3>
<div class="paragraph">
<p>До этого момента мы рассматривали типичные слияния двух веток, которые обычно выполняются с использованием стратегии слияния, называемой «рекурсивной».
Но существуют и другие типы слияния веток.
Давайте кратко рассмотрим некоторые из них.</p>
</div>
<div class="sect4">
<h4 id="_выбор_нашей_или_их_версий">Выбор «нашей» или «их» версий</h4>
<div class="paragraph">
<p>Во-первых, существует ещё один полезный приём, который мы можем использовать в обычном «рекурсивном» режиме слияния.
Мы уже видели опции <code>ignore-all-space</code> и <code>ignore-space-change</code>, которые передаются с префиксом <code>-X</code>, но мы можем также попросить Git при возникновении конфликта использовать ту или иную версию файлов.</p>
</div>
<div class="paragraph">
<p>По умолчанию, когда Git при слиянии веток замечает конфликт, он добавляет в код маркеры конфликта, отмечает файл как конфликтующий и позволяет вам разрешить его.
Если же вместо ручного разрешения конфликта вы хотите, чтобы Git просто использовал какую-то определённую версию файла, а другую игнорировал, то вы можете передать команде <code>merge</code> одну из двух опций <code>-Xours</code> или <code>-Xtheirs</code>.</p>
</div>
<div class="paragraph">
<p>В этом случае Git не будет добавлять маркеры конфликта.
Все неконфликтующие изменения он сольёт, а для конфликтующих он целиком возьмёт ту версию, которую вы указали (это относится и к бинарным файлам).</p>
</div>
<div class="paragraph">
<p>Если мы вернёмся к примеру «hello world», который использовали раньше, то увидим, что попытка слияния в нашу ветку приведёт к конфликту.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Однако, если мы выполним слияние с опцией <code>-Xours</code> или <code>-Xtheirs</code>, конфликта не будет.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае, вместо добавления в файл маркеров конфликта с «hello mundo» в качестве одной версии и с «hola world» в качестве другой, Git просто выберет «hola world».
Однако, все другие неконфликтующие изменения будут слиты успешно.</p>
</div>
<div class="paragraph">
<p>Такая же опция может быть передана команде <code>git merge-file</code>, которую мы обсуждали ранее, то есть для слияния отдельных файлов можно использовать команду <code>git merge-file --ours</code>.</p>
</div>
<div class="paragraph">
<p>На случай если вам нужно нечто подобное, но вы хотите, чтобы Git даже не пытался сливать изменения из другой версии, существует более суровый вариант — <em>стратегия</em> слияния «ours».
Важно отметить, что это не то же самое что <em>опция</em> «ours» рекурсивной стратегии слияния.</p>
</div>
<div class="paragraph">
<p>Фактически, эта стратегия выполнит ненастоящее слияние.
Она создаст новый коммит слияния, у которого родителями будут обе ветки, но при этом данная стратегия даже не взглянет на ветку, которую вы сливаете.
В качестве результата слияния она просто оставляет тот код, который находится в вашей текущей ветке.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вы можете видеть, что между веткой, в которой мы были, и результатом слияния нет никаких отличий.</p>
</div>
<div class="paragraph">
<p>Это часто бывает полезно, когда нужно заставить Git считать, что ветка уже слита, а реальное слияние отложить на потом.
Для примера предположим, что вы создали ветку <code>release</code> и проделали в ней некоторую работу, которую когда-то впоследствии захотите слить обратно в <code>master</code>.
Тем временем в <code>master</code> были сделаны некоторые исправления, которые необходимо перенести также в вашу ветку <code>release</code>.
Вы можете слить ветку с исправлениями в <code>release</code>, а затем выполнить <code>merge -s ours</code> этой ветки в <code>master</code> (хотя исправления в ней уже присутствуют), так что позже, когда вы будете снова сливать ветку <code>release</code>, не возникнет конфликтов, связанных с этими исправлениями.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_subtree_merge">Слияние поддеревьев</h4>
<div class="paragraph">
<p>Идея слияния поддеревьев состоит в том, что у вас есть два проекта и один из проектов отображается в подкаталог другого.
Когда вы выполняете слияние поддеревьев, Git в большинстве случаев способен понять, что одно из них является поддеревом другого и выполнить слияние подходящим способом.</p>
</div>
<div class="paragraph">
<p>Далее мы рассмотрим пример добавления в существующий проект другого проекта и последующее слияние кода второго проекта в подкаталог первого.</p>
</div>
<div class="paragraph">
<p>Первым делом мы добавим в наш проект приложение Rack.
Мы добавим Rack в наш собственный проект, как удалённый репозиторий, а затем выгрузим его в отдельную ветку.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Таким образом, теперь у нас в ветке <code>rack_branch</code> находится основная ветка проекта Rack, а в ветке <code>master</code> — наш собственный проект.
Если вы переключитесь сначала на одну ветку, а затем на другую, то увидите, что они имеют абсолютно разное содержимое:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Может показаться странным, но, на самом деле, ветки в вашем репозитории не обязаны быть ветками одного проекта.
Это мало распространено, так как редко бывает полезным, но иметь ветки, имеющие абсолютно разные истории, довольно легко.</p>
</div>
<div class="paragraph">
<p>В данном примере, мы хотим выгрузить проект Rack в подкаталог нашего основного проекта.
В Git мы можем выполнить это с помощью команды <code>git read-tree</code>.
Вы узнаете больше о команде <code>read-tree</code> и её друзьях в главе <a href="{{< relurl "book/ru/v2/ch00/ch10-git-internals" >}}">Git изнутри</a>, сейчас же вам достаточно знать, что она считывает содержимое некоторой ветки в ваш текущий индекс и рабочий каталог.
Мы просто переключимся обратно на ветку <code>master</code> и выгрузим ветку <code>rack_branch</code> в подкаталог <code>rack</code> ветки <code>master</code> нашего основного проекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git read-tree --prefix=rack/ -u rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Когда мы будем выполнять коммит, он будет выглядеть так, как будто все файлы проекта Rack были добавлены в этот подкаталог — например, мы скопировали их из архива.
Важно отметить, что слить изменения одной из веток в другую довольно легко.
Таким образом, если проект Rack обновился, мы можем получить изменения из его репозитория просто переключившись на соответствующую ветку и выполнив операцию <code>git pull</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout rack_branch
$ git pull</code></pre>
</div>
</div>
<div class="paragraph">
<p>Затем мы можем слить эти изменения обратно в нашу ветку <code>master</code>.</p>
</div>
<div class="paragraph">
<p>Для того, чтобы получить изменения и заполнить сообщение коммита используйте параметр <code>--squash</code>, вместе с опцией <code>-Xsubtree</code> рекурсивной стратегии слияния.
Вообще-то, по умолчанию используется именно рекурсивная стратегия слияния, но мы указали и её тоже для пущей ясности.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</code></pre>
</div>
</div>
<div class="paragraph">
<p>Все изменения из проекта Rack слиты и подготовлены для локального коммита.
Вы также можете поступить наоборот — сделать изменения в подкаталоге <code>rack</code> вашей основной ветки и затем слить их в вашу ветку <code>rack_branch</code>, чтобы позже передать их ответственным за проекты или отправить их в вышестоящий репозиторий проекта Rack.</p>
</div>
<div class="paragraph">
<p>Таким образом, слияние поддеревьев даёт нам возможность использовать рабочий процесс в некоторой степени похожий на рабочий процесс с подмодулями, но при этом без использования подмодулей (которые мы рассмотрим в <a href="{{< relurl "book/ru/v2/ch00/r_git_submodules" >}}">Подмодули</a>).
Мы можем держать ветки с другими связанными проектами в нашем репозитории и периодически сливать их как поддеревья в наш проект.
С одной стороны это удобно, например, тем, что весь код хранится в одном месте.
Однако, при этом есть и некоторые недостатки — поддеревья немного сложнее, проще допустить ошибки при повторной интеграции изменений или случайно отправить ветку не в тот репозиторий.</p>
</div>
<div class="paragraph">
<p>Другая небольшая странность состоит в том, что для получения различий между содержимым подкаталога <code>rack</code> и содержимого ветки <code>rack_branch</code> — для того, чтобы увидеть необходимо ли выполнять слияния между ними — вы не можете использовать обычную команду <code>diff</code>.
Вместо этого следует выполнить команду <code>git diff-tree</code>, указав ветку, с которой производится сравнение:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот как выглядит процедура сравнения содержимого подкаталога <code>rack</code> с содержимым ветки <code>master</code> на сервере после последнего скачивания изменений:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_remote/master</code></pre>
</div>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>