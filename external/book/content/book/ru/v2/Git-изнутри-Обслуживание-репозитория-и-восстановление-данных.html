---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ru
  chapter:
    title: Git изнутри
    number: 10
  section:
    title: Обслуживание репозитория и восстановление данных
    number: 7
    cs_number: '10.7'
    previous: book/ru/v2/Git-изнутри-Протоколы-передачи-данных
    next: book/ru/v2/Git-изнутри-Переменные-окружения
title: Git - Обслуживание репозитория и восстановление данных
url: "/book/ru/v2/Git-изнутри-Обслуживание-репозитория-и-восстановление-данных.html"
---
<h2 id="_обслуживание_репозитория_и_восстановление_данных">Обслуживание репозитория и восстановление данных</h2>
<div class="paragraph">
<p>Изредка вам потребуется делать «уборку» — сделать репозиторий более компактным, очистить импортированный репозиторий от лишних файлов или восстановить потерянные данные.
Данный раздел охватывает некоторые из этих сценариев.</p>
</div>
<div class="sect3">
<h3 id="r_git_gc">Обслуживание репозитория</h3>
<div class="paragraph">
<p>Время от времени Git выполняет автоматическую сборку мусора.
Чаще всего эта команда ничего не делает.
Однако, если у вас накопилось слишком много «рыхлых» объектов (не в pack-файлах), или, наоборот, отдельных pack-файлов, Git запускает полноценный сборщик — <code>git gc</code> (здесь «gc» это сокращение от «garbage collect», что означает «сборка мусора»).
Эта команда выполняет несколько действий: собирает все «рыхлые» объекты и упаковывает их в pack-файлы; объединяет несколько упакованных файлов в один большой; удаляет недостижимые объекты, хранящиеся дольше нескольких месяцев.</p>
</div>
<div class="paragraph">
<p>Сборку мусора можно запустить вручную следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git gc --auto</code></pre>
</div>
</div>
<div class="paragraph">
<p>Опять же, как правило, эта команда ничего не делает.
Нужно иметь примерно 7000 несжатых объектов или более 50 pack-файлов, чтобы запустился настоящий <code>gc</code>.
Эти значения можно изменить с помощью параметров <code>gc.auto</code> и <code>gc.autopacklimit</code> соответственно.</p>
</div>
<div class="paragraph">
<p>Ещё одно действие, выполняемое <code>gc</code> — упаковка ссылок в единый файл.
Предположим, репозиторий содержит следующие ветки и теги:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/refs -type f
.git/refs/heads/experiment
.git/refs/heads/master
.git/refs/tags/v1.0
.git/refs/tags/v1.1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если выполнить <code>git gc</code>, эти файлы будут удалены из каталога <code>refs</code>.
Git перенесёт их в файл <code>.git/packed-refs</code> в угоду эффективности:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/packed-refs
# pack-refs with: peeled fully-peeled
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
^1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</div>
</div>
<div class="paragraph">
<p>При обновлении ссылки Git не будет редактировать этот файл, а добавит новый файл в <code>refs/heads</code>.
Для получения хеша, соответствующего нужной ссылке, Git сначала проверит наличие файла ссылки в каталоге <code>refs</code>, а к файлу <code>packed-refs</code> обратится только в случае отсутствия оного.
Так что, если вы не можете найти ссылку в каталоге <code>refs</code>, скорее всего она упакована в файле <code>packed-refs</code>.</p>
</div>
<div class="paragraph">
<p>Обратите внимание, последняя строка файла начинается с <code>^</code>.
Это означает, что предыдущая строка является аннотированным тегом, а текущая строка — это коммит, на который указывает аннотированный тег.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_data_recovery">Восстановление данных</h3>
<div class="paragraph">
<p>В какой-то момент при работе с Git вы можете нечаянно потерять коммит.
Как правило, такое случается, когда вы удаляете ветку, в которой находились некоторые наработки, а потом оказывается, что они всё-таки были нужными; либо вы выполнили <code>git reset --hard</code>, тем самым отказавшись от коммитов, которые затем понадобились.
Как же в таком случае вернуть свои коммиты обратно?</p>
</div>
<div class="paragraph">
<p>Ниже приведён пример, в котором мы сбрасываем ветку <code>master</code> с потерей данных до более раннего состояния, а затем восстанавливаем потерянные коммиты.
Для начала, давайте посмотрим, как сейчас выглядит история изменений:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b Modify repo.rb a bit
484a59275031909e19aadb7c92262719cfcdf19a Create repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь сбросим ветку <code>master</code> на третий коммит:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef Third commit
$ git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Итак, теперь два последних коммита по-настоящему потеряны — они не достижимы ни из одной ветки.
Необходимо найти SHA-1 хеш последнего коммита и создать ветку, указывающую на него.
Сложность в том, чтобы узнать этот самый SHA-1, ведь вряд ли вы его запомнили, да?</p>
</div>
<div class="paragraph">
<p>Зачастую самый быстрый способ — использование команды <code>git reflog</code>.
Дело в том, что во время вашей работы Git записывает все изменения HEAD.
Каждый раз при переключении веток и коммитов изменений, добавляется запись в reflog.
reflog также обновляется командой <code>git update-ref</code> — это, кстати, хорошая причина использовать именно эту команду, а не вручную записывать SHA-1 в ref-файлы, как было показано в <a href="{{< relurl "book/ru/v2/ch00/r_git_refs" >}}">Ссылки в Git</a>.
Вы можете посмотреть где находился указатель HEAD в любой момент времени, запустив <code>git reflog</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reflog
1a410ef HEAD@{0}: reset: moving to 1a410ef
ab1afef HEAD@{1}: commit: Modify repo.rb a bit
484a592 HEAD@{2}: commit: Create repo.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь мы видим два коммита, на которые когда-то указывал HEAD, однако информации не так уж и много.
Для получения информации в более удобном виде, можно воспользоваться командой <code>git log -g</code>, которая выведет лог записей из reflog в привычном формате:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -g
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Reflog: HEAD@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:22:37 2009 -0700

		Third commit

commit ab1afef80fac8e34258ff41fc1b867c702daa24b
Reflog: HEAD@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

       Modify repo.rb a bit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Похоже, что последний коммит — это и есть тот, который мы потеряли; его можно восстановить, создав новую ветку, указывающую на него.
Например, создадим новую ветку с именем <code>recover-branch</code>, указывающую на этот коммит (<code>ab1afef</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch recover-branch ab1afef
$ git log --pretty=oneline recover-branch
ab1afef80fac8e34258ff41fc1b867c702daa24b Modify repo.rb a bit
484a59275031909e19aadb7c92262719cfcdf19a Create repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Отлично — теперь у нас есть ветка <code>recover-branch</code>, указывающая туда, куда ранее указывала ветка <code>master</code>, тем самым делая потерянные коммиты вновь доступными.
Теперь предположим, что потерянные изменения отсутствуют в reflog — для симуляции такого состояния удалим восстановленную ветку и очистим reflog.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -D recover-branch
$ rm -Rf .git/logs/</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом случае два первых коммита недоступны ниоткуда.
Так как данные reflog хранятся в каталоге <code>.git/logs/</code>, которую мы только что удалили, то теперь у нас нет reflog.
Как теперь восстановить коммиты?
Один из вариантов — использование утилиты <code>git fsck</code>, проверяющую внутреннюю базу данных на целостность.
Если выполнить её с ключом <code>--full</code>, будут показаны все объекты, недостижимые из других объектов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (18/18), done.
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</code></pre>
</div>
</div>
<div class="paragraph">
<p>В нашем случае потерянный коммит указан после слов «dangling commit» («висячий коммит»).
Его можно восстановить аналогичным образом, создав новую ветку, указывающую на этот SHA-1.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_removing_objects">Удаление объектов</h3>
<div class="paragraph">
<p>Git — замечательный инструмент с кучей классных возможностей, но некоторые из них способны стать источником проблем; например, команда <code>git clone</code> загружает проект вместе со всей историей, включая все версии всех файлов.
Это нормально, если в репозитории хранится только исходный код, так как Git хорошо оптимизирован под такой тип данных и может эффективно сжимать их.
Однако, если когда-либо в проект был добавлен большой файл, каждый, кто потом захочет клонировать проект, будет вынужден скачивать этот файл, даже если он был удалён в следующем коммите.
Он будет в базе всегда, просто потому, что он доступен в истории.</p>
</div>
<div class="paragraph">
<p>Это может стать большой проблемой при конвертации Subversion или Perforce репозиториев в Git.
В этих системах вам не нужно загружать всю историю, поэтому добавление больших файлов не имеет там особых последствий.
Если при импорте из другой системы или при каких-либо других обстоятельствах стало ясно, что ваш репозиторий намного больше, чем он должен быть, то как раз сейчас мы расскажем, как можно найти и удалить большие объекты.</p>
</div>
<div class="paragraph">
<p><strong>Предупреждаем: дальнейшие действия переписывают историю изменений.</strong>
Каждый коммит, начиная с самого раннего, из которого нужно удалить большой файл, будет переписан.
Если сделать это непосредственно после импорта, пока никто ещё не работал с репозиторием, то всё окей, иначе придётся сообщить всем участникам о необходимости перебазирования их правок относительно ваших новых коммитов.</p>
</div>
<div class="paragraph">
<p>Для примера добавим большой файл в тестовый репозиторий, удалим его в следующем коммите, а потом найдём и удалим его полностью из базы.
Сначала добавим большой файл в нашу историю:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz &gt; git.tgz
$ git add git.tgz
$ git commit -m 'Add git tarball'
[master 7b30847] Add git tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 git.tgz</code></pre>
</div>
</div>
<div class="paragraph">
<p>Упс, мы нечаянно.
Нам лучше избавиться от этого файла:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm git.tgz
rm 'git.tgz'
$ git commit -m 'Oops - remove large tarball'
[master dadf725] Oops - remove large tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 git.tgz</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь запустим сборщик мусора и посмотрим, сколько места сейчас используется:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git gc
Counting objects: 17, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (17/17), done.
Total 17 (delta 1), reused 10 (delta 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы быстро узнать, сколько места занято, можно воспользоваться командой <code>count-objects</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git count-objects -v
count: 7
size: 32
in-pack: 17
packs: 1
size-pack: 4868
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Строка <code>size-pack</code> — это размер pack-файлов в килобайтах, то есть всего занято почти 5 MБ.
Перед последним коммитом использовалось около 2 КБ — очевидно, удаление файла не удалило его из истории.
Всякий раз, когда кто-либо захочет клонировать этот репозиторий, ему придётся скачивать все 5 МБ для того, чтобы заполучить этот крошечный проект, просто потому, что однажды вы имели неосторожность добавить большой файл.
Давайте же исправим это!</p>
</div>
<div class="paragraph">
<p>Для начала найдём проблемный файл.
В данном случае, мы уже знаем, что это за файл.
Но если бы не знали, как можно было бы определить, какие файлы занимают много места?
При вызове <code>git gc</code> все объекты упаковываются в один pack-файл, но, несмотря на это, определить самые крупные файлы можно, запустив служебную команду <code>git verify-pack</code> и отсортировав её вывод по третьей колонке, в которой записан размер файла.
Так как нас интересуют самые крупный файлы, оставим три последние строки с помощью <code>tail</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git verify-pack -v .git/objects/pack/pack-29…69.idx \
  | sort -k 3 -n \
  | tail -3
dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696
82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438</code></pre>
</div>
</div>
<div class="paragraph">
<p>Большой объект внизу списка, его размер — 5 МБ.
Для того чтобы узнать, что это за файл, воспользуемся командой <code>rev-list</code>, которая уже упоминалась в разделе <a href="{{< relurl "book/ru/v2/ch00/r_enforcing_commit_message_format" >}}">Проверка формата сообщения коммита</a> главы 8.
Если передать ей ключ <code>--objects</code>, она выдаст хеши всех коммитов, а также хеши объектов и соответствующие им имена файлов.
Воспользуемся этим для определения имени выбранного объекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rev-list --objects --all | grep 82c99a3
82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь необходимо удалить данный файл из всех деревьев в прошлом.
Легко получить все коммиты, которые изменяли данный файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --branches -- git.tgz
dadf725 Oops - remove large tarball
7b30847 Add git tarball</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для полного удаления этого файла из истории необходимо переписать все коммиты, начиная с <code>7b30847</code>.
Воспользуемся командой <code>filter-branch</code>, о которой мы писали в разделе <a href="{{< relurl "book/ru/v2/ch00/r_rewriting_history" >}}">Перезапись истории</a> главы 7:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --index-filter \
  'git rm --ignore-unmatch --cached git.tgz' -- 7b30847^..
Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm 'git.tgz'
Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p>Опция <code>--index-filter</code> похожа на <code>--tree-filter</code>, использовавшуюся в разделе <a href="{{< relurl "book/ru/v2/ch00/r_rewriting_history" >}}">Перезапись истории</a> главы 7, за исключением того, что вместо передачи команды, модифицирующей файлы на диске, мы используем команду, изменяющую файлы в индексе.</p>
</div>
<div class="paragraph">
<p>Вместо удаления файла чем-то вроде <code>rm file</code>, мы используем <code>git rm --cached</code>, так как нам надо удалить файл из индекса, а не с диска.
Причина, по которой мы делаем именно так — скорость: нет необходимости извлекать каждую ревизию на диск, чтобы применить фильтр, а это может очень сильно ускорить процесс.
Если хотите, можете использовать и <code>tree-filter</code> для получения аналогичного результата.
Опция <code>--ignore-unmatch</code> команды <code>git rm</code> отключает вывод сообщения об ошибке в случае отсутствия файлов, соответствующих шаблону.
Ещё один момент: мы указали команде <code>filter-branch</code> переписывать историю, начиная с коммита <code>7b30847</code>, потому что мы знаем, что именно в нём впервые появилась проблема.
По умолчанию перезапись начинается с самого первого коммита, что потребовало бы гораздо больше времени.</p>
</div>
<div class="paragraph">
<p>Теперь история не содержит ссылок на данный файл.
Однако, в reflog и в новом наборе ссылок, добавленном Git в <code>.git/refs/original</code> после выполнения <code>filter-branch</code>, ссылки на него всё ещё присутствуют, поэтому необходимо их удалить, а затем переупаковать базу.
Необходимо избавиться от всех возможных ссылок на старые коммиты перед переупаковкой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm -Rf .git/refs/original
$ rm -Rf .git/logs/
$ git gc
Counting objects: 15, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (15/15), done.
Total 15 (delta 1), reused 12 (delta 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Проверим, сколько места удалось освободить:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git count-objects -v
count: 11
size: 4904
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Размер упакованного репозитория сократился до 8 КБ, что намного лучше, чем 5 МБ.
Из значения поля size видно, что большой объект всё ещё хранится в одном из ваших «рыхлых» объектов, но, что самое главное, при любой последующей отправке данных наружу (а значит и при последующих клонированиях репозитория) он передаваться не будет.
Если очень хочется, можно удалить его навсегда локально, выполнив <code>git prune --expire</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git prune --expire now
$ git count-objects -v
count: 0
size: 0
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>