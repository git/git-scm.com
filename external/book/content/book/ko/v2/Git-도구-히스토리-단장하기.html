---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ko
  chapter:
    title: Git 도구
    number: 7
  section:
    title: 히스토리 단장하기
    number: 6
    cs_number: '7.6'
    previous: book/ko/v2/Git-도구-검색
    next: book/ko/v2/Git-도구-Reset-명확히-알고-가기
title: Git - 히스토리 단장하기
url: "/book/ko/v2/Git-도구-히스토리-단장하기.html"
---
<h2 id="_rewriting_history">히스토리 단장하기</h2>
<div class="paragraph">
<p>Git으로 일하다 보면 어떤 이유로든 로컬 커밋 히스토리를 수정해야 할 때가 있다.
결정을 나중으로 미룰 수 있던 것은 Git의 장점이다.
Staging Area로 커밋할 파일을 고르는 일을 커밋하는 순간으로 미룰 수 있고 Stash 명령으로 하던 일을 미룰 수 있다. 게다가 이미 커밋해서 결정한 내용을 수정할 수 있다. 그리고 수정할 수 있는 것도 매우 다양하다.
커밋들의 순서도 변경할 수 있고 커밋 메시지와 커밋한 파일도 변경할 수 있다. 여러 개의 커밋을 하나로 합치거나 반대로 커밋 하나를 여러 개로 분리할 수도 있다. 아니면 커밋 전체를 삭제할 수도 있다. 하지만, 이 모든 것은 다른 사람과 코드를 공유하기 전에 해야 한다.</p>
</div>
<div class="paragraph">
<p>이 절에서는 사람들과 코드를 공유하기 전에 커밋 히스토리를 예쁘게 단장하는 방법에 대해서 설명한다.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">노트</div>
</td>
<td class="content">
<div class="paragraph">
<p>Git이 동작하는 기본 원리 중 하나는 Git은 로컬에 모든 버전관리 데이터를 로컬에 복사(Clone) 해두고 있다는 점이다. 이 때문에 자유롭게 히스토리를 <em>로컬에서</em> 수정해 볼 수 있는 자유도 누릴 수 있다.
다만 로컬의 버전관리 데이터 혹은 커밋이 외부로 Push가 된 후라면 이야기는 완전 딴판이된다. Push된 데이터는 수정에 대해선 완전이 끝난 것이다. 고쳐야 할 이유가 생겼더라도 새로 수정작업을 추가해야지 이전 커밋 자체를 수정할 수는 없다.
그렇기에 온전하게 수정 작업을 마무리했다는 확신 없이 작업 내용을 공유하는 저장소로 보내는(Push) 것은 피해야 할 행동이다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h3 id="_git_amend">마지막 커밋을 수정하기</h3>
<div class="paragraph">
<p>히스토리를 단장하는 일 중에서는 마지막 커밋을 수정하는 것이 가장 자주 하는 일이다.
기본적으로 두 가지로 나눌 수 있는데 하나는 단순히 커밋 메시지만를 수정하는 것이고 다른 하나는 나중에 수정한 파일을 마지막 커밋 안에 밀어넣는 것이다.</p>
</div>
<div class="paragraph">
<p>커밋 메시지를 수정하는 방법은 매우 간단하다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit --amend</code></pre>
</div>
</div>
<div class="paragraph">
<p>이 명령은 자동으로 텍스트 편집기를 실행시켜서 마지막 커밋 메시지를 열어준다.
여기에 메시지를 바꾸고 편집기를 닫으면 편집기는 바뀐 메시지로 마지막 커밋을 수정한다.</p>
</div>
<div class="paragraph">
<p>반대로 커밋 메시지가 아니라 프로젝트 내용을 수정한 경우가 있다. 커밋하고 난 후 새로 만든 파일이나 수정한 파일을 가장 최근 커밋에 집어넣을 수 있다. 기본적으로 방법은 같다.
파일을 수정하고 <code>git add</code> 명령으로 Staging Area에 넣는다. 그리고 <code>git commit --amend</code> 명령으로 커밋하면 커밋 자체가 수정되면서 추가로 수정사항을 밀어넣을 수 있다.</p>
</div>
<div class="paragraph">
<p>이때 SHA-1 값이 바뀌기 때문에 과거의 커밋을 변경할 때 주의해야 한다.
Rebase와 같이 이미 Push 한 커밋은 수정하면 안 된다.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">힌트</div>
</td>
<td class="content">
<div class="title">커밋을 고치는 작업은 커밋 메시지 고치를 덩달아 이끌 수 있음</div>
<div class="paragraph">
<p>커밋을 고치는 것은 커밋 메시지를 고치는 것일수도 있고 또는 커밋 담고 있는 변경 내용을 고치는 것 일수도 있다.
커밋의 고치는데 있어 추가된 변경 내용이 상당히 있을 경우 커밋 메시지가 충실하게 담고 있는지 확인해 볼 필요가 있다.</p>
</div>
<div class="paragraph">
<p>반대로 커밋을 고치는 내용이 오타를 살짝 고치거나 실수로 빠뜨린 것을 넣는 등 아주 사소하거나 이미 커밋 메시지가 충분히 이를 반영하고 있을 수 있다. 이런 경우 다음과 같이 <code>--no-edit</code> 옵션을 사용하면 커밋 메시지를 수정하도록 편집기가 실행되지는 않는다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit --amend --no-edit</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_changing_multiple">커밋 메시지를 여러 개 수정하기</h3>
<div class="paragraph">
<p>최근 커밋이 아니라 예전 커밋을 수정하려면 다른 도구가 필요하다.
히스토리 수정하기 위해 만들어진 도구는 없지만 <code>rebase</code> 명령을 이용하여 수정할 수 있다. 현재 작업하는 브랜치에서 각 커밋을 하나하나 수정하는 것이 아니라 어느 시점부터 HEAD까지의 커밋을 한 번에 Rebase 한다.
대화형 Rebase 도구를 사용하면 커밋을 처리할 때마다 잠시 멈춘다. 그러면 각 커밋의 메시지를 수정하거나 파일을 추가하고 변경하는 등의 일을 진행할 수 있다.
<code>git rebase</code> 명령에 <code>-i</code> 옵션을 추가하면 대화형 모드로 Rebase 할 수 있다.
어떤 시점부터 HEAD까지 Rebase 할 것인지 인자로 넘기면 된다.</p>
</div>
<div class="paragraph">
<p>마지막 커밋 메시지 세 개를 모두 수정하거나 그 중 몇 개를 수정하는 시나리오를 살펴보자. <code>git rebase -i</code> 의 인자로 편집하려는 마지막 커밋의 부모를 <code>HEAD~2^</code> 나 <code>HEAD~3</code> 로 해서 넘긴다.
마지막 세 개의 커밋을 수정하는 것이기 때문에 <code>~3</code> 이 좀 더 기억하기 쉽다. 그렇지만, 실질적으로 가리키게 되는 것은 수정하려는 커밋의 부모인 네 번째 이전 커밋이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase -i HEAD~3</code></pre>
</div>
</div>
<div class="paragraph">
<p>이 명령은 Rebase 하는 것이기 때문에 메시지의 수정 여부에 관계없이 <code>HEAD~3..HEAD</code> 범위에 있는 모든 커밋을 수정한다.
다시 강조하지만 이미 중앙서버에 Push 한 커밋은 절대 고치지 말아야 한다. Push 한 커밋을 Rebase 하면 결국 같은 내용을 두 번 Push 하는 것이기 때문에 다른 개발자들이 혼란스러워 할 것이다.</p>
</div>
<div class="paragraph">
<p>실행하면 Git은 수정하려는 커밋 목록이 첨부된 스크립트를 텍스트 편집기로 열어준다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out</code></pre>
</div>
</div>
<div class="paragraph">
<p>이 커밋은 모두 <code>log</code> 명령과는 정반대의 순서로 나열된다.
<code>log</code> 명령을 실행하면 아래와 같은 결과를 볼 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit</code></pre>
</div>
</div>
<div class="paragraph">
<p>위 결과의 역순임을 기억하자.
대화형 Rebase는 스크립트에 적혀 있는 순서대로
<code>HEAD~3</code> 부터 적용하기 시작하고 위에서 아래로 각각의 커밋을 순서대로 수정한다.
순서대로 적용하는 것이기 때문에 제일 위에 있는 것이 최신이 아니라 가장 오래된 것이다.</p>
</div>
<div class="paragraph">
<p>특정 커밋에서 실행을 멈추게 하려면 스크립트를 수정해야 한다.
<code>pick</code> 이라는 단어를 'edit’로 수정하면 그 커밋에서 멈춘다.
가장 오래된 커밋 메시지를 수정하려면 아래와 같이 편집한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>
</div>
</div>
<div class="paragraph">
<p>저장하고 편집기를 종료하면 Git은 목록에 있는 커밋 중에서 가장 오래된 커밋으로 이동하고, 아래와 같은 메시지를 보여주고, 명령 프롬프트를 보여준다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue</code></pre>
</div>
</div>
<div class="paragraph">
<p>명령 프롬프트가 나타날 때 Git은 Rebase 과정에서 현재 정확히 뭘 해야 하는지 메시지로 알려준다.
아래와 같은 명령을 실행하고</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit --amend</code></pre>
</div>
</div>
<div class="paragraph">
<p>커밋 메시지를 수정하고 텍스트 편집기를 종료하고 나서
아래 명령을 실행한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase --continue</code></pre>
</div>
</div>
<div class="paragraph">
<p>이렇게 나머지 두 개의 커밋에 적용하면 끝이다.
다른 것도 pick을 edit로 수정해서 이 작업을 몇 번이든 반복할 수 있다.
매번 Git이 멈출 때마다 커밋을 정정할 수 있고 완료할 때까지 계속 할 수 있다.</p>
</div>
</div>
<div class="sect3">
<h3 id="_커밋_순서_바꾸기">커밋 순서 바꾸기</h3>
<div class="paragraph">
<p>대화형 Rebase 도구로 커밋 전체를 삭제하거나 순서를 조정할 수 있다.
“added cat-file” 커밋을 삭제하고 다른 두 커밋의 순서를 변경하려면 아래와 같은 Rebase 스크립트를</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>
</div>
</div>
<div class="paragraph">
<p>아래와 같이 수정한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit</code></pre>
</div>
</div>
<div class="paragraph">
<p>수정한 내용을 저장하고 편집기를 종료하면 Git은 브랜치를 이 커밋의 부모로 이동시키고서 <code>310154e</code> 와 <code>f7f3f6d</code> 를 순서대로 적용한다.
명령이 끝나고 나면 커밋 순서가 변경됐고 “added cat-file” 커밋이 제거된 것을 확인할 수 있다.</p>
</div>
</div>
<div class="sect3">
<h3 id="_squashing">커밋 합치기</h3>
<div class="paragraph">
<p>대화형 Rebase 명령을 이용하여 여러 개의 커밋을 꾹꾹 눌러서 커밋 하나로 만들어 버릴 수 있다.
Rebase 스크립트에 자동으로 포함된 도움말에 설명이 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out</code></pre>
</div>
</div>
<div class="paragraph">
<p>“pick” 이나 “edit” 말고 “squash” 를 입력하면 Git은 해당 커밋과 바로 이전 커밋을 합칠 것이고 커밋 메시지도 Merge 한다.
그래서 3개의 커밋을 모두 합치려면 스크립트를 아래와 같이 수정한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file</code></pre>
</div>
</div>
<div class="paragraph">
<p>저장하고 나서 편집기를 종료하면 Git은 3개의 커밋 메시지를 Merge 할 수 있도록 에디터를 바로 실행해준다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file</code></pre>
</div>
</div>
<div class="paragraph">
<p>이 메시지를 저장하면 3개의 커밋이 모두 합쳐진 커밋 한 개만 남는다.</p>
</div>
</div>
<div class="sect3">
<h3 id="_커밋_분리하기">커밋 분리하기</h3>
<div class="paragraph">
<p>커밋을 분리한다는 것은 기존의 커밋을 해제하고(혹은 되돌려 놓고) Stage를 여러 개로 분리하고 나서 그것을 원하는 횟수만큼 다시 커밋하는 것이다.
예로 들었던 커밋 세 개 중에서 가운데 것을 분리해보자. 이 커밋의 “updated README formatting and added blame” 을 “updated README formatting” 과 “added blame” 으로 분리하는 것이다. <code>rebase -i</code> 스크립트에서 해당 커밋을 "edit"로 변경한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>
</div>
</div>
<div class="paragraph">
<p>저장하고 나서 명령 프롬프트로 넘어간 다음에 그 커밋을 해제하고 그 내용을 다시 두 개로 나눠서 커밋하면 된다.
저장하고 편집기를 종료하면 Git은 제일 오래된 커밋의 부모로 이동하고서 <code>f7f3f6d</code> 과 <code>310154e</code> 을 처리하고 콘솔 프롬프트를 보여준다.
여기서 커밋을 해제하는 <code>git reset HEAD^</code> 라는 명령으로 커밋을 해제한다. 그러면 수정했던 파일은 Unstaged 상태가 된다.
그다음에 파일을 Stage 한 후 커밋하는 일을 원하는 만큼 반복하고 나서 <code>git rebase --continue</code> 라는 명령을 실행하면 남은 Rebase 작업이 끝난다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue</code></pre>
</div>
</div>
<div class="paragraph">
<p>나머지 <code>a5f4a0d</code> 커밋도 처리되면 히스토리는 아래와 같다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit</code></pre>
</div>
</div>
<div class="paragraph">
<p>다시 강조하지만 Rebase 하면 목록에 있는 모든 커밋의 SHA-1 값은 변경된다. 절대로 이미 서버에 Push 한 커밋을 수정하면 안 된다.</p>
</div>
</div>
<div class="sect3">
<h3 id="_filter_branch는_포크레인">filter-branch는 포크레인</h3>
<div class="paragraph">
<p>수정해야 하는 커밋이 너무 많아서 Rebase 스크립트로 수정하기 어려울 것 같으면 다른 방법을 사용하는 것이 좋다. 모든 커밋의 이메일 주소를 변경하거나 어떤 파일을 삭제하는 경우를 살펴보자.
<code>filter-branch</code> 라는 명령으로 수정할 수 있는데 Rebase가 삽이라면 이 명령은 포크레인이라고 할 수 있다. <code>filter-branch</code> 도 역시 수정하려는 커밋이 이미 공개돼서 다른 사람과 함께 공유하는 중이라면 사용하지 말아야 한다.
하지만, 잘 쓰면 꽤 유용하다.
<code>filter-branch</code> 가 유용한 경우를 예로 들어 설명하기 때문에 여기에서 대충 어떤 경우에 유용할지 배울 수 있다.</p>
</div>
<div class="sect4">
<h4 id="_removing_file_every_commit">모든 커밋에서 파일을 제거하기</h4>
<div class="paragraph">
<p>갑자기 누군가 생각 없이 <code>git add .</code> 같은 명령을 실행해서 공룡 똥 덩어리를 커밋했거나 실수로 암호가 포함된 파일을 커밋해서 이런 파일을 다시 삭제해야 하는 상황을 살펴보자.
이런 상황은 생각보다 자주 발생한다.
<code>filter-branch</code> 는 히스토리 전체에서 필요한 것만 골라내는 데 사용하는 도구다.
<code>filter-branch</code> 의 <code>--tree-filter</code> 라는 옵션을 사용하면 히스토리에서 <code>passwords.txt</code> 파일을 아예 제거할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>--tree-filter</code> 옵션은 프로젝트를 Checkout 한 후에 각 커밋에 명시한 명령을 실행시키고 그 결과를 다시 커밋한다.
이 경우에는 각 스냅샷에 <code>passwords.txt</code> 파일이 있으면 그 파일을 삭제한다.
실수로 편집기의 백업파일을 커밋했으면 <code>git filter-branch --tree-filter 'rm -f *~' HEAD</code> 라고 실행해서 삭제할 수 있다.</p>
</div>
<div class="paragraph">
<p>이 명령은 모든 파일과 커밋을 정리하고 브랜치 포인터를 다시 복원해준다.
이런 작업은 테스팅 브랜치에서 실험하고 나서 master 브랜치에 적용하는 게 좋다.
<code>filter-branch</code> 명령에 <code>--all</code> 옵션을 추가하면 모든 브랜치에 적용할 수 있다.</p>
</div>
</div>
<div class="sect4">
<h4 id="_하위_디렉토리를_루트_디렉토리로_만들기">하위 디렉토리를 루트 디렉토리로 만들기</h4>
<div class="paragraph">
<p>다른 VCS에서 코드를 임포트하면 그 VCS만을 위한 디렉토리가 있을 수 있다. SVN에서 코드를 임포트하면 <code>trunk</code>, <code>tags</code>, <code>branch</code> 디렉토리가 포함된다.
모든 커밋에 대해 <code>trunk</code> 디렉토리를 프로젝트 루트 디렉토리로 만들 때도 <code>filter-branch</code> 명령이 유용하다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p>이제 <code>trunk</code> 디렉토리를 루트 디렉토리로 만들었다.
Git은 입력한 디렉토리와 관련이 없는 커밋을 자동으로 삭제한다.</p>
</div>
</div>
<div class="sect4">
<h4 id="_모든_커밋의_이메일_주소를_수정하기">모든 커밋의 이메일 주소를 수정하기</h4>
<div class="paragraph">
<p>프로젝트를 오픈소스로 공개할 때 아마도 회사 이메일 주소로 커밋된 것을 개인 이메일 주소로 변경해야 한다. 아니면 아예 <code>git config</code> 로 이름과 이메일 주소를 설정하는 것을 잊었을 수도 있다.
자신의 이메일 주소만 변경하도록 조심해야 한다.
<code>filter-branch</code> 명령의 <code>--commit-filter</code> 옵션을 사용하여 해당 커밋만 골라서 이메일 주소를 수정할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD</code></pre>
</div>
</div>
<div class="paragraph">
<p>이메일 주소를 새 주소로 변경했다.
모든 커밋은 부모의 SHA-1 값을 가지고 있기 때문에 조건에 만족하는 커밋의 SHA-1값만 바뀌는 것이 아니라 모든 커밋의 SHA-1 값이 바뀐다.</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>