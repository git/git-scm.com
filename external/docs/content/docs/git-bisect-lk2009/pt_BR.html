---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-bisect-lk2009 Documentation
docname: git-bisect-lk2009
lang: pt_BR
aliases:
- "/docs/git-bisect-lk2009/pt_BR/index.html"
---
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>Resumo</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O comando "git bisect" permite que os usuários e os desenvolvedores de software encontrem facilmente o commit que introduziu uma regressão. Mostramos por que é importante ter boas ferramentas para combater as regressões. Nós descrevemos como o comando "git bisect" funciona de fora e os algoritmos que ele utiliza por dentro. Em seguida, explicamos como tirar proveito do comando "git bisect" para melhorar as práticas atuais. E discutimos como o "git bisect" pode melhorar no futuro.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introdução_ao_git_bisect"><a class="anchor" href="#_introdução_ao_git_bisect"></a>Introdução ao "git bisect'</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O Git é um sistema de controle de versão distribuído (DVCS) criado por Linus Torvalds e mantido por Junio Hamano.</p>
</div>
<div class="paragraph">
<p>No Git como em muitos outros sistemas de controle de versão (VCS), as diferentes condições dos dados gerenciados pelo sistema são chamados de commits. E como o VCS é utilizado principalmente para gerenciar o código-fonte do software, algumas alterações "interessantes" do comportamento no software são introduzidas em alguns commits.</p>
</div>
<div class="paragraph">
<p>De fato, as pessoas estão especialmente interessadas em confirmações que introduzem um comportamento "ruim", chamado de bug ou regressão. Eles estão interessados nestes commits porque um commit (espero) contém um conjunto muito pequeno de alterações no código-fonte. E é muito mais fácil entender e corrigir adequadamente um problema quando você só precisa verificar um conjunto muito pequeno de alterações do que quando não sabe onde procurar.</p>
</div>
<div class="paragraph">
<p>Portanto, para ajudar as pessoas a encontrar os commits que introduzam um comportamento "ruim", o conjunto dos comandos "git bisect" foi inventado. E segue-se, é claro, que na linguagem do comando "git bisect", os commits onde o "comportamento interessante" estão presente são chamados de "commits ruins", enquanto os outros commits são chamados de commits "bons". E um commit que introduz o comportamento que estamos interessados é chamado de "primeiro commit ruim". Observe que pode haver mais de um "primeiro commit ruim" no espaço do commit que estamos pesquisando.</p>
</div>
<div class="paragraph">
<p>Portanto, o comando "git bisect" foi projetado para ajudar a encontrar um "primeiro commit ruim". E para ser o mais eficiente possível, ele tenta executar uma pesquisa binária.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_uma_visão_geral_da_luta_contra_as_regressões"><a class="anchor" href="#_uma_visão_geral_da_luta_contra_as_regressões"></a>Uma visão geral da luta contra as regressões</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_regressões_um_grande_problema"><a class="anchor" href="#_regressões_um_grande_problema"></a>Regressões: um grande problema</h3>
<div class="paragraph">
<p>As regressões são um grande problema na indústria do software. Mas é difícil colocar alguns números reais por trás desta afirmação.</p>
</div>
<div class="paragraph">
<p>Existem alguns números sobre os erros em geral, como um estudo do NIST em 2002 <a href="#1">[1]</a> que dizia:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Os bugs ou erros de software são tão predominantes e tão prejudiciais que custam aos Estados Unidos algo em torno de em US$ 59,5 bilhões por ano, ou cerca de 0,6% do produto interno bruto, de acordo com um estudo recém-lançado encomendado pelo National Institute of Standards and Technology (NIST) do Departamento de Comércio. Em nível nacional, mais da metade dos custos é mantida pelos usuários de software e o restante pelos desenvolvedores/fornecedores de software. O estudo também constatou que, embora não seja possível eliminar todos os erros, mais de um terço destes custos, ou um valor estimado em US$ 22,2 bilhões, poderia ser eliminado por uma infraestrutura de testes aprimorada que permitisse a identificação e a remoção de defeitos de software de maneira mais precoce e eficaz. Essa é a economia associada à descoberta de uma porcentagem maior (mas não 100%) de erros mais próxima dos estágios de desenvolvimento em que eles são introduzidos. Atualmente, mais da metade de todos os erros não são encontrados até o "final" do processo de desenvolvimento ou durante o uso do software após a venda.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>E depois:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Os desenvolvedores de software já gastam aproximadamente 80 por cento dos custos de desenvolvimento na identificação e na correção dos defeitos, e ainda assim poucos produtos de qualquer tipo que não sejam software são enviados com níveis muito altos de erros.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Eventualmente, a conclusão começou com:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>O caminho para uma maior qualidade de software é um teste significativamente aprimorado do software.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Existem outras estimativas dizendo que 80% do custo relacionado ao software é relacionado com a manutenção<a href="#2">[2]</a>.</p>
</div>
<div class="paragraph">
<p>Porém, de acordo com a Wikipedia <a href="#3">[3]</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Uma percepção comum da manutenção é que ela está apenas consertando bugs. No entanto, estudos e pesquisas ao longo dos anos indicaram que a maioria, mais de 80%, do esforço de manutenção é usada para ações não corretivas (Pigosky, 1997). Essa percepção é perpetuada através dos usuários que enviam relatórios de problemas que, na realidade, são aprimoramentos da funcionalidade no sistema.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Porém podemos adivinhar que o aprimoramento do software existente é muito caro porque é preciso estar atento às regressões. Pelo menos isso tornaria os estudos acima consistentes entre si.</p>
</div>
<div class="paragraph">
<p>É claro que algum tipo de software é desenvolvido, usado durante algum tempo sem ser muito aprimorado e finalmente, jogado fora. Nesse caso, é claro, as regressões podem não ser um grande problema. Por outro lado, há muitos softwares grandes que são continuamente desenvolvidos e mantidos durante anos ou mesmo dezenas de anos por muitas pessoas. E como muitas vezes existem muitas pessoas que dependem (às vezes de maneira crítica) deste software, as regressões são realmente um grande problema.</p>
</div>
<div class="paragraph">
<p>Um destes softwares é o kernel do Linux. E se olharmos para o kernel Linux, podemos ver que muito tempo e esforço são gastos para combater as regressões. O ciclo de lançamento começa com uma janela de mesclagem de duas semanas. Em seguida, o candidato do primeiro lançamento (rc) é marcado. E depois disso, cerca de 7 ou 8 versões de candidatos aparecerão com cerca de uma semana de espaço entre cada uma delas, antes do lançamento final.</p>
</div>
<div class="paragraph">
<p>O tempo entre a primeira versão rc (release candidate = versão de lançamento) e a versão final deve ser utilizado para testar as versões rc, resolver os bugs e especialmente as regressões. Mais de 80% deste tempo gira em torno do ciclo de lançamento. Mas este ainda não é o fim da batalha, pois é óbvio que ele continua após o seu lançamento.</p>
</div>
<div class="paragraph">
<p>E é isso que o Ingo Molnar (um informado desenvolvedor de kernel do Linux) diz sobre o uso do <em>git bisect</em>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Eu o utilizo de forma mais ativa durante a janela da mesclagem (quando muitas árvores são mescladas na upstream e quando o influxo de bugs é mais alto) - e sim, houve casos onde eu o usei várias vezes no dia. Minha média é de aproximadamente uma vez por dia.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Portanto, as regressões são combatidas o tempo todo pelos desenvolvedores e de fato, é sabido que os bugs devem ser corrigidos o mais rápido possível, tão logo sejam encontrados. É por isso que é importante ter boas ferramentas para este fim.</p>
</div>
</div>
<div class="sect2">
<h3 id="_outras_ferramentas_para_combater_as_regressões"><a class="anchor" href="#_outras_ferramentas_para_combater_as_regressões"></a>Outras ferramentas para combater as regressões</h3>
<div class="paragraph">
<p>Então, quais são as ferramentas utilizadas para combater as regressões? Eles são quase os mesmos daqueles utilizados para combater os bugs tradicionais. As únicas ferramentas específicas são pacotes de testes e as ferramentas similares ao "git bisect".</p>
</div>
<div class="paragraph">
<p>Os conjuntos de teste são muito legais. Mas quando eles são utilizados sozinhos, eles devem ser usados para que todos os testes sejam verificados após cada commit. Isto significa que eles não são muito eficientes, porque muitos testes são realizados sem resultados interessantes e sofrem com explosões combinatórias.</p>
</div>
<div class="paragraph">
<p>De fato, o problema é que um software grande geralmente possui muitas opções de configuração diferentes e que cada caso de teste deve passar para cada configuração após cada commit. Portanto, caso tenha para cada release: <em>N</em> configurações, <em>M</em> commits e <em>T</em> casos de teste, execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>N * M * T tests</pre>
</div>
</div>
<div class="paragraph">
<p>onde <em>N</em>, <em>M</em> e <em>T</em> estão crescendo com o tamanho do seu software.</p>
</div>
<div class="paragraph">
<p>Logo, não será possível testar completamente tudo.</p>
</div>
<div class="paragraph">
<p>E caso alguns erros passarem pelo seu conjunto de testes, você poderá adicionar um teste ao seu conjunto de testes. Porém caso queira utilizar o seu novo conjunto aprimorado de testes para descobrir onde o erro ocorreu, será necessário emular um processo de bisseção ou talvez você teste cada commit sem rodeios de forma inversa a partir do commit "ruim" que você possa ter, sendo um total desperdício.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_visão_geral_do_git_bisect"><a class="anchor" href="#_visão_geral_do_git_bisect"></a>Visão geral do "git bisect"</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_iniciando_uma_bisseção"><a class="anchor" href="#_iniciando_uma_bisseção"></a>Iniciando uma bisseção</h3>
<div class="paragraph">
<p>O primeiro subcomando "git bisect" que será usado é "git bisect start" para iniciar a pesquisa. Em seguida, os limites devem ser definidos para limitar o espaço dos commits. Isso geralmente é feito com um commit "ruim" e pelo menos um commit "bom". Eles podem ser passados na chamada inicial para o comando "git bisect start" assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start [BAD [GOOD...]]</pre>
</div>
</div>
<div class="paragraph">
<p>ou eles podem ser definidos usando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect bad [COMMIT]</pre>
</div>
</div>
<div class="paragraph">
<p>e:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect good [COMMIT...]</pre>
</div>
</div>
<div class="paragraph">
<p>onde <code>BAD</code>, <code>GOOD</code> e <code>COMMIT</code> são todos os nomes que podem ser resolvidos para um commit.</p>
</div>
<div class="paragraph">
<p>Então, o comando "git bisect" fará a averiguação de um commit de sua escolha e solicitará que o usuário o teste, assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start v2.6.27 v2.6.25
Bisecting: 10928 revisions left to test after this (roughly 14 steps)
[2ec65f8b89ea003c27ff7723525a2ee335a2b393] x86: clean up using max_low_pfn on 32-bit</pre>
</div>
</div>
<div class="paragraph">
<p>Observe que o exemplo que usaremos é realmente um exemplo de brinquedo; procuraremos o primeiro commit que possui uma versão como "2.6.26-alguma-coisa", ou seja, o commit que possua uma linha "SUBLEVEL = 26" no nível mais alto do Makefile. Este é um exemplo de um brinquedo, porque existem maneiras melhores para encontrar este commit com o Git em vez de utilizar o "git bisect" (por exemplo, "git blame" ou "git log -S&lt;texto&gt;").</p>
</div>
</div>
<div class="sect2">
<h3 id="_conduzindo_uma_bisseção_manualmente"><a class="anchor" href="#_conduzindo_uma_bisseção_manualmente"></a>Conduzindo uma bisseção manualmente</h3>
<div class="paragraph">
<p>Neste ponto, existem basicamente duas maneiras de conduzir a pesquisa. Pode ser acionado manualmente através do usuário ou automaticamente através de um script ou comando.</p>
</div>
<div class="paragraph">
<p>Caso o usuário esteja conduzindo, em cada etapa da pesquisa, o usuário terá que testar a confirmação atual e dizer se é "bom" ou "ruim" utilizando os comandos <em>git bisect good</em> or <em>git bisect bad</em> respectivamente, como foram descritos acima. Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect bad
Bisecting: 5480 revisions left to test after this (roughly 13 steps)
[66c0b394f08fd89236515c1c84485ea712a157be] KVM: kill file-&gt;f_count abuse in kvm</pre>
</div>
</div>
<div class="paragraph">
<p>E após mais algumas etapas como essa, o comando "git bisect" acabará por encontrar um primeiro commit incorreto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect bad
2ddcca36c8bcfa251724fe342c8327451988be0d is the first bad commit
commit 2ddcca36c8bcfa251724fe342c8327451988be0d
Autor: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Data:   Sáb Mai 3 11:59:44 2008 -0700

    Linux 2.6.26-rc1

:100644 100644 5cf82581... 4492984e... M      Makefile</pre>
</div>
</div>
<div class="paragraph">
<p>Neste ponto, podemos ver o que o commit faz, dar uma olhada (se ainda não tiver feito a averiguação) ou mexer com ele, por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git show HEAD
commit 2ddcca36c8bcfa251724fe342c8327451988be0d
Autor: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Data:   Sáb Mai 3 11:59:44 2008 -0700

    Linux 2.6.26-rc1

diff --git a/Makefile b/Makefile
index 5cf8258..4492984 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
-SUBLEVEL = 25
-EXTRAVERSION =
+SUBLEVEL = 26
+EXTRAVERSION = -rc1
 NAME = Funky Weasel is Jiggy wit it

 # *DOCUMENTAÇÃO*</pre>
</div>
</div>
<div class="paragraph">
<p>E quando terminarmos, podemos usar o comando "git bisect reset" para voltar ao ramo em que estávamos antes de começarmos a dividir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect reset
Checking out files: 100% (21549/21549), done.
Previous HEAD position was 2ddcca3... Linux 2.6.26-rc1
Switched to branch 'master'</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conduzindo_uma_bisseção_automaticamente"><a class="anchor" href="#_conduzindo_uma_bisseção_automaticamente"></a>Conduzindo uma bisseção automaticamente</h3>
<div class="paragraph">
<p>A outra maneira de conduzir o processo de bisseção é dizer ao <code>git bisect</code> para lançar um script ou comando a cada etapa da bisseção para saber se o compromisso atual é "bom" ou "ruim". Para fazer isso, nós usamos o comando "git bisect run". Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start v2.6.27 v2.6.25
Bisecting: 10928 revisions left to test after this (roughly 14 steps)
[2ec65f8b89ea003c27ff7723525a2ee335a2b393] x86: clean up using max_low_pfn on 32-bit
$
$ git bisect run grep '^SUBLEVEL = 25' Makefile
running grep ^SUBLEVEL = 25 Makefile
Bisecting: 5480 revisions left to test after this (roughly 13 steps)
[66c0b394f08fd89236515c1c84485ea712a157be] KVM: kill file-&gt;f_count abuse in kvm
running grep ^SUBLEVEL = 25 Makefile
SUBLEVEL = 25
Bisecting: 2740 revisions left to test after this (roughly 12 steps)
[671294719628f1671faefd4882764886f8ad08cb] V4L/DVB(7879): Adding cx18 Support for mxl5005s
...
...
running grep ^SUBLEVEL = 25 Makefile
Bisecting: 0 revisions left to test after this (roughly 0 steps)
[2ddcca36c8bcfa251724fe342c8327451988be0d] Linux 2.6.26-rc1
running grep ^SUBLEVEL = 25 Makefile
2ddcca36c8bcfa251724fe342c8327451988be0d is the first bad commit
commit 2ddcca36c8bcfa251724fe342c8327451988be0d
Author: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Date:   Sat May 3 11:59:44 2008 -0700

    Linux 2.6.26-rc1

:100644 100644 5cf82581... 4492984e... M      Makefile
bisect run success</pre>
</div>
</div>
<div class="paragraph">
<p>Neste exemplo, passamos "grep <em>^SUBLEVEL = 25</em> Makefile" como parâmetro para o comando <code>git bisect run</code>. Isso significa que, a cada passo, o comando <em>grep</em> que encaminhamos será iniciado. E caso encerre com o código 0 (que significa sucesso), o comando <code>git bisect</code> marcará a condição atual como "bom". Caso encerre com o código 1 (ou qualquer código entre 1 e incluindo o 127, exceto o código especial 125), a condição atual será marcado como "ruim".</p>
</div>
<div class="paragraph">
<p>O código de saída entre 128 e 255 é especial para o comando "git bisect run". Eles fazem parar imediatamente o processo de bisseção. É útil por exemplo, caso o comando encaminhado demorar muito para ser concluído, por é possível encerrá-lo com um sinal que interromperá o processo de bisseção.</p>
</div>
<div class="paragraph">
<p>Também pode ser útil nos scripts encaminhados para o comando "git bisect run" para "exit 255" Caso alguma situação muito anormal seja detectada.</p>
</div>
</div>
<div class="sect2">
<h3 id="_evitando_os_commits_que_não_foram_testados"><a class="anchor" href="#_evitando_os_commits_que_não_foram_testados"></a>Evitando os commits que não foram testados</h3>
<div class="paragraph">
<p>Às vezes, acontece que a condição atual não possa ser testada, por exemplo, caso ele não seja compilado porque houve um erro que o impedia naquele momento. É para isso que serve o código de encerramento especial 125. Diz ao comando "git bisect run" que o commit atual deve ser marcado como não testável e que outro deve ser selecionado e averiguado.</p>
</div>
<div class="paragraph">
<p>Caso o processo de bisseção tenha sido conduzido manualmente, será possível utilizar o comando "git bisect skip" para realizar a mesma coisa. (De fato, o código de saída especial 125 faz o comando "git bisect run" utilizar "git bisect skip" em segundo plano.)</p>
</div>
<div class="paragraph">
<p>Ou, caso queira mais controle, poderá inspecionar a condição atual usando, por exemplo, o comando "git bisect visualize". Ele iniciará o gitk (ou o comando "git log" caso a variável de ambiente <code>DISPLAY</code> não estiver configurada) para ajudá-lo a encontrar um melhor ponto de bisseção.</p>
</div>
<div class="paragraph">
<p>De qualquer forma, caso você tenha uma sequência de commits não testáveis, pode acontecer que a regressão que você está procurando tenha sido introduzido por um destes commits não testáveis. Nesse caso, não é possível saber com certeza qual o commit introduziu a regressão.</p>
</div>
<div class="paragraph">
<p>Portanto, tenha utilizado o comando "git bisect skip" (ou o script de execução encerrou com o código especial 125), poderá obter um resultado como este:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Restam apenas os commits que foram 'ignorados' e faltam testar.
O primeiro commit incorreto pode ser qualquer um destes:
15722f2fa328eaba97022898a305ffc8172db6b1
78e86cf3e850bd755bb71831f42e200626fbd1e0
e15b73ad3db9b48d7d1ade32f8cd23a751fe0ace
070eab2303024706f2924822bfec8b9847e4ac1b
Não podemos mais seguir adiante com o bisect!</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_salvando_um_registro_log_e_reproduzindo_o"><a class="anchor" href="#_salvando_um_registro_log_e_reproduzindo_o"></a>Salvando um registro log e reproduzindo-o</h3>
<div class="paragraph">
<p>Caso queira exibir para outras pessoas o seu processo de bisseção, é possível obter um registro log utilizando, por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect log &gt; bisect_log.txt</pre>
</div>
</div>
<div class="paragraph">
<p>E é possível reproduzi-lo utilizando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect replay bisect_log.txt</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_detalhes_do_git_bisect"><a class="anchor" href="#_detalhes_do_git_bisect"></a>Detalhes do "git bisect"</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_algoritmo_da_bisseção"><a class="anchor" href="#_algoritmo_da_bisseção"></a>Algoritmo da bisseção</h3>
<div class="paragraph">
<p>Como o commit do Git forma um grafo acíclico direcionado (DAG), encontrar o melhor commit de bisseção para testar em cada etapa não é tão simples. De qualquer forma, Linus encontrou e implementou um algoritmo "de forama verdadeiramente estúpida", posteriormente aprimorado por Junio Hamano, que funciona muito bem.</p>
</div>
<div class="paragraph">
<p>Portanto, o algoritmo usado pelo comando "git bisect" para encontrar a melhor bisseção do commit quando não há commits que foram ignorados é o seguinte:</p>
</div>
<div class="paragraph">
<p>1) mantenha apenas os commits que:</p>
</div>
<div class="paragraph">
<p>a) são ancestrais do commit "ruim" (incluindo o próprio commit "ruim"),
b) não são ancestrais de um commit "bom" (excluindo os commits "bons").</p>
</div>
<div class="paragraph">
<p>Significa que nos livramos dos commits que não interessam do DAG.</p>
</div>
<div class="paragraph">
<p>Como por exemplo, caso comecemos com um grafo como este:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>G-Y-G-W-W-W-X-X-X-X
	   \ /
	    W-W-B
	   /
Y---G-W---W
 \ /   \
Y-Y     X-X-X-X

-&gt; o tempo passa neste sentido -&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>onde <em>B</em> é o commit "ruim", o "G" são os commits "bons" e <em>W</em>, <em>X</em> e <em>Y</em> são outros commits, obteremos o seguinte grafo após esta primeira etapa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>W-W-W
     \
      W-W-B
     /
W---W</pre>
</div>
</div>
<div class="paragraph">
<p>Portanto, apenas os commits <em>W</em> e <em>B</em> serão mantidos. Como os commits <em>X</em> e <em>Y</em> serão removidos pelas regras a) e b) respectivamente, e porque os commits <em>G</em> são removidos pela regra b) também.</p>
</div>
<div class="paragraph">
<p>Nota para os usuários do Git, é equivalente a manter apenas o commit informado por:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git rev-list BAD --not GOOD1 GOOD2...</pre>
</div>
</div>
<div class="paragraph">
<p>Observe também que não exigimos que os commits mantidos sejam descendentes de um "bom" commit. Portanto, no exemplo a seguir, os commits <em>W</em> e <em>Z</em> serão mantidas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>G-W-W-W-B
   /
Z-Z</pre>
</div>
</div>
<div class="paragraph">
<p>2) a partir das extremidades "boas" do grafo, associe para cada commit a quantidade de ancestrais que possui mais um</p>
</div>
<div class="paragraph">
<p>Como por exemplo, com o grafo a seguir, onde <em>H</em> é o commit "ruim" e <em>A</em> e o <em>D</em> são alguns parentes de alguns commits "bons":</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A-B-C
     \
      F-G-H
     /
D---E</pre>
</div>
</div>
<div class="paragraph">
<p>isto nos dá:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1 2 3
A-B-C
     \6 7 8
      F-G-H
1   2/
D---E</pre>
</div>
</div>
<div class="paragraph">
<p>3) associado para cada commit: min(X, N - X)</p>
</div>
<div class="paragraph">
<p>onde <em>X</em> é o valor associado ao commit na etapa 2) e <em>N</em> é a quantidade total dos commits no grafo.</p>
</div>
<div class="paragraph">
<p>No exemplo acima, temos <em>N=8</em>, portanto, isso dará:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1 2 3
A-B-C
     \2 1 0
      F-G-H
1   2/
D---E</pre>
</div>
</div>
<div class="paragraph">
<p>4) o melhor ponto de bisseção é o commit com o maior número associado a ele</p>
</div>
<div class="paragraph">
<p>Portanto, no exemplo acima, o melhor ponto de bisseção é o commit <em>C</em>.</p>
</div>
<div class="paragraph">
<p>5) observe que alguns atalhos são implementados para acelerar o algoritmo</p>
</div>
<div class="paragraph">
<p>Como conhecemos o "N" desde o início, sabemos que mínimo (X, N - X) não pode ser maior que N/2. Portanto, durante as etapas 2) e 3), se associarmos N/2 a um commit, sabemos que este é o melhor ponto de bisseção. Portanto neste caso, podemos simplesmente parar de processar qualquer outro commit e retorne para o commit atual.</p>
</div>
</div>
<div class="sect2">
<h3 id="_depuração_do_algoritmo_da_bisseção"><a class="anchor" href="#_depuração_do_algoritmo_da_bisseção"></a>Depuração do algoritmo da bisseção</h3>
<div class="paragraph">
<p>Para qualquer grafo do commit, você pode ver o número associado a cada commit utilizando o comando "git rev-list --bisect-all".</p>
</div>
<div class="paragraph">
<p>Por exemplo, para o grafo acima, o comando seria:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git rev-list --bisect-all BAD --not GOOD1 GOOD2</pre>
</div>
</div>
<div class="paragraph">
<p>geraria algo como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>e15b73ad3db9b48d7d1ade32f8cd23a751fe0ace (dist=3)
15722f2fa328eaba97022898a305ffc8172db6b1 (dist=2)
78e86cf3e850bd755bb71831f42e200626fbd1e0 (dist=2)
a1939d9a142de972094af4dde9a544e577ddef0e (dist=2)
070eab2303024706f2924822bfec8b9847e4ac1b (dist=1)
a3864d4f32a3bf5ed177ddef598490a08760b70d (dist=1)
a41baa717dd74f1180abf55e9341bc7a0bb9d556 (dist=1)
9e622a6dad403b71c40979743bb9d5be17b16bd6 (dist=0)</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_discussão_sobre_o_algoritmo_da_bissecção"><a class="anchor" href="#_discussão_sobre_o_algoritmo_da_bissecção"></a>Discussão sobre o algoritmo da bissecção</h3>
<div class="paragraph">
<p>Primeiro vamos definir "melhor ponto de bisseção". Digamos que um commt <em>X</em> é o melhor ponto de bisseção ou um melhor commit de bisseção caso conheça a sua condição ("bom" ou "ruim") fornece o máximo de informações possíveis caso a condição do commit seja "bom" ou "ruim".</p>
</div>
<div class="paragraph">
<p>Isto significa que as melhores bisseção dos commits são os commits onde a seguinte função seja máxima:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>f(X) = min(information_if_good(X), information_if_bad(X))</pre>
</div>
</div>
<div class="paragraph">
<p>onde <em>information_if_good(X)</em> é a informação que obtemos caso <em>X</em> seja bom e <em>information_if_bad(X)</em> é a informação que obtemos caso <em>X</em> seja ruim.</p>
</div>
<div class="paragraph">
<p>Agora vamos supor que exista apenas um "primeiro commit ruim". Isto significa que todos os seus descendentes são "ruins" e todos os outros commits são "bons". E iremos supor que todos os commits têm uma probabilidade igual de serem bons ou ruins, ou de serem o primeiro commit incorreto, portanto, conhecer a condição do commit <em>c</em> dá sempre a mesma quantidade de informações onde quer que estes commits <em>c</em> estejam no grafo e independente do que o <em>c</em> seja. (Portanto, supomos que estes commits, seja por exemplo, em um ramo ou próximo a um commit bom ou ruim, não forneçam mais ou menos informações).</p>
</div>
<div class="paragraph">
<p>Vamos supor também que tenhamos um grafo limpo como um após o outro
1) no algoritmo de bisseção acima. Isso significa que podemos medir as informações que obtemos em termos quantidade dos commits que podemos remover do grafo.</p>
</div>
<div class="paragraph">
<p>E vamos receber um commit <em>X</em> no grafo.</p>
</div>
<div class="paragraph">
<p>Caso <em>X</em> seja considerado "bom", sabemos que os seus ancestrais são todos "bons", então queremos dizer que:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>information_if_good(X) = number_of_ancestors(X)  (TRUE)</pre>
</div>
</div>
<div class="paragraph">
<p>E isso é verdade porque na etapa 1) b) removemos os ancestrais dos "bons" commits.</p>
</div>
<div class="paragraph">
<p>Caso <em>X</em> seja considerado "ruim", sabemos que todos os seus descendentes são "ruins", então queremos dizer que:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>information_if_bad(X) = number_of_descendants(X)  (WRONG)</pre>
</div>
</div>
<div class="paragraph">
<p>Mas é errado, porque na etapa 1) a) mantemos apenas os ancestrais dos commits ruins. Então obtemos mais informações quando um commit é marcado como "ruim", porque também sabemos que os ancestrais do commit "ruim" anterior, não são ancestrais do novo commit "ruim" que não são o primeiro commit incorreto. Não sabemos se eles são bons ou ruins, porém sabemos que eles não são o primeiro commit incorreto porque não são ancestrais do novo commit "ruim".</p>
</div>
<div class="paragraph">
<p>Portanto, quando um commit é marcado como "ruim", sabemos que podemos remover todos os commit no grafo, exceto aqueles que são os ancestrais do novo commit "ruim". Isto significa que:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>information_if_bad(X) = N - number_of_ancestors(X)  (TRUE)</pre>
</div>
</div>
<div class="paragraph">
<p>onde <em>N</em> é a quantidade de commits no grafo (limpos).</p>
</div>
<div class="paragraph">
<p>Portanto, no final, isso significa que, para encontrar as melhores bisseções dos commits, devemos maximizar a função:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>f(X) = min(number_of_ancestors(X), N - number_of_ancestors(X))</pre>
</div>
</div>
<div class="paragraph">
<p>E isso é bom porque na etapa 2) calculamos a number_of_ancestors(X) e, portanto, na etapa 3) calculamos f(X).</p>
</div>
<div class="paragraph">
<p>Vamos tomar o seguinte grafo como exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>            G-H-I-J
           /       \
A-B-C-D-E-F         O
           \       /
            K-L-M-N</pre>
</div>
</div>
<div class="paragraph">
<p>Caso calculemos a seguinte função não ideal nela:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g(X) = min(number_of_ancestors(X), number_of_descendants(X))</pre>
</div>
</div>
<div class="paragraph">
<p>nós temos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>            4 3 2 1
            G-H-I-J
1 2 3 4 5 6/       \0
A-B-C-D-E-F         O
           \       /
            K-L-M-N
            4 3 2 1</pre>
</div>
</div>
<div class="paragraph">
<p>porém com o algorítimo utilizado pelo <em>git bisect</em> nós temos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>            7 7 6 5
            G-H-I-J
1 2 3 4 5 6/       \0
A-B-C-D-E-F         O
           \       /
            K-L-M-N
            7 7 6 5</pre>
</div>
</div>
<div class="paragraph">
<p>Então escolhemos <em>G</em>, <em>H</em>, <em>K</em> ou <em>L</em> como o melhor ponto de bisseção, que é melhor que <em>F</em>. Porque, por exemplo, o <em>L</em> é ruim, saberemos não apenas que <em>L</em>, <em>M</em> e <em>N</em> são ruins, mas também que o <em>G</em>, <em>H</em>, <em>I</em> e <em>J</em> não são os primeiros commits ruins (pois supomos que haja apenas um primeiro commit ruim e ele deve ser um ancestral do <em>L</em>).</p>
</div>
<div class="paragraph">
<p>Portanto, o algoritmo atual parece ser o melhor possível, dado o que supomos inicialmente.</p>
</div>
</div>
<div class="sect2">
<h3 id="_algoritmo_de_salto"><a class="anchor" href="#_algoritmo_de_salto"></a>Algoritmo de salto</h3>
<div class="paragraph">
<p>Quando alguns commits forem ignoradas (utilizando o comando "git bisect skip"), o algoritmo de bisseção é o mesmo da etapa 1) a 3). Então utilizamos aproximadamente as seguintes etapas:</p>
</div>
<div class="paragraph">
<p>6) classifique o commit diminuindo o valor associado</p>
</div>
<div class="paragraph">
<p>7) se o primeiro commit não foi ignorado, podemos retorná-lo e parar aqui</p>
</div>
<div class="paragraph">
<p>8) caso contrário, filtre todos os commits ignorados da lista</p>
</div>
<div class="paragraph">
<p>9) use um gerador de número pseudo-aleatório (PRNG) para gerar um número aleatório entre <em>0</em> e <em>1</em></p>
</div>
<div class="paragraph">
<p>10) multiplique este número aleatório com a a sua raiz quadrada para enviesá-lo para 0</p>
</div>
<div class="paragraph">
<p>11) multiplicada o resultado pela quantidade dos commits na lista dos filtrados e obtenha um índice nesta lista</p>
</div>
<div class="paragraph">
<p>12) retorne o commit ao índice que foi processado</p>
</div>
</div>
<div class="sect2">
<h3 id="_discussão_sobre_o_algoritmo_de_salto"><a class="anchor" href="#_discussão_sobre_o_algoritmo_de_salto"></a>Discussão sobre o algoritmo de salto</h3>
<div class="paragraph">
<p>Após a etapa 7) (no algoritmo <em>skip</em>), poderíamos verificar se o segundo commit foi ignorado e retorná-lo, se não for o caso. E de fato, este foi o algoritmo que utilizamos quando o comando "git bisect skip" foi desenvolvido no Git versão 1.5.4 (lançado em 1º de fevereiro de 2008) até o Git versão 1.6.4 (lançado em 29 de julho de 2009).</p>
</div>
<div class="paragraph">
<p>Porém o Ingo Molnar e o H. Peter Anvin (outro informado desenvolvedor de kernel do linux) reclamaram que às vezes os melhores pontos de bisseção aconteciam em uma área onde todos os commits eram testáveis. E neste caso, o usuário foi solicitado a testar muitos commits onde não são possíveis de serem testados, o que poderia ser muito ineficiente.</p>
</div>
<div class="paragraph">
<p>Na verdade, os commits não testáveis geralmente não são testáveis porque uma quebra foi introduzida em algum momento, e essa quebra foi corrigida somente depois que muitos outras commits foram introduzidos.</p>
</div>
<div class="paragraph">
<p>Naturalmente, essa quebra não está relacionada à quebra que estamos tentando localizar no grafo do commit. Porém isso nos impede de saber se o "mau comportamento" que interessa está presente ou não.</p>
</div>
<div class="paragraph">
<p>Portanto, é fato que os commits próximos de um commit onde o teste não possa ser feito têm uma alta probabilidade de serem elas mesmas as não testáveis. Os melhores commits para bisseção também são frequentemente encontrados juntos (devido ao algoritmo de bisseção).</p>
</div>
<div class="paragraph">
<p>É por isso que é uma péssima ideia escolher a próxima melhor bisseção do commit que não foi ignorado quando o primeiro tenha sido ignorado.</p>
</div>
<div class="paragraph">
<p>Descobrimos que a maioria dos commits no grafo pode fornecer muitas informações quando são testadas. E os commits que, em média, não fornecerão muita informação são os próximos commits bons e ruins.</p>
</div>
<div class="paragraph">
<p>Portanto, ao usar um PRNG com um viés para favorecer os commits longe dos commits bons e ruins parecia ser uma boa escolha.</p>
</div>
<div class="paragraph">
<p>Uma melhoria óbvia neste algoritmo seria procurar por um commit que tenha um valor associado próximo ao do melhor commit de bisseção e que esteja em outra ramificação, antes de utilizar o PRNG. Pois caso este commit exista, é muito provável que também não seja testável, logo, provavelmente fornecerá mais informações do que o que foi selecionado aleatoriamente.</p>
</div>
</div>
<div class="sect2">
<h3 id="_verificando_as_bases_mescladas"><a class="anchor" href="#_verificando_as_bases_mescladas"></a>Verificando as bases mescladas</h3>
<div class="paragraph">
<p>Há outro ajuste no algoritmo de bisseção que não foi descrito no "algoritmo de bisseção" acima.</p>
</div>
<div class="paragraph">
<p>Nos exemplos anteriores, supomos que os commits "bons" eram ancestrais do commit "ruim". Porém isto não é um requisito do "git bisect".</p>
</div>
<div class="paragraph">
<p>É claro que o commit "ruim" não pode ser um ancestral de um commit "bom", porque os ancestrais dos commits bons devem ser "bons". E todos os commits "bons" devem estar relacionados ao commit ruim. Eles não podem estar numa ramificação que não tenha vínculo com a ramificação do commit "ruim". Mas é possível que um commit bom esteja relacionado a um commit ruim e, ainda assim, não seja nem um de seus ancestrais nem um de seus descendentes.</p>
</div>
<div class="paragraph">
<p>Como por exemplo, pode haver um ramo "main" (principal) e um ramo "dev" que foi bifurcada no ramo principal em um commit chamado "D" desta maneira:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A-B-C-D-E-F-G  &lt;--main
       \
        H-I-J  &lt;--dev</pre>
</div>
</div>
<div class="paragraph">
<p>O commit "D" é chamado de uma "base de mesclagem" para o ramo "main" e "dev" pois é o melhor ancestral comum destas ramificações para uma mesclagem.</p>
</div>
<div class="paragraph">
<p>Agora, suponha que o commit J seja ruim, que o commit G seja bom e que apliquemos o algoritmo de bisseção como foi descrito anteriormente.</p>
</div>
<div class="paragraph">
<p>Conforme descrito na etapa 1) b) do algoritmo de bisseção, removemos todos os ancestrais dos commits bons porque eles também devem ser bons.</p>
</div>
<div class="paragraph">
<p>Então, ficaríamos com apenas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>H-I-J</pre>
</div>
</div>
<div class="paragraph">
<p>Mas o que acontece caso o primeiro commit incorreto seja o "B" e se foi corrigido no ramo "principal" (main) pelo commit "F"?</p>
</div>
<div class="paragraph">
<p>O resultado dessa bisseção seria que descobriríamos que "H" é o primeiro commit ruim, quando na verdade é o "B". Portanto, isso seria errado!</p>
</div>
<div class="paragraph">
<p>E sim, na prática pode acontecer das pessoas que trabalham em um ramo não estejam cientes que as pessoas que trabalham no outro ramo corrigiram um bug! Também pode acontecer que F tenha corrigido mais de um bug ou que seja uma reversão de algum grande esforço de desenvolvimento que não estava pronto para ser liberado.</p>
</div>
<div class="paragraph">
<p>De fato, as equipes de desenvolvimento geralmente mantêm um ramo de desenvolvimento e um ramo de manutenção, seria muito fácil para eles caso o comando "git bisect" funcionasse quando quisessem dividir uma regressão no ramo de desenvolvimento que não está no ramo de manutenção. Eles devem ser capaz de começar a dividir utilizando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start dev main</pre>
</div>
</div>
<div class="paragraph">
<p>Para ativar esse recurso adicional, quando uma bisseção é iniciada e quando alguns commits bons não são ancestrais do commit ruim, primeiro calculamos a mesclagem das bases entre os commits ruins e os bons, escolhemos estas bases da mesclagem como os primeiros commits que serão averiguados e testados.</p>
</div>
<div class="paragraph">
<p>Caso ocorra de uma base que foi mesclada esteja ruim, o processo de bisseção será interrompido com uma mensagem como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A base da mesclagem BBBBBB é ruim.
Isto significa que o bug foi corrigido entre BBBBBB e [GGGGGG, ...].</pre>
</div>
</div>
<div class="paragraph">
<p>onde BBBBBB é o hash sha1 da base de mesclagem ruim e [GGGGGG, &#8230;&#8203;] é uma lista separada por vírgulas do sha1 do bom commit.</p>
</div>
<div class="paragraph">
<p>Caso algumas das mesclagens das bases sejam ignoradas, o processo de bisseção continuará, porém a seguinte mensagem será impressa para cada mesclagem da base que foi ignorada:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Aviso: a base da mesclagem entre BBBBBB e [GGGGGG,...] deve ser ignorado.
Portanto, não podemos ter certeza de que o primeiro commit ruim esteja entre MMMMMM e BBBBBB.
Continuamos mesmo assim.</pre>
</div>
</div>
<div class="paragraph">
<p>onde BBBBBB é o hash sha1 do commit ruim, o MMMMMM é o sha1 da base da mesclagem que é ignorado e [GGGGGG, &#8230;&#8203;] é uma lista separada por vírgulas do sha1 dos commits bons.</p>
</div>
<div class="paragraph">
<p>Portanto, caso não haja uma base da mesclagem ruim, o processo de bisseção continuará normalmente após esta etapa.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_melhores_práticas_para_as_bisseções"><a class="anchor" href="#_melhores_práticas_para_as_bisseções"></a>Melhores práticas para as bisseções</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_usando_conjuntos_de_teste_e_o_comando_git_bisect_juntos"><a class="anchor" href="#_usando_conjuntos_de_teste_e_o_comando_git_bisect_juntos"></a>Usando conjuntos de teste e o comando <em>git bisect</em> juntos</h3>
<div class="paragraph">
<p>Caso você possua um conjunto de testes e utiliza o <code>git bisect</code>, torna-se menos importante verificar se todos os testes passam após cada confirmação. Embora, claro, seja provavelmente uma boa ideia fazer algumas verificações para evitar a quebra de muitas coisas pois isso pode dificultar a bisseção dos outros bugs.</p>
</div>
<div class="paragraph">
<p>Você pode concentrar os teus esforços para verificar alguns pontos (as versões rc e beta por exemplo) que todos os casos de teste <em>T</em> passam por todas as <em>N</em> configurações. E quando alguns testes não passam, você pode usar "git bisect" (ou melhor, "git bisect run"). Então você deve executar a grosso modo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>c * N * T + b * M * log2(M) tests</pre>
</div>
</div>
<div class="paragraph">
<p>onde <em>c</em> é a quantidade de rodadas de teste (portanto, uma constante pequena) e <em>b</em> é a proporção dos erros por commit(espero que também seja uma constante pequena).</p>
</div>
<div class="paragraph">
<p>Então é claro que é muito melhor que O(N * T) vs O(N * T * M) caso testasse tudo após cada commit.</p>
</div>
<div class="paragraph">
<p>Isto significa que os conjuntos de testes são bons para evitar que o commit de alguns bugs sejam feitos e também são bons para dizer que você tem alguns bugs. Mas eles não são tão bons para dizer onde alguns erros foram introduzidos. Para te dizer isso eficientemente, o comando <em>git bisect</em> é necessário.</p>
</div>
<div class="paragraph">
<p>A outra coisa interessante dos conjuntos de testes é que, quando você tem um, já sabe como testar o mau comportamento. Portanto, você pode usar este conhecimento para criar um novo caso de teste para o comando "git bisect" quando parecer que uma regressão existe. Portanto, será mais fácil dividir o bug e corrigi-lo. E então você pode adicionar o caso de teste que você acabou de criar ao seu conjunto de testes.</p>
</div>
<div class="paragraph">
<p>Portanto, caso saiba criar casos de teste e dividir em partes, estará sujeito a um círculo virtuoso:</p>
</div>
<div class="paragraph">
<p>mais testes &#8658; mais fácil de criar testes &#8658; mais fácil de fazer <em>bisect</em> &#8658; mais testes</p>
</div>
<div class="paragraph">
<p>Portanto, os conjuntos de testes e o comando "git bisect", quando utilizadas em conjunto, são ferramentas complementares que são muito poderosas e eficientes.</p>
</div>
</div>
<div class="sect2">
<h3 id="_falhas_na_construção_da_bisseção"><a class="anchor" href="#_falhas_na_construção_da_bisseção"></a>Falhas na construção da bisseção</h3>
<div class="paragraph">
<p>Você pode facilmente fazer o <em>bisect</em> automaticamente em construções quebradas usando algo como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start BAD GOOD
$ git bisect run make</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_encaminhando_sh_c_alguns_comandos_para_git_bisect_run"><a class="anchor" href="#_encaminhando_sh_c_alguns_comandos_para_git_bisect_run"></a>Encaminhando sh -c "alguns comandos" para "git bisect run"</h3>
<div class="paragraph">
<p>Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect run sh -c "make || exit 125; ./my_app | grep 'good output'"</pre>
</div>
</div>
<div class="paragraph">
<p>Por outro lado, caso faça isso com frequência, pode valer a pena ter scripts para evitar muita digitação.</p>
</div>
</div>
<div class="sect2">
<h3 id="_localizando_regressões_de_desempenho"><a class="anchor" href="#_localizando_regressões_de_desempenho"></a>Localizando regressões de desempenho</h3>
<div class="paragraph">
<p>Aqui está um exemplo do script que é ligeiramente modificado a partir de um script do mundo real utilizado por Junio Hamano <a href="#4">[4]</a>.</p>
</div>
<div class="paragraph">
<p>Este script pode ser passado através de um "git bisect run" para localizar um commit que introduziu uma regressão de desempenho:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>#!/bin/sh

# Os erros de compilação não me interessam.
make my_app || exit 255

# Estamos verificando se ele para em um período de tempo razoável, então
# deixe correr em segundo plano...

./my_app &gt;log 2&gt;&amp;1 &amp;

# ... e pega a ID do seu processo.
pid=$!

# ... e aguarde o tempo suficiente.
sleep $NORMAL_TIME

# ... e veja se o processo ainda está lá.
if kill -0 $pid
then
	# e se ainda estiver rodando -- isso é ruim.
	kill $pid; sleep 1; kill $pid;
	exit 1
else
	# Ele já terminou (o $pid do processo não existe mais),
	# e nós estamos felizes.
	exit 0
fi</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_seguindo_as_melhores_práticas_gerais"><a class="anchor" href="#_seguindo_as_melhores_práticas_gerais"></a>Seguindo as melhores práticas gerais</h3>
<div class="paragraph">
<p>Obviamente, é uma boa ideia não ter commits com alterações que conscientemente quebram as coisas, mesmo que os outros commits consigam consertar quebras posteriores.</p>
</div>
<div class="paragraph">
<p>Também é uma boa ideia ao usar qualquer VCS ter apenas uma pequena alteração lógica em cada commit.</p>
</div>
<div class="paragraph">
<p>Quanto menores as alterações no seu commit, mais eficaz será o "git bisect". E provavelmente você precisará do comando "git bisect", não de primeira pois as pequenas alterações são mais fáceis de revisar, mesmo que sejam revisadas apenas pelo responsável do envio.</p>
</div>
<div class="paragraph">
<p>Outra boa ideia é ter boas mensagens para os commits. Eles podem ser muito úteis para entender por que algumas alterações foram feitas.</p>
</div>
<div class="paragraph">
<p>Estas boas práticas são muito úteis caso você faça <em>bisect</em> com muita frequência.</p>
</div>
</div>
<div class="sect2">
<h3 id="_evitando_mesclagens_propensas_a_erros"><a class="anchor" href="#_evitando_mesclagens_propensas_a_erros"></a>Evitando mesclagens propensas a erros</h3>
<div class="paragraph">
<p>As primeiras mesclagens por si só podem introduzir algumas regressões, mesmo quando a mesclagem não precise de uma resolução de conflitos do código-fonte. Isso ocorre porque uma mudança semântica pode ocorrer em um ramo, enquanto o outro ramo não está ciente do que aconteceu.</p>
</div>
<div class="paragraph">
<p>Como por exemplo, um ramo pode alterar a semântica de uma função, enquanto o outro ramo adiciona mais chamadas à mesma função.</p>
</div>
<div class="paragraph">
<p>Piora muito caso muitos arquivos precisem ser corrigidos por causa de conflitos. É por isso que estas mesclagens são chamadas de "mesclagens más" (evil merges). Eles podem tornar as regressões muito difíceis de rastrear. Pode até ser enganador saber que o primeiro commit ruim, caso seja uma mesclagem deste tipo, porque as pessoas podem pensar que o bug vem de uma má resolução de conflito quando se trata de uma alteração semântica em um ramo.</p>
</div>
<div class="paragraph">
<p>De qualquer forma, "git rebase" pode ser utilizado para linearizar o histórico. Pode ser utilizado em primeiro lugar, para evitar a mesclagem. Ou pode ser utilizado para dividir um histórico linear em vez do que não seja linear, pois isso deve fornecer mais informações no caso de uma alteração semântica em um ramo.</p>
</div>
<div class="paragraph">
<p>As mesclagens também podem ser simplificadas utilizando os ramos menores ou ao utilizar muitos tópicos das ramificações, em vez de apenas as ramificações das versões mais longas.</p>
</div>
<div class="paragraph">
<p>E os testes podem ser feitos com mais frequência nos ramos nas integrações especiais como <em>linux-next</em> para o kernel do linux.</p>
</div>
</div>
<div class="sect2">
<h3 id="_adaptando_o_seu_fluxo_de_trabalho"><a class="anchor" href="#_adaptando_o_seu_fluxo_de_trabalho"></a>Adaptando o seu fluxo de trabalho</h3>
<div class="paragraph">
<p>Um fluxo de trabalho especial para processar as regressões pode dar ótimos resultados.</p>
</div>
<div class="paragraph">
<p>Aqui está um exemplo de um fluxo de trabalho utilizado por Andreas Ericsson:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>escreva, no conjunto de testes, um script de teste que exponha a regressão</p>
</li>
<li>
<p>Utilize um "git bisect run" para localizar o commit que introduziu um bug</p>
</li>
<li>
<p>corrija o bug que muitas vezes se torna óbvio na etapa anterior</p>
</li>
<li>
<p>faz o commit de ambas as correções e o script de teste (e se necessário, mais testes)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>E aqui está o que o Andreas disse sobre este fluxo de trabalho <a href="#5">[5]</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Para dar alguns números concretos, costumávamos ter um relatório médio para corrigir o ciclo de 142.6 horas (de acordo com nosso rastreador de bugs um tanto estranho que apenas mede o tempo). Desde que nos mudamos para o Git, diminuímos para 16.2 horas. Principalmente porque podemos ficar em cima da correção dos bugs agora e porque todo mundo está tentando resolver os bugs (estamos muito orgulhosos de como somos preguiçosos em deixar o Git encontrar os bugs para nós). Cada nova versão resulta em ~40% menos bugs (quase certamente devido à forma como nos sentimos ao escrever testes).</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Claramente, este fluxo de trabalho utiliza o círculo virtuoso entre os conjuntos de testes e o "git bisect". De fato, torna o procedimento padrão para lidar com a regressão.</p>
</div>
<div class="paragraph">
<p>Em outras mensagens, Andreas diz que eles também utilizam as "melhores práticas" descritas acima: pequenos commits lógicos, tópicos das ramificações, sem mesclagem "do mal",&#8230;&#8203; Todas estas práticas aprimoram a bisectabilidade do grafo do commit, tornando mais fácil e mais útil o processo de bisseção.</p>
</div>
<div class="paragraph">
<p>Portanto, um bom fluxo de trabalho deve ser projetado em torno dos pontos acima. Isso está tornando a divisão mais fácil, mais útil e padronizado.</p>
</div>
</div>
<div class="sect2">
<h3 id="_envolvendo_pessoas_do_controle_de_qualidade_e_se_possível_usuários_finais"><a class="anchor" href="#_envolvendo_pessoas_do_controle_de_qualidade_e_se_possível_usuários_finais"></a>Envolvendo pessoas do controle de qualidade e se possível, usuários finais</h3>
<div class="paragraph">
<p>Um aspecto interessante do comando "git bisect" é que ele não é apenas uma ferramenta de desenvolvedor. Ele pode ser usado efetivamente por pessoas do controle de qualidade ou mesmo pelos usuários finais (caso eles tenham acesso ao código-fonte ou se puderem ter acesso a todas as compilações).</p>
</div>
<div class="paragraph">
<p>Houve uma discussão em um ponto na lista de discussão do kernel do linux sobre se era permitido sempre pedir ao usuário final que fizesse um <em>bisect</em>, foram levantados muitos pontos interessantes apoiando este ponto de vista que sim, é permitido.</p>
</div>
<div class="paragraph">
<p>Como por exemplo, David Miller escreveu <a href="#6">[6]</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>O que as pessoas não entendem é que essa é uma situação onde o "princípio do nó final" se aplica. Quando os recursos são limitados (neste caso, os desenvolvedores), você não coloca a maior parte da carga sobre eles. Em vez disso, você envia as coisas para o recurso que você tem em grande quantidade, os nós finais (aqui: usuários), para que a situação realmente seja dimensionada.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Isto significa que geralmente é "mais barato" se as pessoas do controle de qualidade ou dos usuários finais puderem fazer isso.</p>
</div>
<div class="paragraph">
<p>O interessante também é que os usuários finais que estão relatando os bugs (ou das pessoas do controle de qualidade que reproduziram um bug) têm acesso ao ambiente onde o bug ocorre. Portanto, eles geralmente podem reproduzir mais facilmente uma regressão. E se eles puderem fazer um <em>bisect</em>, mais informações serão extraídas do ambiente onde o erro ocorre, o que significa que será mais fácil compreender e então corrigir o bug.</p>
</div>
<div class="paragraph">
<p>Para os projetos de código aberto, pode ser uma boa maneira de obter contribuições mais úteis dos usuários finais e apresentá-las às atividades do controle de qualidade e desenvolvimento.</p>
</div>
</div>
<div class="sect2">
<h3 id="_usando_scripts_complexos"><a class="anchor" href="#_usando_scripts_complexos"></a>Usando scripts complexos</h3>
<div class="paragraph">
<p>Em alguns casos, como no desenvolvimento do kernel, pode valer a pena desenvolver scripts complexos para poder automatizar completamente a bissetriz.</p>
</div>
<div class="paragraph">
<p>Aqui está o que Ingo Molnar diz sobre isso <a href="#7">[7]</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Eu tenho um script para bisseção totalmente automatizado que trava o processo de boot. Tem origem no "git-bisect run". Eu o executo, ele cria e inicializa os kernels automaticamente e quando a inicialização falha (o script percebe que, por meio do registro log serial, que ele assiste continuamente ou por um tempo limite, caso o sistema não apareça em 10 minutos, é um kernel "ruim"), o script chama minha atenção através de um sinal sonoro e eu desligo a caixa de teste. (sim, eu devo usar uma tomada gerenciada para automatizá-la 100%)</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_combinando_os_conjuntos_dos_testes_git_bisect_e_outros_sistemas_juntos"><a class="anchor" href="#_combinando_os_conjuntos_dos_testes_git_bisect_e_outros_sistemas_juntos"></a>Combinando os conjuntos dos testes, git bisect e outros sistemas juntos</h3>
<div class="paragraph">
<p>Vimos que os conjuntos dos testes e o comando <em>git bisect</em> são muito poderosos quando usados juntos. Pode ser ainda mais poderoso caso possa combiná-los com outros sistemas.</p>
</div>
<div class="paragraph">
<p>Como por exemplo, alguns conjuntos de testes podem ser executados automaticamente à noite com algumas configurações incomuns (ou mesmo aleatórias). E caso uma regressão eja encontrada por um conjunto de testes, o comando "git bisect" poderá ser iniciado automaticamente e o seu resultado poderá ser enviado através de um e-mail ao autor do primeiro commit ruim encontrado pelo "git bisect", e talvez das outras pessoas também. E uma nova entrada no sistema de monitoramento dos bugs também pode ser criada de forma automática.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_o_futuro_da_bisseção"><a class="anchor" href="#_o_futuro_da_bisseção"></a>O futuro da bisseção</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_git_replace"><a class="anchor" href="#_git_replace"></a>"git replace"</h3>
<div class="paragraph">
<p>Vimos anteriormente que o comando "git bisect skip" agora está usando um PRNG para tentar evitar as áreas no grafo do commit onde o commit não sejam testáveis. O problema é que, às vezes, o primeiro commit ruim fica em uma área não testável.</p>
</div>
<div class="paragraph">
<p>Para simplificar a discussão, supomos que a área não testável seja uma cadeia simples de commits e que ela foi criada por uma quebra introduzida por um commit (vamos chamá-lo de <em>BBC</em> para o <em>bisect</em> quebrado do commit) e posteriormente corrigida por outro (vamos chamá-lo de <em>BFC</em> para o <em>bisect</em> que vai corrigir o commit).</p>
</div>
<div class="paragraph">
<p>Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z-...</pre>
</div>
</div>
<div class="paragraph">
<p>onde sabemos que <em>Y</em> é bom e <em>BFC</em> é ruim e onde <em>BBC</em> e de <em>X1</em> até <em>X6</em> onde os testes não sejam possíveis.</p>
</div>
<div class="paragraph">
<p>Neste caso, se estiver fazendo o bisecting manualmente, o que você pode fazer é criar uma ramificação especial que comece logo antes da "BBC". O primeiro commit neste ramo deve ser o "BBC" com o "BFC" compactado nele. E os outros commits no ramo devem ser os commits entre "BBC" e "BFC" reconstruídos no primeiro commit do ramo e depois o commit após o BFC também ter sido reconstruído.</p>
</div>
<div class="paragraph">
<p>Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>      (BBC+BFC)-X1'-X2'-X3'-X4'-X5'-X6'-Z'
     /
...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z-...</pre>
</div>
</div>
<div class="paragraph">
<p>onde os commits citados com ' foram reconstruídos na sua base (rebased).</p>
</div>
<div class="paragraph">
<p>Você pode criar facilmente um ramo com o Git usando reconstrução interativa.</p>
</div>
<div class="paragraph">
<p>Utilizando por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git rebase -i Y Z</pre>
</div>
</div>
<div class="paragraph">
<p>e depois mover o <em>BFC</em> após o <em>BBC</em> e esmagá-lo.</p>
</div>
<div class="paragraph">
<p>Depois disso, é possível começar a dividir normalmente no novo ramo e eventualmente, encontrar o primeiro commit com problemas.</p>
</div>
<div class="paragraph">
<p>Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start Z' Y</pre>
</div>
</div>
<div class="paragraph">
<p>Caso esteja utilizando o comando <code>git bisect run</code>, é possível utilizar a mesma correção manual acima e em seguida, iniciar outro comando <code>git bisect run</code> no ramo especial. Ou como diz na página do manual <code>git bisect</code>, o script passado ao <code>git bisect run</code> pode aplicar um patch antes de compilar e testar o software <a href="#8">[8]</a>. O patch deve transformar um commit atual não testável em um testável. Portanto, o teste resultará em "bom" ou "ruim" e o comando <code>git bisect</code> será capaz de encontrar o primeiro commit que estiver ruim. O script não deve se esquecer de remover o patch assim que o teste for concluído antes de encerrar o script.</p>
</div>
<div class="paragraph">
<p>(Observe que, em vez de um patch, é possível utilizar o comando "git cherry-pick BFC" para aplicar a correção e neste caso, utilizar o comando "git reset --hard HEAD^" para reverter a escolha seletiva após o teste e antes de retornar do script.)</p>
</div>
<div class="paragraph">
<p>Porém as maneiras demonstradas acima para solucionar as áreas não testáveis são um pouco atrapalhadas. Utilizar os ramos especiais é bom porque estas ramificações podem ser compartilhadas pelos desenvolvedores como ramos comuns, porém o risco é que as pessoas obtenham muitos ramos. E isso interrompe o fluxo de trabalho normal "git bisect". Portanto, caso queira utilizar o "git bisect run" automaticamente, precisará adicionar um código especial ao seu script para reiniciar a bisseção nos ramos especiais.</p>
</div>
<div class="paragraph">
<p>De qualquer forma, pode-se notar no exemplo do ramo especial acima que os commit Z' e Z devem apontar para a mesma condição do código-fonte (a mesma "árvore" da linguagem git). Isso ocorre porque Z' resulta da aplicação das mesmas alterações que Z em uma ordem ligeiramente diferente.</p>
</div>
<div class="paragraph">
<p>Portanto, se pudéssemos "substituir" <em>Z</em> por <em>Z</em> quando fazemos o <em>bisect</em>, não precisaríamos adicionar nada em um script. Funcionaria apenas para qualquer pessoa no projeto que compartilhasse as ramificações especiais e as substituições.</p>
</div>
<div class="paragraph">
<p>Com o exemplo acima, isso daria:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>      (BBC+BFC)-X1'-X2'-X3'-X4'-X5'-X6'-Z'-...
     /
...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z</pre>
</div>
</div>
<div class="paragraph">
<p>É por isso que o comando "git replace" foi criado. Tecnicamente, ele armazena as substituições das refs na hierarquia "refs/replace/". Estas refs são como ramificações (que são armazenadas em "refs/heads/") ou nas tags (que são armazenadas em "refs/tags"), isso significa que eles podem ser automaticamente compartilhados como ramificações ou tags entre os desenvolvedores.</p>
</div>
<div class="paragraph">
<p>O comando "git replace" é um mecanismo muito poderoso. Pode ser utilizado para corrigir os commits no histórico já lançado, por exemplo, alterar a mensagem do commit ou o autor do mesmo. E também pode ser utilizado em vez dos "enxertos" do git para vincular um repositório a um outro repositório antigo.</p>
</div>
<div class="paragraph">
<p>De fato, é este o último recurso que o "vendeu" para a comunidade Git, agora está no ramo "master" do repositório Git do Git e deve ser lançado no Git 1.6.5 em outubro ou novembro de 2009.</p>
</div>
<div class="paragraph">
<p>Um problema com o comando "git replace" é que ele atualmente armazena todas as substituições refs no "refs/replace/", mas talvez seja melhor caso as substituições das refs de que são úteis apenas para a bisseção estivessem no "refs/replace/bisect/". Dessa maneira, a reposição das refs poderiam ser usados apenas para fazer a bisseção, enquanto as outras refs diretamente em "refs/replace/" seriam utilizadas quase que o tempo todo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_erros_esporádicos_da_bisseção"><a class="anchor" href="#_erros_esporádicos_da_bisseção"></a>Erros esporádicos da bisseção</h3>
<div class="paragraph">
<p>Outra possível melhoria do "git bisect" seria adicionar opcionalmente alguma redundância aos testes que forem realizados, para que fosse mais confiável durante o rastreio de erros esporádicos.</p>
</div>
<div class="paragraph">
<p>Isso foi solicitado por alguns desenvolvedores do kernel porque alguns erros chamados esporádicos não aparecem em todas as compilações porque são muito dependentes do que é gerado pelo compilador.</p>
</div>
<div class="paragraph">
<p>A ideia é que a cada três testes por exemplo, o comando "git bisect" possa solicitar ao usuário que teste um commit que já foi considerado "bom" ou "ruim" (porque um de seus descendentes ou um dos seus ancestrais tenha sido encontrado como sendo "bom" ou "ruim", respectivamente). Caso um commit tenha sido previamente classificado incorretamente, a bisseção poderá ser interrompida mais cedo, antes que muitos erros possam ser cometidos. Em seguida, o usuário terá que verificar o que aconteceu e reiniciar a bisseção usando um registro log fixo do <em>bisect</em>.</p>
</div>
<div class="paragraph">
<p>Já existe um projeto chamado <em>BBChop</em> criado por Ealdwulf Wuffinga no Github que faz algo assim usando a Teoria Bayesiana de Pesquisa <a href="#9">[9]</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>O BBChop é como o comando <em>git bisect</em> (ou equivalente), mas funciona quando o seu bug for intermitente. Ou seja, funciona na presença dos falsos negativos (quando uma versão funcione embora contenha o erro). Assume que não há falsos positivos (em princípio, a mesma abordagem funcionaria, porém adicioná-la pode não ser trivial).</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Porém o <em>BBChop</em> é independente de qualquer VCS e seria mais fácil para os usuários do Git ter algo integrado no Git.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusão"><a class="anchor" href="#_conclusão"></a>Conclusão</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vimos que as regressões são um problema importante e que o comando "git bisect" possui recursos interessantes que complementam as boas práticas e outras ferramentas, especialmente os conjuntos de testes, que geralmente são usados para combater as regressões. Mas pode ser necessário alterar alguns fluxos de trabalho e hábitos (ruins) para tirar o máximo proveito disso.</p>
</div>
<div class="paragraph">
<p>Algumas melhorias nos algoritmos dentro do comando "git bisect" são possíveis e alguns novos recursos podem ajudar em alguns casos, porém o comando "git bisect" em geral já funciona muito bem, é muito usado e já é muito útil. Para apoiar essa última afirmação, vamos dar a palavra final ao Ingo Molnar, quando o autor lhe perguntou quanto tempo ele acha que o comando "git bisect" o salva quando ele o utiliza:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><em>muito</em>.</p>
</div>
<div class="paragraph">
<p>Cerca de dez anos atrás, eu fiz minha primeira "bisseção" de uma fila de patches do Linux. Isso foi antes dos dias do Git (e mesmo antes do "BitKeeper"). Eu literalmente passei os dias resolvendo os patches, criando o que em essência eram compromissos independentes que eu acho que estavam relacionados com este bug.</p>
</div>
<div class="paragraph">
<p>Foi uma ferramenta de último recurso absoluta. Prefiro passar dias olhando a saída do <em>printk</em> do que fazer uma <em>bisseção dos patches</em> manualmente.</p>
</div>
<div class="paragraph">
<p>Com o Git bisect, é fácil: no melhor dos casos, é possível obter uma bisseção do kernel com ~15 passos entre 20 a 30 minutos de maneira automatizada. Mesmo com ajuda manual ou ao dividir vários bugs acumulados, raramente leva mais de uma hora.</p>
</div>
<div class="paragraph">
<p>Na verdade, é inestimável porque existem bugs que eu nem tentaria depurar caso não fosse pelo comando <code>git bisect</code>. No passado, havia padrões de bug que eram imediatamente inúteis para se depurar - na melhor das hipóteses eu poderia enviar a assinatura da falha/bug para o <em>lkml</em> e esperar que alguém pudesse pensar em algo.</p>
</div>
<div class="paragraph">
<p>E ainda que uma bisseção falhe, hoje ela nos diz algo valioso sobre o bug: que é não determinístico - depende do tempo ou do layout da imagem do kernel.</p>
</div>
<div class="paragraph">
<p>Portanto, o comando <em>git bisect</em> é uma bondade incondicional e fique à vontade para citar isso ;-)</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_agradecimentos"><a class="anchor" href="#_agradecimentos"></a>Agradecimentos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Meus agradecimentos ao Junio Hamano por sua ajuda na revisão deste documento, por revisar os patches que enviei para a lista de discussão do Git, por discutir algumas ideias e por me ajudar a melhorá-las, por melhorar muito o "git bisect" e por seu incrível trabalho em manter e desenvolvendo o Git.</p>
</div>
<div class="paragraph">
<p>Meus agradecimentos ao Ingo Molnar por me fornecer informações muito úteis que aparecem neste artigo, por comentar este artigo, pelas suas sugestões para melhorar o "git bisect" e por evangelizar o "git bisect" nas listas de discussão do kernel do linux.</p>
</div>
<div class="paragraph">
<p>Meus agradecimentos ao Linus Torvalds por inventar, desenvolver e evangelizar "git bisect", Git e o Linux.</p>
</div>
<div class="paragraph">
<p>Meus agradecimentos a muitas outras ótimas pessoas que ajudaram de um jeito ou de outro quando eu trabalhei no Git, especialmente ao Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, Sam Vilain, Jon Seymour.</p>
</div>
<div class="paragraph">
<p>Meus agradecimentos ao comitê do programa Linux-Kongress por escolher o autor para dar uma palestra e por publicar este artigo.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_referências"><a class="anchor" href="#_referências"></a>Referências</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>[[[1]]] <a href="https://web.archive.org/web/20091206032101/http://www.nist.gov/public_affairs/releases/n02-10.htm"><em>Custo dos erros de software nos EUA</em>. Economia de US$ 59,5 bilhões por ano'. Comunicado à imprensa do Nist</a>. Consulte também <a href="https://www.nist.gov/system/files/documents/director/planning/report02-3.pdf"><em>The Economic Impacts of Inadequate Infratructure for Software Testing</em>. Relatório de Planejamento Nist 02-3</a>, Resumo Executivo e Capítulo 8.</p>
</li>
<li>
<p>[[[2]]] <a href="https://www.oracle.com/java/technologies/javase/codeconventions-introduction.html"><em>Code Conventions for the Java Programming Language: 1. Introduction</em>. Sun Microsystems.</a></p>
</li>
<li>
<p>[[[3]]] <a href="https://en.wikipedia.org/wiki/Software_maintenance"><em>Manutenção do Software</em>. Wikipedia.</a></p>
</li>
<li>
<p>[[[4]]] <a href="https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/">Junio C Hamano. <em>A História de sucesso de um bisect automatizado</em>.</a></p>
</li>
<li>
<p>[[[5]]] <a href="https://lwn.net/Articles/317154/">Christian Couder. <em>Um bisect totalmente automatizado com "git bisect run"</em>. LWN.net.</a></p>
</li>
<li>
<p>[[[6]]] <a href="https://lwn.net/Articles/277872/">Jonathan Corbet. <em>A bisseção divide usuários e os desenvolvedores</em>. LWN.net.</a></p>
</li>
<li>
<p>[[[7]]] <a href="https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/">Ingo Molnar. <em>Re: BUG 2.6.23-rc3 can&#8217;t see sd partitions on Alpha</em>. Linux-kernel mailing list.</a></p>
</li>
<li>
<p>[[[8]]] <a href="https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html">Junio C Hamano and the git-list. <em>git-bisect(1) Página do Manual</em>. Arquivos do Linux Kernel.</a></p>
</li>
<li>
<p>[[[9]]] <a href="https://github.com/Ealdwulf/bbchop">Ealdwulf. <em>bbchop</em>. GitHub.</a></p>
</li>
</ul>
</div>
</div>
</div>