---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-shortlog Documentation
docname: git-shortlog
lang: zh_HANS-CN
aliases:
- "/docs/git-shortlog/zh_HANS-CN/index.html"
---
<div class="sect1">
<h2 id="_名称"><a class="anchor" href="#_名称"></a>名称</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-shortlog - 汇总 <em>git log</em> 输出</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_概述"><a class="anchor" href="#_概述"></a>概述</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git shortlog</em> [&lt;选项&gt;] [&lt;修订范围&gt;] [[--] &lt;路径&gt;&#8230;&#8203;] 。
git log --pretty=short | <em>git shortlog</em> [&lt;多个选项&gt;] 。</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_描述"><a class="anchor" href="#_描述"></a>描述</h2>
<div class="sectionbody">
<div class="paragraph">
<p>将&#8217;git log&#8217;输出总结为适合纳入发布公告的格式。每个提交将按作者和标题分组。</p>
</div>
<div class="paragraph">
<p>此外，"[PATCH]"将从提交描述中被剥离。</p>
</div>
<div class="paragraph">
<p>如果命令行上没有传递修订版，而且标准输入不是终端，或者没有当前分支，'git shortlog&#8217;将输出从标准输入读取的日志摘要，而不参考当前版本库。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_选项"><a class="anchor" href="#_选项"></a>选项</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-shortlog--n"> <a class="anchor" href="#git-shortlog--n"></a>-n </dt>
<dt class="hdlist1" id="git-shortlog---numbered"> <a class="anchor" href="#git-shortlog---numbered"></a>--numbered </dt>
<dd>
<p>根据每个作者的提交数量对输出进行排序，而不是按照作者的字母顺序。</p>
</dd>
<dt class="hdlist1" id="git-shortlog--s"> <a class="anchor" href="#git-shortlog--s"></a>-s </dt>
<dt class="hdlist1" id="git-shortlog---summary"> <a class="anchor" href="#git-shortlog---summary"></a>--summary </dt>
<dd>
<p>抑制提交描述，只提供提交计数摘要。</p>
</dd>
<dt class="hdlist1" id="git-shortlog--e"> <a class="anchor" href="#git-shortlog--e"></a>-e </dt>
<dt class="hdlist1" id="git-shortlog---email"> <a class="anchor" href="#git-shortlog---email"></a>--email </dt>
<dd>
<p>显示每个作者的电子邮件地址。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---formatltgt"> <a class="anchor" href="#git-shortlog---formatltgt"></a>--format[=&lt;格式&gt;] </dt>
<dd>
<p>代替提交主题，使用一些其他信息来描述每个提交。 <em>&lt;格式&gt;</em> 可以是任何被 <em>git log</em> 的 <code>--format</code> 选项接受的字符串，比如 <em>* [%h] %s</em>。 参见 <a href='{{< relurl "docs/git-log/zh_HANS-CN" >}}'>git-log[1]</a> 的 “漂亮的格式” 部分。）</p>
<div class="literalblock">
<div class="content">
<pre>每个漂亮的印刷品承诺在展示之前都会被重新包装。</pre>
</div>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog---dateltgt"> <a class="anchor" href="#git-shortlog---dateltgt"></a>--date=&lt;格式&gt; </dt>
<dd>
<p>显示根据给定日期字符串格式化的日期。(参见<a href='{{< relurl "docs/git-log/zh_HANS-CN" >}}'>git-log[1]</a>中 "提交格式化"部分的`--date`选项）。与 `--group=format:&lt;format&gt;`一起使用会非常有用。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---groupltgt"> <a class="anchor" href="#git-shortlog---groupltgt"></a>--group=&lt;类型&gt; </dt>
<dd>
<p>根据 <code>&lt;类型&gt;`对提交进行分组。如果没有指定 `--group</code> 选项，默认为 <code>作者</code> 。<code>&lt;类型&gt;</code> 是以下之一：</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>"作者"，提交内容按作者分组</p>
</li>
<li>
<p><code>提交者</code> ，提交内容按提交人分组（与 <code>-c</code> 相同）</p>
</li>
<li>
<p><code>trailer:&lt;field&gt;</code>，<code>&lt;field&gt;`被解释为不区分大小写的提交消息预告片（见 <a href='{{< relurl "docs/git-interpret-trailers/zh_HANS-CN" >}}'>git-interpret-trailers[1]</a>）。例如，如果你的项目使用 `Reviewed-by</code> 拖车，你可能想用 <code>git shortlog -ns --group=trailer:reviewed-by</code> 来查看谁在审核。</p>
</li>
<li>
<p><code>格式：&lt;format&gt;</code> 可以是任何被 <em>git log</em> 的 <code>--format</code> 选项接受的字符串。（参见 <a href='{{< relurl "docs/git-log/zh_HANS-CN" >}}'>git-log[1]</a> 的 "PRETTY FORMATS" 部分）。</p>
<div class="paragraph">
<p>请注意，不包括拖车的提交将不被计算在内。 同样地，有多个拖车的提交（例如多个签收）可以被计算一次（但该提交中每个独特的拖车值只能计算一次）。</p>
</div>
<div class="paragraph">
<p>Shortlog将尝试把每个拖车值解析为`name &lt;email&gt;<code>的身份。如果成功，将应用mailmap，除非指定</code>--email`选项，否则将省略email。如果该值不能被解析为一个身份，那么它将被完全视为字面意思。</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>如果 <code>--group</code> 被多次指定，每个值下的提交都会被计算（但同样，每个提交中的唯一值只能计算一次）。例如，<code>git shortlog --group=author --group=trailer:co-authored-by</code> 同时计算作者和共同作者。</p>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog--c"> <a class="anchor" href="#git-shortlog--c"></a>-c </dt>
<dt class="hdlist1" id="git-shortlog---committer"> <a class="anchor" href="#git-shortlog---committer"></a>--committer </dt>
<dd>
<p>这是`--group=committer`的一个别名。</p>
</dd>
<dt class="hdlist1" id="git-shortlog--wltwidthgtltindent1gtltindent2gt"> <a class="anchor" href="#git-shortlog--wltwidthgtltindent1gtltindent2gt"></a>-w[&lt;width&gt;[,&lt;indent1&gt;[,&lt;indent2&gt;]]] </dt>
<dd>
<p>通过以`width`包裹每一行来对输出进行换行。 每个条目的第一行缩进`缩进1`个空格，第二行和后续行缩进`缩进2`个空格。<code>width</code>, <code>indent1</code>, 和`indent2`分别默认为76, 6和9。</p>
<div class="paragraph">
<p>如果宽度为`0`（零），则缩进输出的行数而不包裹它们。</p>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog-ltrevision-rangegt"> <a class="anchor" href="#git-shortlog-ltrevision-rangegt"></a>&lt;revision-range&gt; </dt>
<dd>
<p>只显示指定修订范围内的提交。 当没有指定 &lt;修订范围&gt; 时，默认为 <code>HEAD</code> （即导致当前提交的整个历史）。 <code>origin...HEAD</code> 指定了从当前提交（即`HEAD` ）可以到达的所有提交，但不是从 `origin `。关于 &lt;修订范围&gt; 的完整拼写方式，见 <a href='{{< relurl "docs/gitrevisions/zh_HANS-CN" >}}'>gitrevisions[7]</a> 的 “指定范围” 部分。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---ltpathgt82308203"> <a class="anchor" href="#git-shortlog---ltpathgt82308203"></a>[--] &lt;path&gt;&#8230;&#8203; </dt>
<dd>
<p>只考虑那些足以解释符合指定路径的文件是如何产生的提交。</p>
<div class="paragraph">
<p>当出现混淆时，路径可能需要以`--`为前缀，以便将其与选项或修订范围分开。</p>
</div>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_承诺限制"><a class="anchor" href="#_承诺限制"></a>承诺限制</h3>
<div class="paragraph">
<p>除了使用描述中解释的特殊符号指定应列出的提交范围，还可以应用额外的提交限制。</p>
</div>
<div class="paragraph">
<p>使用更多的选项通常会进一步限制输出（例如，<code>--since=&lt;date1&gt;`限制在比</code>&lt;date1&gt;<code>新的提交，与</code>--grep=&lt;pattern&gt;<code>一起使用会进一步限制在日志信息中有一行符合</code>&lt;pattern&gt;`的提交），除非另有说明。</p>
</div>
<div class="paragraph">
<p>请注意，这些都是在提交排序和格式化选项之前应用的，如 <code>--reverse</code>。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-shortlog--ltgt"> <a class="anchor" href="#git-shortlog--ltgt"></a>-&lt;数&gt; </dt>
<dt class="hdlist1" id="git-shortlog--nltgt"> <a class="anchor" href="#git-shortlog--nltgt"></a>-n &lt;数量&gt; </dt>
<dt class="hdlist1" id="git-shortlog---max-countltgt"> <a class="anchor" href="#git-shortlog---max-countltgt"></a>--max-count=&lt;数量&gt; </dt>
<dd>
<p>限制输出的提交数量。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---skipltgt"> <a class="anchor" href="#git-shortlog---skipltgt"></a>--skip=&lt;数量&gt; </dt>
<dd>
<p>在开始显示提交输出之前，跳过&#8217;数&#8217;的提交。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---sinceltgt"> <a class="anchor" href="#git-shortlog---sinceltgt"></a>--since=&lt;日期&gt; </dt>
<dt class="hdlist1" id="git-shortlog---afterltgt"> <a class="anchor" href="#git-shortlog---afterltgt"></a>--after=&lt;日期&gt; </dt>
<dd>
<p>显示比某一特定日期更近的提交。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---since-as-filterltgt"> <a class="anchor" href="#git-shortlog---since-as-filterltgt"></a>--since-as-filter=&lt;日期&gt; </dt>
<dd>
<p>显示所有比指定日期更近的提交。这将访问该范围内的所有提交，而不是停在第一个比指定日期更早的提交。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---untilltgt"> <a class="anchor" href="#git-shortlog---untilltgt"></a>--until=&lt;日期&gt; </dt>
<dt class="hdlist1" id="git-shortlog---beforeltgt"> <a class="anchor" href="#git-shortlog---beforeltgt"></a>--before=&lt;日期&gt; </dt>
<dd>
<p>显示超过特定日期的提交。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---authorltgt"> <a class="anchor" href="#git-shortlog---authorltgt"></a>--author=&lt;模式&gt; </dt>
<dt class="hdlist1" id="git-shortlog---committerltgt"> <a class="anchor" href="#git-shortlog---committerltgt"></a>--committer=&lt;模式&gt; </dt>
<dd>
<p>将提交文件的输出限制在作者/提交人标题行符合指定模式（正则表达式）的文件。 如果有多个`--author=&lt;pattern&gt;<code>，则会选择作者符合任何一个给定模式的提交（对于多个</code>--committer=&lt;pattern&gt;`也是如此）。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---grep-reflogltgt"> <a class="anchor" href="#git-shortlog---grep-reflogltgt"></a>--grep-reflog=&lt;模式&gt; </dt>
<dd>
<p>将提交文件的输出限制在有符合指定模式（正则表达式）的reflog条目的提交文件。如果有多个 <code>--grep-reflog</code>，则会选择那些 reflog 信息符合任何指定模式的提交。 除非使用了`--walk-reflogs`，否则使用此选项是错误的。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---grepltgt"> <a class="anchor" href="#git-shortlog---grepltgt"></a>--grep=&lt;模式&gt; </dt>
<dd>
<p>将提交结果限制在日志信息与指定模式（正则表达式）相匹配的提交。 如果有多个 <code>--grep=&lt;模式&gt;</code>，则会选择那些日志信息与任何指定模式相匹配的提交（但见 <code>--all-match</code>）。</p>
<div class="paragraph">
<p>当 <code>--notes</code> 生效时，笔记中的信息被匹配，就像它是日志信息的一部分。</p>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog---all-match"> <a class="anchor" href="#git-shortlog---all-match"></a>--all-match </dt>
<dd>
<p>将输出的提交限制在符合所有给定`--grep`的提交，而不是至少符合一个的提交。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---invert-grep"> <a class="anchor" href="#git-shortlog---invert-grep"></a>--invert-grep </dt>
<dd>
<p>限定输出的提交信息与 `--grep=&lt;模式&gt;`指定的模式不匹配。</p>
</dd>
<dt class="hdlist1" id="git-shortlog--i"> <a class="anchor" href="#git-shortlog--i"></a>-i </dt>
<dt class="hdlist1" id="git-shortlog---regexp-ignore-case"> <a class="anchor" href="#git-shortlog---regexp-ignore-case"></a>--regexp-ignore-case </dt>
<dd>
<p>匹配正则表达式的限制模式，不考虑字母大小写。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---basic-regexp"> <a class="anchor" href="#git-shortlog---basic-regexp"></a>--basic-regexp </dt>
<dd>
<p>将限制性模式视为基本的正则表达式；这是默认的。</p>
</dd>
<dt class="hdlist1" id="git-shortlog--E"> <a class="anchor" href="#git-shortlog--E"></a>-E </dt>
<dt class="hdlist1" id="git-shortlog---extended-regexp"> <a class="anchor" href="#git-shortlog---extended-regexp"></a>--extended-regexp </dt>
<dd>
<p>将限制性模式视为扩展的正则表达式，而不是默认的基本正则表达式。</p>
</dd>
<dt class="hdlist1" id="git-shortlog--F"> <a class="anchor" href="#git-shortlog--F"></a>-F </dt>
<dt class="hdlist1" id="git-shortlog---fixed-strings"> <a class="anchor" href="#git-shortlog---fixed-strings"></a>--fixed-strings </dt>
<dd>
<p>将限制性模式视为固定字符串（不要将模式解释为正则表达式）。</p>
</dd>
<dt class="hdlist1" id="git-shortlog--P"> <a class="anchor" href="#git-shortlog--P"></a>-P </dt>
<dt class="hdlist1" id="git-shortlog---perl-regexp"> <a class="anchor" href="#git-shortlog---perl-regexp"></a>--perl-regexp </dt>
<dd>
<p>将限制性模式视为与Perl兼容的正则表达式。</p>
<div class="paragraph">
<p>对这些类型的正则表达式的支持是一个可选的编译时依赖。如果Git在编译时没有对它们的支持，提供这个选项将导致它死亡。</p>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog---remove-empty"> <a class="anchor" href="#git-shortlog---remove-empty"></a>--remove-empty </dt>
<dd>
<p>当一个给定的路径从树上消失时停止。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---merges"> <a class="anchor" href="#git-shortlog---merges"></a>--merges </dt>
<dd>
<p>只打印合并后的提交。这与`--min-parents=2`完全相同。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---no-merges"> <a class="anchor" href="#git-shortlog---no-merges"></a>--no-merges </dt>
<dd>
<p>不打印有一个以上父级的提交。这与`--max-parents=1`完全相同。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---min-parentsltgt"> <a class="anchor" href="#git-shortlog---min-parentsltgt"></a>--min-parents=&lt;数量&gt; </dt>
<dt class="hdlist1" id="git-shortlog---max-parentsltgt"> <a class="anchor" href="#git-shortlog---max-parentsltgt"></a>--max-parents=&lt;数量&gt; </dt>
<dt class="hdlist1" id="git-shortlog---no-min-parents"> <a class="anchor" href="#git-shortlog---no-min-parents"></a>--no-min-parents </dt>
<dt class="hdlist1" id="git-shortlog---no-max-parents"> <a class="anchor" href="#git-shortlog---no-max-parents"></a>--no-max-parents </dt>
<dd>
<p>只显示至少（或最多）有那么多父提交的提交。特别是，<code>--max-parents=1`等同于</code>--no-merges`，<code>--min-parents=2`等同于</code>--merges`。 <code>--max-parents=0`给出所有根提交，</code>--min-parents=3`给出所有章鱼合并。</p>
<div class="paragraph">
<p><code>--no-min-parents</code> 和 <code>--no-max-parents</code> 会再次重置这些限制（为无限制）。 等价形式是 <code>--min-parents=0</code>（任何提交都有 0 个或更多父代）和 <code>--max-parents=-1</code>（负数表示无上限）。</p>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog---first-parent"> <a class="anchor" href="#git-shortlog---first-parent"></a>--first-parent </dt>
<dd>
<p>查找要包含的提交时，在看到合并提交时只跟随第一个父提交。 在查看某个特性分支的演变时，该选项可以提供更好的概览，因为合并到特性分支往往只是为了不时地适应上游的更新，而该选项可以让你忽略由合并带来的历史中的单个提交。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---exclude-first-parent-only"> <a class="anchor" href="#git-shortlog---exclude-first-parent-only"></a>--exclude-first-parent-only </dt>
<dd>
<p>在寻找要排除的提交（用'^'）时，在看到合并提交时只跟随第一个父提交。 考虑到任意的合并都可以成为有效的主题分支变化，这可以用来查找主题分支中从它与远程分支的分歧点开始的变化集合。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---not"> <a class="anchor" href="#git-shortlog---not"></a>--not </dt>
<dd>
<p>反转 <em>^</em> 前缀（或无前缀）对后面所有版本说明符的意义，直到下一个 <code>--not</code>。 在 --stdin 之前的命令行中使用时，通过标准输入流传递的修订版本不会受其影响。反之，通过标准输入传递时，命令行上传递的修订版本也不会受其影响。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---all"> <a class="anchor" href="#git-shortlog---all"></a>--all </dt>
<dd>
<p>假设`refs/&#8216;中的所有参考文献，连同`HEAD`一起，在命令行中被列为&#8217;&lt;commit&gt;'。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---branchesltgt"> <a class="anchor" href="#git-shortlog---branchesltgt"></a>--branches[=&lt;模式&gt;] </dt>
<dd>
<p>假设`refs/heads`中的所有 refs 在命令行中被列为 <em>&lt;commit&gt;</em>。如果给出了'&lt;pattern&gt;'，将分支限制在与给定的shell glob相匹配的分支。如果pattern缺少'?<em>、</em>*'或'[<em>，则末尾的</em>/*'是暗示的。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---tagsltgt"> <a class="anchor" href="#git-shortlog---tagsltgt"></a>--tags[=&lt;模式&gt;] </dt>
<dd>
<p>假设`refs/tags`中的所有参考文献在命令行中被列为'&lt;commit&gt;'。如果给出了'&lt;pattern&gt;'，将标签限制在与给定的shell glob相匹配的标签。如果pattern缺少'?<em>、</em>*'或'[<em>，则暗示最后的</em>/*'。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---remotesltgt"> <a class="anchor" href="#git-shortlog---remotesltgt"></a>--remotes[=&lt;模式&gt;] </dt>
<dd>
<p>假设`refs/remotes`中的所有 refs 在命令行中被列为 <em>&lt;commit&gt;</em>。如果给出了'&lt;pattern&gt;'，将远程跟踪分支限制在与给定的shell glob相匹配的分支。 如果pattern缺少'?<em>、</em>*'或'[<em>，则末尾的</em>/*'是暗示的。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---globltgt"> <a class="anchor" href="#git-shortlog---globltgt"></a>--glob=&lt;通配符模式&gt; </dt>
<dd>
<p>假设所有与shell glob <em>&lt;glob-pattern&gt;相匹配的refs在命令行中被列为</em>&lt;commit&gt;'。前面的&#8217;refs/<em>，如果缺少的话会自动预加。如果模式中缺少</em>?<em>、</em>*'或'[<em>，则在结尾处隐含</em>/*'。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---excludeltgt"> <a class="anchor" href="#git-shortlog---excludeltgt"></a>--exclude=&lt;通配符模式&gt; </dt>
<dd>
<p>不包括匹配"&lt;glob-pattern&gt;"的参考文献，否则下一个`--all`、<code>--branches</code>、<code>--tags</code>、<code>--remotes`或</code>--glob`会考虑这些参考文献。重复这个选项可以累积排除模式，直到下一个`----all`、<code>---branches</code>、<code>---tags</code>、<code>---remotes`或</code>---glob`选项（其他选项或参数不清除累积模式）。</p>
<div class="paragraph">
<p>当应用于 <code>--branches</code>、 <code>--tags</code> 或 <code>--remotes</code> 时，所给出的模式不应以 <code>refs/heads</code>、<code>refs/tags</code> 或 <code>refs/remotes</code> 开头；当应用于 <code>--glob</code> 或 <code>--all</code> 选项时，必须以 <code>refs/</code> 开头。如果要使用尾部的 <em>/*</em>，则必须明确给出。</p>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog---exclude-hiddenfetchreceiveuploadpack"> <a class="anchor" href="#git-shortlog---exclude-hiddenfetchreceiveuploadpack"></a>--exclude-hidden=[fetch|receive|uploadpack] </dt>
<dd>
<p>通过查阅相应的 <code>fetch.hideRefs</code> 、<code>receive.hideRefs</code> 或 <code>uploadpack.hideRefs</code> 配置和 <code>transfer.hideRefs</code> 配置（参见 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>），不要包含会被 <code>git-fetch</code> 、<code>git-receive-pack</code> 或 <code>git-upload-pack</code> 隐藏的引用。该选项会影响下一个伪引用选项 <code>--all</code> 或 <code>--glob</code>，并在处理后清除。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---reflog"> <a class="anchor" href="#git-shortlog---reflog"></a>--reflog </dt>
<dd>
<p>假设reflogs提到的所有对象都在命令行中被列为`&lt;commit&gt;`。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---alternate-refs"> <a class="anchor" href="#git-shortlog---alternate-refs"></a>--alternate-refs </dt>
<dd>
<p>假设所有提到的作为备用仓库的参考提示的对象都列在命令行上。备用资源库是任何资源库，其对象目录在`objects/info/alternates`中指定。 包含的对象集可以通过`core.alternateRefsCommand`等修改。见<a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---single-worktree"> <a class="anchor" href="#git-shortlog---single-worktree"></a>--single-worktree </dt>
<dd>
<p>默认情况下，当有多个工作树时，所有工作树都会被以下选项检查（见<a href='{{< relurl "docs/git-worktree/zh_HANS-CN" >}}'>git-worktree[1]</a>）：<code>--all</code>，<code>--reflog`和</code>--indexed-objects`。 这个选项强制它们只检查当前的工作树。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---ignore-missing"> <a class="anchor" href="#git-shortlog---ignore-missing"></a>--ignore-missing </dt>
<dd>
<p>在看到输入中无效的对象名称时，假装没有给出坏的输入。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---bisect"> <a class="anchor" href="#git-shortlog---bisect"></a>--bisect </dt>
<dd>
<p>假设坏的二分法参考文献`refs/bisect/bad`被列出，并且在命令行中假设它后面是`--not`和好的二分法参考文献`refs/bisect/good-*`。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---stdin"> <a class="anchor" href="#git-shortlog---stdin"></a>--stdin </dt>
<dd>
<p>除从命令行获取参数外，还可从标准输入读取参数。它接受提交和伪选项，如 <code>--all</code> 和 <code>--glob=</code>。当看到 <code>--</code> 分隔符时，下面的输入将被视为路径并用于限制结果。通过标准输入读取的 <code>--not</code> 等标志只适用于以相同方式传递的参数，不会影响后续的命令行参数。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---cherry-mark"> <a class="anchor" href="#git-shortlog---cherry-mark"></a>--cherry-mark </dt>
<dd>
<p>就像`--cherry-pick`（见下文），但用`=<code>标记同等的提交，而不是省略，用</code>+`标记不同等的提交。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---cherry-pick"> <a class="anchor" href="#git-shortlog---cherry-pick"></a>--cherry-pick </dt>
<dd>
<p>当提交的集合有对称差异时，省略任何与 "另一边 "的另一个提交相同的提交。</p>
<div class="paragraph">
<p>例如，如果你有两个分支，<code>A</code> 和 <code>B</code>，通常的方法是用`--左&#8212;&#8203;右`列出其中一边的所有提交（见下面关于`--left-right`选项的描述）。然而，它显示的是从另一个分支中偷梁换柱的提交（例如，<em>'3rd on b</em>' 可能是从分支 A 中偷梁换柱的）。有了这个选项，这样的提交对将从输出中排除。</p>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog---left-only"> <a class="anchor" href="#git-shortlog---left-only"></a>--left-only </dt>
<dt class="hdlist1" id="git-shortlog---right-only"> <a class="anchor" href="#git-shortlog---right-only"></a>--right-only </dt>
<dd>
<p>只列出对称性差异各自一侧的提交，即只列出那些通过 <code>--left-right</code> 标记的 <code>&lt;</code> 或 <code>&gt;</code>。</p>
<div class="paragraph">
<p>例如，<code>--cherry-pick --right-only A...B`省略了`B`中那些在`A`中的提交或与`A`中的提交相等的补丁。换句话说，它列出了 "git cherry A B "的 "+"的提交。 更准确地说，</code>--cherry-pick --right-only --no-merges`可以得到准确的列表。</p>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog---cherry"> <a class="anchor" href="#git-shortlog---cherry"></a>--cherry </dt>
<dd>
<p><code>--right-only --cherry-mark --no-merges`的同义词；有助于将输出限制在我们这边的提交，并标记那些已经应用到分叉历史的另一边的提交，`git log --cherry upstream...mybranch</code>，类似于`git cherry upstream mybranch`。</p>
</dd>
<dt class="hdlist1" id="git-shortlog--g"> <a class="anchor" href="#git-shortlog--g"></a>-g </dt>
<dt class="hdlist1" id="git-shortlog---walk-reflogs"> <a class="anchor" href="#git-shortlog---walk-reflogs"></a>--walk-reflogs </dt>
<dd>
<p>不走提交祖先链，而走从最近的提交到更早的提交的reflog条目。 使用这个选项时，你不能指定要排除的提交（也就是说，不能使用'^commit'、'commit1&#8230;&#8203;commit2&#8217;和&#8217;commit1/&#8230;&#8203;commit2&#8217;的符号）。</p>
<div class="paragraph">
<p>With <code>--pretty</code> format other than <code>oneline</code> and <code>reference</code> (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as <code>ref@{&lt;Nth&gt;}</code> (where <em>&lt;Nth&gt;</em> is the reverse-chronological index in the reflog) or as <code>ref@{&lt;timestamp&gt;}</code> (with the <em>&lt;timestamp&gt;</em> for that entry), depending on a few rules:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If the starting point is specified as <code>ref@{&lt;Nth&gt;}</code>, show the index format.</p>
</li>
<li>
<p>如果起点被指定为`ref@{now}`，显示时间戳格式。</p>
</li>
<li>
<p>如果两者都没有使用，但在命令行中给出了`--date`，则按照`--date`所要求的格式显示时间戳。</p>
</li>
<li>
<p>否则，显示索引格式。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>在`--pretty=oneline`下，提交信息的前缀是同一行中的这些信息。 这个选项不能与 `--reverse`结合使用。 参见 <a href='{{< relurl "docs/git-reflog/zh_HANS-CN" >}}'>git-reflog[1]</a>。</p>
</div>
<div class="paragraph">
<p>在`--pretty=reference`下，这些信息将完全不显示。</p>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog---merge"> <a class="anchor" href="#git-shortlog---merge"></a>--merge </dt>
<dd>
<p>显示在范围 <code>HEAD...&lt;其他&gt;</code> 中触及冲突路径的提交，其中 <code>&lt;其他&gt;</code> 是 <code>MERGE_HEAD</code>、<code>CHERRY_PICK_HEAD</code>、<code>REVERT_HEAD</code> 或 <code>REBASE_HEAD</code> 中第一个存在的伪引用。仅在索引中有未合并条目时有效。这个选项可以在解决三向合并中的冲突时用来显示相关的提交。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---boundary"> <a class="anchor" href="#git-shortlog---boundary"></a>--boundary </dt>
<dd>
<p>输出排除的边界提交。边界提交的前缀是"-"。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_简化历史"><a class="anchor" href="#_简化历史"></a>简化历史</h3>
<div class="paragraph">
<p>有时你只对历史的一部分感兴趣，例如修改某个&lt;路径&gt;的提交。但 "历史简化 "有两部分，一部分是选择提交，另一部分是如何做，因为有各种策略来简化历史。</p>
</div>
<div class="paragraph">
<p>以下选项选择要显示的提交：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-shortlog-ltpathsgt"> <a class="anchor" href="#git-shortlog-ltpathsgt"></a>&lt;paths&gt; </dt>
<dd>
<p>修改给定&lt;路径&gt;的提交会被选中。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---simplify-by-decoration"> <a class="anchor" href="#git-shortlog---simplify-by-decoration"></a>--simplify-by-decoration </dt>
<dd>
<p>被某个分支或标签引用的提交被选中。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>请注意，可以显示额外的提交，以提供一个有意义的历史。</p>
</div>
<div class="paragraph">
<p>以下选项会影响简化的执行方式：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-shortlog-"> <a class="anchor" href="#git-shortlog-"></a>默认模式 </dt>
<dd>
<p>将历史简化为解释树的最终状态的最简单的历史。最简单的原因是，如果最终结果相同，它会修剪一些侧枝（即合并具有相同内容的分支）</p>
</dd>
<dt class="hdlist1" id="git-shortlog---show-pulls"> <a class="anchor" href="#git-shortlog---show-pulls"></a>--show-pulls </dt>
<dd>
<p>包括默认模式下的所有提交，但也包括任何与第一个父分支不相干但与后来的父分支相干的合并提交。这种模式有助于显示 "首次引入 "某个分支的合并提交。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---full-history"> <a class="anchor" href="#git-shortlog---full-history"></a>--full-history </dt>
<dd>
<p>与默认模式相同，但不修剪一些历史记录。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---dense"> <a class="anchor" href="#git-shortlog---dense"></a>--dense </dt>
<dd>
<p>只显示所选的提交，再加上一些才有意义的历史。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---sparse"> <a class="anchor" href="#git-shortlog---sparse"></a>--sparse </dt>
<dd>
<p>简化历史中的所有提交都会显示出来。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---simplify-merges"> <a class="anchor" href="#git-shortlog---simplify-merges"></a>--simplify-merges </dt>
<dd>
<p>为`--full-history`增加了一个选项，可以从结果的历史中删除一些不必要的合并，因为没有选定的提交对这次合并有贡献。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---ancestry-pathltgt"> <a class="anchor" href="#git-shortlog---ancestry-pathltgt"></a>--ancestry-path[=&lt;提交&gt;] </dt>
<dd>
<p>如果给定了一个要显示的提交范围（例如 <em>提交1..提交2</em> 或 <em>提交2 ^-提交1</em> ），则只会显示该范围内属于 &lt;提交&gt; 的祖先、&lt;提交&gt; 的后代或 &lt;提交&gt; 本身的提交。 如果没有指定提交，则使用 <em>提交1</em>（范围中排除的部分）作为 &lt;提交&gt;。 可以多次传递；如果是这样，如果某个提交是所给定提交中的任何一个，或者是其中一个提交的祖先或后代，则该提交将被包括在内。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下是更详细的解释。</p>
</div>
<div class="paragraph">
<p>假设你指定了 <code>foo</code> 作为 &lt;路径&gt;。 我们将把修改 <code>foo</code> 的提交称为 !TREESAME，其余的称为 TREESAME。 (在为 <code>foo</code> 过滤的差异中，它们看起来分别是不同的和相同的。）</p>
</div>
<div class="paragraph">
<p>在下文中，我们将始终引用同一个历史实例来说明简化设置之间的差异。 我们假设你在这个提交图中过滤的是一个文件 <code>foo</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M---N---O---P---Q
	 /     /   /   /   /   /
	I     B   C   D   E   Y
	 \   /   /   /   /   /
	  `-------------'   X</pre>
</div>
</div>
<div class="paragraph">
<p>历史 A---Q 的横线被认为是每次合并的第一个父本。 这些提交是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&#8216;I`是初始提交，其中`foo`存在，内容是`asdf&#8217;<em>，文件`quux`存在，内容是`quux</em>'。初始提交与空树比较，所以`I`是！`TREESAME。</p>
</li>
<li>
<p>在`A`中，&#8216;foo`只包含`foo&#8217;'。</p>
</li>
<li>
<p>`B`包含与`A`相同的变化。 它的合并`M`是微不足道的，因此对所有父类来说是TREESAME。</p>
</li>
<li>
<p><code>C`没有改变`foo</code>，但是它的合并`N`将其改为`foobar''，所以它与任何父类都不存在TREESAME。</p>
</li>
<li>
<p>&#8216;D`将`foo`设置为`baz&#8217;<em>。它的合并项`O`将`N`和`D`的字符串合并为`foobarbaz</em>'；也就是说，它与任何父类都不是TREESAME。</p>
</li>
<li>
<p>&#8216;E`将`quux`改为`xyzzy&#8217;<em>，其合并的`P`将这些字符串合并为`quux xyzzy</em>'。`P&#8217;与`O&#8217;的关系是TREESAME，但与`E&#8217;不是。</p>
</li>
<li>
<p><code>X`是一个独立的根提交，添加了一个新文件`side</code>，<code>Y`修改了它。`Y`与`X`同为TREESAME。它的合并文件`Q`在`P`上添加了`side</code>，`Q`与`P`是同源，但与`Y`不是同源。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>rev-list`在历史中倒退，根据是否使用</code>--full-history`和/或父代重写（通过`--parents`或`--children`），包括或排除提交。以下设置是可用的。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-shortlog--1"> <a class="anchor" href="#git-shortlog--1"></a>默认模式 </dt>
<dd>
<p>如果提交的内容与任何父类不相干，则被包括在内（当然这一点可以改变，见下面的`--sparse`）。 如果该提交是一个合并，并且它与一个父类是同源的，则只跟随该父类。 (即使有几个TREESAME父类，也只跟随其中一个。) 否则，跟随所有父类。</p>
<div class="paragraph">
<p>这将实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---N---O
	 /     /   /
	I---------D</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果有TREESAME父类的话，只遵循TREESAME父类的规则，将`B&#8217;完全排除在考虑之外。 `C`是通过`N`考虑的，但也是TREESAME。 根提交是与空树比较的，所以`I`是!!TREESAME。</p>
</div>
<div class="paragraph">
<p>父/子关系只有在使用 <code>--parents</code> 选项的情况下才能看到，但这并不影响在默认模式下选择的提交，所以我们显示了父行。</p>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog---full-history-1"> <a class="anchor" href="#git-shortlog---full-history-1"></a>--full-history 无父级重写的完整历史记录 </dt>
<dd>
<p>这种模式与默认模式有一点不同：总是跟随一个合并的所有父本，即使它与其中一个父本是TREESAME。 即使合并的一方有多个提交被包括在内，这也不意味着合并本身也是如此在这个例子中，我们得到</p>
<div class="listingblock">
<div class="content">
<pre>	I  A  B  N  D  O  P  Q</pre>
</div>
</div>
<div class="paragraph">
<p><code>M</code> 被排除在外，因为它与父母都是TREESAME。 <code>E</code> 、<code>C</code> 和`B` 都走了，但只有`B` 是 !TREESAME，所以其他的都没有出现。</p>
</div>
<div class="paragraph">
<p>请注意，如果没有父子重写，其实是不可能谈论提交之间的父子关系的，所以我们显示它们是不相连的。</p>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog---full-history-1-1"> <a class="anchor" href="#git-shortlog---full-history-1-1"></a>--full-history 带父级重写功能的全历史记录 </dt>
<dd>
<p>普通的提交只有当它们是！TREESAME时才会被包括在内（尽管这一点可以改变，见下面的`--sparse`）。</p>
<div class="paragraph">
<p>合并总是被包括在内。 然而，他们的父级列表会被重写。沿着每个父级，修剪掉那些不包括自己的提交。 这样做的结果是</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M---N---O---P---Q
	 /     /   /   /   /
	I     B   /   D   /
	 \   /   /   /   /
	  `-------------'</pre>
</div>
</div>
<div class="paragraph">
<p>与上面的`--full-history`相比，没有重写。 请注意，<code>E`被修剪掉了，因为它是TREESAME，但是P的父列表被改写为包含`E`的父`I</code>。 同样的情况发生在`C`和`N`，以及`X`、<code>Y`和`Q</code>。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>除了上述设置外，你还可以改变 TRESAME 是否会影响收录：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-shortlog---dense-1"> <a class="anchor" href="#git-shortlog---dense-1"></a>--dense </dt>
<dd>
<p>如果不与任何父类有TREESAME关系，则包括走过的承诺。</p>
</dd>
<dt class="hdlist1" id="git-shortlog---sparse-1"> <a class="anchor" href="#git-shortlog---sparse-1"></a>--sparse </dt>
<dd>
<p>所有走过的提交都包括在内。</p>
<div class="paragraph">
<p>请注意，如果没有`--full-history`，这仍然可以简化合并：如果父代之一是TREESAME，我们只跟随这个父代，所以合并的其他方面永远不会被走。</p>
</div>
</dd>
<dt class="hdlist1" id="git-shortlog---simplify-merges-1"> <a class="anchor" href="#git-shortlog---simplify-merges-1"></a>--simplify-merges </dt>
<dd>
<p>首先，按照`--full-history`与父级改写的相同方式建立一个历史图（见上文）。</p>
<div class="paragraph">
<p>然后根据以下规则将每个提交的 <code>C</code> 简化为最终历史中的替换 <code>C</code>：</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>将 "C "设为 "C"。</p>
</li>
<li>
<p>将`C'<code>的每个父类`P'替换成其简化的`P'</code>。 在这个过程中，放弃那些是其他父类的祖先的父类，或者是根部提交TREESAME的空树，并删除重复的父类，但注意不要放弃所有我们是TREESAME的父类。</p>
</li>
<li>
<p>如果在这次父级改写之后，&#8216;C&#8217;`是一个根或合并提交（有0个或&gt;1个父级），一个边界提交，或！TREESAME，那么它将被保留。 否则，它将被替换为其唯一的父类。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>通过与 <code>--full-history</code> 选项的父级改写进行比较，可以最好地显示其效果。 这个例子变成了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M---N---O
	 /     /       /
	I     B       D
	 \   /       /
	  `---------'</pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>N</code> 、<code>P</code> 和 <code>Q</code> 与 <code>--full-history</code> 的主要区别：</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>N`的父列表中删除了`I</code>，因为它是另一个父`M`的一个祖先。 但是，`N`仍然存在，因为它是!TREESAME。</p>
</li>
<li>
<p><code>P`的父级列表也同样删除了`I</code>。 然后`P`被完全删除，因为它有一个父本，并且是TREESAME。</p>
</li>
<li>
<p><code>Q`的父列表中有`Y`简化为`X</code>。然后`X`被删除，因为它是一个TREESAME根。然后`Q`被完全删除，因为它有一个父级，是TREESAME。</p>
</li>
</ul>
</div>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>还有一种简化模式可用：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-shortlog---ancestry-pathltgt-1"> <a class="anchor" href="#git-shortlog---ancestry-pathltgt-1"></a>--ancestry-path[=&lt;提交&gt;] </dt>
<dd>
<p>将显示的提交限制在&lt;提交&gt;的祖先，或&lt;提交&gt;的后代，或&lt;提交&gt;本身。</p>
<div class="paragraph">
<p>作为一个用例，请考虑以下提交历史：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	    D---E-------F
	   /     \       \
	  B---C---G---H---I---J
	 /                     \
	A-------K---------------L--M</pre>
</div>
</div>
<div class="paragraph">
<p>有规律的 "D&#8230;&#8203;M "会计算出作为`M`的祖先的提交集合，但不包括作为`D`的祖先的提交。这对了解`M&#8217;的历史在`D&#8217;之后发生了什么很有用，也就是说`M&#8217;有什么东西是`D&#8217;没有的'。这个例子中的结果是所有的提交，除了`A`和`B`（当然还有`D`本身）。</p>
</div>
<div class="paragraph">
<p>然而，当我们想找出`M&#8217;中哪些提交被`D&#8217;引入的错误所污染而需要修复时，我们可能只想查看&#8217;D&#8230;&#8203;M&#8217;中实际上是`D&#8217;的后代的子集，即排除`C&#8217;和`K'。这正是`--ancestry-path`选项的作用。应用于&#8217;D&#8230;&#8203;M&#8217;范围，它的结果是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>		E-------F
		 \       \
		  G---H---I---J
			       \
				L--M</pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以用`--ancestry-path=D`来代替`--ancestry-path`，这在应用于&#8217;D&#8230;&#8203;M&#8217;范围时意思相同，只是更加明确。</p>
</div>
<div class="paragraph">
<p>如果我们感兴趣的是这个范围内的某个主题，以及受该主题影响的所有提交，我们可能只想查看祖先路径中包含该主题的`D&#8230;&#8203;M`子集。 因此，以`--ancestry-path=H D&#8230;&#8203;M`为例，会形成以下结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>		E
		 \
		  G---H---I---J
			       \
				L--M</pre>
</div>
</div>
<div class="paragraph">
<p>而`--ancestry-path=K D&#8230;&#8203;M`会形成以下结果</p>
</div>
<div class="listingblock">
<div class="content">
<pre>		K---------------L--M</pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在讨论另一个选项，`--show-pulls`之前，我们需要创建一个新的历史实例。</p>
</div>
<div class="paragraph">
<p>用户在查看简化的提交历史时经常遇到的一个问题是，他们知道的对某个文件的修改提交并没有出现在该文件的简史中。让我们演示一个新的例子，并说明`--full-history`和`--simplify-merges`等选项在这种情况下是如何工作的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M-----C--N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`-Z'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `---Y--'</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，假设`I`创建了`file.txt`，并被`A`、<code>B`和`X`以不同方式修改。单亲提交的`C</code>、<code>Z`和`Y`没有修改`file.txt</code>。合并提交 <code>M`是通过解决合并冲突而产生的，包括了 `A `和 `B `的修改，因此与其中任何一个都不是同源的。然而，合并提交`R`是通过忽略`M`处的`file.txt`的内容，而只采用`X`处的`file.txt`的内容而产生的。因此，`R`与`X`是同源的，但不是`M</code>。最后，创建`N&#8217;的自然合并决议是取`file.txt`在`R&#8217;的内容，所以`N&#8217;与`R`是同源的，但不是`C`。 合并提交的 <code>O</code> 和 <code>P</code> 与它们的第一代父母是同源的，但与它们的第二代父母 <code>Z</code> 和 `Y `则不是同源的。</p>
</div>
<div class="paragraph">
<p>当使用默认模式时，`N&#8217;和`R`都有一个TREESAME父级，所以这些边被展示出来，其他边被忽略。由此产生的历史图是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	I---X</pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code>--full-history</code> 选项时，Git 会行走每条边。这将发现提交 <code>A</code> 和 <code>B</code> 以及合并 <code>M</code>，但也将揭示合并提交 <code>O</code> 和 <code>P</code> 。通过父级改写，得到的图是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M--------N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`--'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `------'</pre>
</div>
</div>
<div class="paragraph">
<p>这里，合并提交 <code>O</code> 和 <code>P</code> 带来了额外的输出，因为它们实际上并没有对 <code>file.txt</code> 做出改变。他们只是合并了一个基于 <code>file.txt</code> 旧版本的主题。这是在使用工作流程的仓库中常见的问题，在工作流程中，许多贡献者并行工作，并沿着一个主干合并他们的主题分支：不相关的合并出现在 <code>--full-history</code> 选项结果中。</p>
</div>
<div class="paragraph">
<p>当使用`--simplify-merges`选项时，提交的 <code>O</code> 和 <code>P</code> 从结果中消失。这是因为 <code>O</code> 和 <code>P</code> 重写的第二父本可以从它们的第一父本到达。这些边被移除，然后这些提交看起来就像与它们的父类一样的单亲提交。这也发生在提交 <code>N</code> 上，导致历史视图如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M--.
	 /     /    \
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'</pre>
</div>
</div>
<div class="paragraph">
<p>在这个视图中，我们看到了所有来自`A`，<code>B`和`X`的重要单亲变化。我们还可以看到仔细解决的合并`M`和不那么仔细解决的合并`R</code>。这些信息通常足以确定为什么`A`和`B`的提交在默认视图中从历史中 "消失 "了。然而，这种方法也有一些问题。</p>
</div>
<div class="paragraph">
<p>第一个问题是性能。与之前的任何选项不同，<code>--simplify-merges</code> 选项需要在返回一个结果之前走完整个提交历史。这可能使该选项难以用于非常大的仓库。</p>
</div>
<div class="paragraph">
<p>第二个问题是审计的问题。当许多贡献者在同一个版本库中工作时，哪些合并提交将一个变化引入到一个重要的分支是很重要的。上面有问题的合并`R`不可能是用来合并到一个重要分支的合并提交。相反，`N&#8217;是用来将`R&#8217;和`X&#8217;合并到重要分支的。这个提交可能有关于为什么`X&#8217;会覆盖`A&#8217;和`B&#8217;的修改的信息，在其提交信息中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-shortlog---show-pulls-1"> <a class="anchor" href="#git-shortlog---show-pulls-1"></a>--show-pulls </dt>
<dd>
<p>除了在默认历史中显示的提交之外，还要显示每一个与第一个父本不相同但与后来的父本相同的合并提交。</p>
<div class="paragraph">
<p>当一个合并提交被 <code>--show-pulls</code> 选项包含时，该合并被视为从另一个分支 “拉取” 来的修改。在这个例子中使用 <code>--show-pulls</code> 选项时（没有其他选项），得到的图是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	I---X---R---N</pre>
</div>
</div>
<div class="paragraph">
<p>这里，合并后的提交`R`和`N`被包括在内，因为它们分别将提交`X`和`R`拉到了基础分支。这些合并是`A`和`B`的提交没有出现在默认历史中的原因。</p>
</div>
<div class="paragraph">
<p>当 <code>--show-pulls</code> 与 <code>--simplify-merges</code> 选项配对时，该图包括所有必要的信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M--.   N
	 /     /    \ /
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，由于`M`可以从`R`到达，从`N`到`M`的边被简化掉了。然而，`N`仍然作为一个重要的提交出现在历史中，因为它把`R`的修改 "拉 "进了主分支。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>--simplify-by-decoration</code> 选项允许你只查看历史拓扑的全貌，省略那些没有被标签引用的提交。 如果 (1) 提交被标签引用，或者 (2) 提交改变了命令行上给出的路径内容，则被标记为 TREESAME（换句话说，按照上述历史简化规则保留）。 所有其他的提交都被标记为 TREESAME（会被简化掉）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_制图作者"><a class="anchor" href="#_制图作者"></a>制图作者</h2>
<div class="sectionbody">
<div class="paragraph">
<p>参见 <a href='{{< relurl "docs/gitmailmap/zh_HANS-CN" >}}'>gitmailmap[5]</a>。</p>
</div>
<div class="paragraph">
<p>注意，如果`git shortlog`在版本库外运行（处理标准输入的日志内容），它将在当前目录下寻找一个`.mailmap`文件。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>属于 <a href='{{< relurl "docs/git/zh_HANS-CN" >}}'>git[1]</a> 文档</p>
</div>
</div>
</div>