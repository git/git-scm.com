---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-rebase Documentation
docname: git-rebase
lang: zh_HANS-CN
aliases:
- "/docs/git-rebase/zh_HANS-CN/index.html"
---
<div class="sect1">
<h2 id="_名称"><a class="anchor" href="#_名称"></a>名称</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-rebase - 在另一个基础提示之上重新应用提交内容</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_概述"><a class="anchor" href="#_概述"></a>概述</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git rebase</em> [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;]
	[--onto &lt;newbase&gt; | --keep-base] [&lt;upstream&gt; [&lt;branch&gt;]]
<em>git rebase</em> [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]
	--root [&lt;branch&gt;]
<em>git rebase</em> (--continue|--skip|--abort|--quit|--edit-todo|--show-current-patch)</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_描述"><a class="anchor" href="#_描述"></a>描述</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果指定了 <code>&lt;branch&gt;</code>，<code>git rebase</code> 会自动执行 <code>git switch &lt;branch&gt;</code>，然后再做其他事情。 否则，它会保留在当前分支上。</p>
</div>
<div class="paragraph">
<p>如果未指定 <code>&lt;upstream&gt;</code>，将使用 <code>branch.&lt;name&gt;.remote</code> 和 <code>branch.&lt;name&gt;.merge</code> 选项中配置的上游（详见 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>），并假定使用 `--fork-point`选项。 如果您当前不在任何分支上，或者当前分支没有配置上游，变基操作会中止。</p>
</div>
<div class="paragraph">
<p>当前分支中的所有提交所做的改动，但不在 <code>&lt;upstream&gt;</code> 中的，都会被保存到一个临时区域。 这与 <code>git log &lt;upstream&gt;..HEAD</code> 或 <code>git log 'fork_point'..HEAD</code> 所显示的提交相同（如果启用了 <code>--fork-point</code>，请参阅下文关于 <code>--fork-point`的描述）；或者，如果指定了 `--root</code> 选项，则与 <code>git log HEAD</code> 所显示的提交相同。</p>
</div>
<div class="paragraph">
<p>如果提供了 <code>--onto</code> 选项，当前分支会重置为 <code>&lt;upstream&gt;</code> 或 <code>&lt;newbase&gt;</code>。 这与 <code>git reset --hard &lt;upstream&gt;</code>（或 <code>&lt;newbase&gt;</code>）的效果完全相同。<code>ORIG_HEAD</code> 设置为指向重置前分支的顶端。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
如果在重置过程中使用了其他写入伪引用的命令（例如 <code>git reset</code>），就不能保证 <code>ORIG_HEAD</code> 在重置结束时仍然指向前一个分支的分支提示。不过，使用当前分支的 引用日志（即 <code>@{1}</code>，参见 <a href='{{< relurl "docs/gitrevisions/zh_HANS-CN" >}}'>gitrevisions[7]</a>）可以访问前一个分支的分支提示。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然后，先前保存在临时区域的提交将按顺序逐一重新应用到当前分支。请注意，<code>HEAD</code> 中任何与 <code>HEAD...&lt;upstream&gt;</code> 中的提交有相同文字改动的提交都会被省略（也就是说，上游已经接受的补丁，如果提交信息或时间戳不同，就会被跳过）。</p>
</div>
<div class="paragraph">
<p>合并失败有可能导致该过程无法完全自动进行。 您必须解决合并失败问题，然后运行 <code>git rebase --continue</code>。 另一种方法是使用 <code>git rebase --skip</code> 绕过导致合并失败的提交。 要检查原始的 <code>&lt;branch&gt;</code> 并移除 <code>.git/rebase-apply</code> 工作文件，请使用 <code>git rebase --abort</code> 命令。</p>
</div>
<div class="paragraph">
<p>假设存在以下历史记录，当前分支为 "topic"：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>          A---B---C topic
         /
    D---E---F---G master</pre>
</div>
</div>
<div class="paragraph">
<p>从这一点来看，以下任一命令的结果都是如此：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase master
git rebase master topic</pre>
</div>
</div>
<div class="paragraph">
<p>那就是 :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                  A'--B'--C' topic
                 /
    D---E---F---G master</pre>
</div>
</div>
<div class="paragraph">
<p><strong>注：</strong> 后一种形式只是 <code>git checkout topic</code> 的简写。后接 <code>git rebase master</code>。当 rebase 退出时，<code>topic</code> 将仍是已签出的分支。</p>
</div>
<div class="paragraph">
<p>如果上游分支已经包含了您所做的修改（例如，因为您邮寄的补丁被应用到了上游），那么该提交将被跳过，并发出警告（如果使用了 “合并” 后台）。 例如，在以下历史记录上运行 <code>git rebase master</code>（其中 <code>A'</code> 和 <code>A</code> 引入了相同的变更集，但提交者信息不同）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>          A---B---C topic
         /
    D---E---A'---F master</pre>
</div>
</div>
<div class="paragraph">
<p>将导致 :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                   B'---C' topic
                  /
    D---E---A'---F master</pre>
</div>
</div>
<div class="paragraph">
<p>下面是如何使用 <code>rebase --onto</code> 将基于一个分支的特性分支移植到另一个分支，以假装特性分支是从后一个分支分叉而来。</p>
</div>
<div class="paragraph">
<p>首先，我们假设 <em>topic</em> 基于 <em>next</em> 分支。 例如，<em>topic</em> 中开发的功能依赖于 <em>next</em> 中的某些功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic</pre>
</div>
</div>
<div class="paragraph">
<p>我们想让 <em>topic</em> 从分支 <em>master</em> 中分叉出来；例如，因为 <em>topic</em> 所依赖的功能已经合并到了更稳定的分支 <em>master</em> 中。我们希望我们的提交树看起来像这样 :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o  master
        |            \
        |             o'--o'--o'  topic
         \
          o---o---o---o---o  next</pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用以下命令来获取 :</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --onto master next topic</pre>
</div>
</div>
<div class="paragraph">
<p>--onto 选项的另一个示例是重新基点分支的一部分。 如果我们有以下情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                            H---I---J topicB
                           /
                  E---F---G  topicA
                 /
    A---B---C---D  master</pre>
</div>
</div>
<div class="paragraph">
<p>那么命令</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --onto master topicA topicB</pre>
</div>
</div>
<div class="paragraph">
<p>将导致 :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                 H'--I'--J'  topicB
                /
                | E---F---G  topicA
                |/
    A---B---C---D  master</pre>
</div>
</div>
<div class="paragraph">
<p>这在主题 B 不依赖于主题 A 的情况下非常有用。</p>
</div>
<div class="paragraph">
<p>也可以用变基删除一系列提交。 如果我们遇到以下情况 :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    E---F---G---H---I---J  topicA</pre>
</div>
</div>
<div class="paragraph">
<p>那么命令</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --onto topicA~5 topicA~3 topicA</pre>
</div>
</div>
<div class="paragraph">
<p>将导致删除 F 和 G 项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    E---H'---I'---J'  topicA</pre>
</div>
</div>
<div class="paragraph">
<p>如果 F 和 G 在某些方面有缺陷，或者不应该是 topicA 的一部分，这一点就很有用。 请注意，<code>--onto</code> 参数和 <code>&lt;upstream&gt;</code> 参数可以是任何有效的提交。</p>
</div>
<div class="paragraph">
<p>如果出现冲突，<code>git rebase</code> 会在第一个有问题的提交处停止，并在树中留下冲突标记。 你可以用 <code>git diff</code> 找到这些标记 (&lt;&lt;&lt;&lt;&lt;&lt;)，并进行编辑以解决冲突。 每编辑一个文件，都需要告诉 Git 冲突已被解决，通常可以用</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git add &lt;filename&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>手动解决冲突并以所需的分辨率更新索引后，您可以使用</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --continue</pre>
</div>
</div>
<div class="paragraph">
<p>或者，您也可以通过以下方法撤销 <em>git rebase</em> 操作</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase --abort</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_模式选项"><a class="anchor" href="#_模式选项"></a>模式选项</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节中的选项不能与任何其他选项一起使用，包括不能相互使用：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase---continue"> <a class="anchor" href="#git-rebase---continue"></a>--continue </dt>
<dd>
<p>解决合并冲突后，重新启动重新分区进程。</p>
</dd>
<dt class="hdlist1" id="git-rebase---skip"> <a class="anchor" href="#git-rebase---skip"></a>--skip </dt>
<dd>
<p>跳过当前补丁，重新启动重新分区进程。</p>
</dd>
<dt class="hdlist1" id="git-rebase---abort"> <a class="anchor" href="#git-rebase---abort"></a>--abort </dt>
<dd>
<p>终止变基操作并将 HEAD 重置为原始分支。如果在启动变基操作时提供了 <code>&lt;分支&gt;</code>，那么 <code>HEAD</code> 将被重置为 <code>&lt;分支&gt;</code>。否则，<code>HEAD</code> 将被重置为启动变基操作时的位置。</p>
</dd>
<dt class="hdlist1" id="git-rebase---quit"> <a class="anchor" href="#git-rebase---quit"></a>--quit </dt>
<dd>
<p>放弃变基操作，但 <code>HEAD</code> 不会重置回原始分支。索引和工作树也会因此保持不变。如果使用 <code>--autostash</code> 创建了临时储藏条目，它将被保存到储藏列表中。</p>
</dd>
<dt class="hdlist1" id="git-rebase---edit-todo"> <a class="anchor" href="#git-rebase---edit-todo"></a>--edit-todo </dt>
<dd>
<p>在交互式变基过程中编辑待办事项列表。</p>
</dd>
<dt class="hdlist1" id="git-rebase---show-current-patch"> <a class="anchor" href="#git-rebase---show-current-patch"></a>--show-current-patch </dt>
<dd>
<p>在交互式变基或因冲突而停止变基时显示当前补丁。相当于 <code>git show REBASE_HEAD</code>。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_选项"><a class="anchor" href="#_选项"></a>选项</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase---ontoltgt"> <a class="anchor" href="#git-rebase---ontoltgt"></a>--onto &lt;新基础&gt; </dt>
<dd>
<p>创建新提交的起点。如果未指定 <code>--onto</code> 选项，则起点为 <code>&lt;upstream&gt;</code>。 可以是任何有效的提交，而不仅仅是现有的分支名称。</p>
<div class="paragraph">
<p>作为一种特殊情况，如果 A 和 B 的合并库只有一个，则可以使用 "A...B "作为合并库的快捷方式。您最多可以省略 A 和 B 中的一个，在这种情况下，它默认为 HEAD。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---keep-base"> <a class="anchor" href="#git-rebase---keep-base"></a>--keep-base </dt>
<dd>
<p>将创建新提交的起点设为 <code>&lt;upstream&gt;</code> 和 <code>&lt;branch&gt;</code> 的合并库。运行 <code>git rebase --keep-base &lt;upstream&gt; &lt;branch&gt;</code> 相当于运行 <code>git rebase --reapply-cherry-picks --no-fork-point --onto &lt;upstream&gt;...&lt;branch&gt; &lt;upstream&gt; &lt;branch&gt;</code> 。</p>
<div class="paragraph">
<p>该选项适用于在上游分支上开发功能的情况。在开发功能的过程中，上游分支可能会前进，这时最好的办法可能不是继续在上游分支上重新加载，而是保持基本提交不变。由于基本提交保持不变，该选项意味着 <code>--reapply-cherry-picks</code>，以避免丢失提交。</p>
</div>
<div class="paragraph">
<p>虽然该选项和 <code>--fork-point</code> 都能找到 <code>&lt;upstream&gt;</code> 和 <code>&lt;branch&gt;</code> 之间的合并基数，但该选项使用合并基数作为创建新提交的_起点_，而 `--fork-point`则使用合并基数来确定将被重定向的_提交集_。</p>
</div>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase-ltgt"> <a class="anchor" href="#git-rebase-ltgt"></a>&lt;上游仓库&gt; </dt>
<dd>
<p>要与之比较的上游分支。 可以是任何有效的提交，而不仅仅是现有的分支名称。默认为当前分支配置的上游分支。</p>
</dd>
<dt class="hdlist1" id="git-rebase-ltgt-1"> <a class="anchor" href="#git-rebase-ltgt-1"></a>&lt;分支&gt; </dt>
<dd>
<p>工作分支；默认为 <code>HEAD</code>。</p>
</dd>
<dt class="hdlist1" id="git-rebase---apply"> <a class="anchor" href="#git-rebase---apply"></a>--apply </dt>
<dd>
<p>使用应用策略来变基（内部调用 <code>git-am</code>）。 一旦合并后端处理了应用后端所做的一切，这个选项将来可能就不再适用了。</p>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---emptydropkeepstop"> <a class="anchor" href="#git-rebase---emptydropkeepstop"></a>--empty=(drop|keep|stop) </dt>
<dd>
<p>How to handle commits that are not empty to start and are not clean cherry-picks of any upstream commit, but which become empty after rebasing (because they contain a subset of already upstream changes):</p>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase-codedropcode"> <a class="anchor" href="#git-rebase-codedropcode"></a><code>drop</code> </dt>
<dd>
<p>提交将被丢弃。这是默认行为。</p>
</dd>
<dt class="hdlist1" id="git-rebase-codekeepcode"> <a class="anchor" href="#git-rebase-codekeepcode"></a><code>keep</code> </dt>
<dd>
<p>提交将被保留。当指定了 <code>--exec</code> 时，此选项是隐含的，除非同时指定了 <code>-i</code>/<code>--interactive</code>。</p>
</dd>
<dt class="hdlist1" id="git-rebase-codestopcode"> <a class="anchor" href="#git-rebase-codestopcode"></a><code>stop</code> </dt>
<dt class="hdlist1" id="git-rebase-codeaskcode"> <a class="anchor" href="#git-rebase-codeaskcode"></a><code>ask</code> </dt>
<dd>
<p>当提交被应用时，变基将停止，允许您选择是丢弃它、进一步编辑文件，还是只提交空更改。当指定了 <code>-i</code>/<code>--interactive</code> 时，此选项是隐含的。<code>ask</code> 是 <code>stop</code> 的废弃同义词。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>需要注意的是，开始时为空的提交会被保留（除非指定了 <code>--no-keep-empty</code>），而干净的 cherry-picks 提交（由 <code>git log --cherry-mark ...</code>）会被检测到并作为第一步被丢弃（除非通过了 <code>--reapply-cherry-picks`或 `--keep-base</code>）。</p>
</div>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---no-keep-empty"> <a class="anchor" href="#git-rebase---no-keep-empty"></a>--no-keep-empty </dt>
<dt class="hdlist1" id="git-rebase---keep-empty"> <a class="anchor" href="#git-rebase---keep-empty"></a>--keep-empty </dt>
<dd>
<p>不在结果中保留重置前开始为空的提交（即不改变父提交的任何内容）。 默认情况下保留开始时为空的提交，因为创建此类提交需要向 <code>git commit</code> 传递 <code>--allow-empty</code> 覆盖标志，表明用户非常有意地创建此类提交，因此希望保留它。</p>
<div class="paragraph">
<p>使用这个标记的情况可能很少，因为你只需启动交互式变基，并删除与你不想要的提交对应的行，就能删除开始时为空的提交。 该标记是一种方便的快捷方式，比如当外部工具生成许多空提交，而你希望将它们全部删除时。</p>
</div>
<div class="paragraph">
<p>如果提交开始时不是空的，但重定向后变成空的，参阅 <code>--empty</code> 标志。</p>
</div>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---reapply-cherry-picks"> <a class="anchor" href="#git-rebase---reapply-cherry-picks"></a>--reapply-cherry-picks </dt>
<dt class="hdlist1" id="git-rebase---no-reapply-cherry-picks"> <a class="anchor" href="#git-rebase---no-reapply-cherry-picks"></a>--no-reapply-cherry-picks </dt>
<dd>
<p>重新应用任何上游提交中所有干净的拣选，而不是先发制人地丢弃它们。(如果这些提交在重排后成为空提交，因为它们包含了上游修改的子集，则对它们的行为由 <code>--empty</code> 标志控制。）</p>
<div class="paragraph">
<p>如果没有 <code>--keep-base</code>（或给出了 <code>--no-reapply-cherry-picks</code>），这些提交将被自动放弃。 由于这需要读取所有上游提交，对于需要读取大量上游提交的仓库来说，代价可能会很高。使用 <em>merge</em> 后端时，每次丢弃提交都会发出警告（除非给出 <code>--quiet</code>）。除非将 <code>advice.skippedCherryPicks</code> 设为 false，否则也会发出警告（参见 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>）。</p>
</div>
<div class="paragraph">
<p><code>--reapply-cherry-picks</code> 允许变基操作放弃读取所有上游提交，从而可能提高性能。</p>
</div>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---allow-empty-message"> <a class="anchor" href="#git-rebase---allow-empty-message"></a>--allow-empty-message </dt>
<dd>
<p>无操作。 过去，重写带空信息的提交会失败，而该选项会覆盖这一行为，允许重写带空信息的提交。 现在，带空信息的提交不会导致重定向失败。</p>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase--m"> <a class="anchor" href="#git-rebase--m"></a>-m </dt>
<dt class="hdlist1" id="git-rebase---merge"> <a class="anchor" href="#git-rebase---merge"></a>--merge </dt>
<dd>
<p>使用合并策略重定向（默认）。</p>
<div class="paragraph">
<p>请注意，变基合并是通过在 <code>&lt;上游&gt;</code> 分支上重放工作分支的每次提交来实现的。 因此，当发生合并冲突时，被报告为 <em>ours</em> 的一方是迄今为止以 <code>&lt;上游&gt;</code> 为起点的重定向系列，而 <em>theirs</em> 则是工作分支。 换句话说，双方是对调的。</p>
</div>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase--sltgt"> <a class="anchor" href="#git-rebase--sltgt"></a>-s &lt;策略&gt; </dt>
<dt class="hdlist1" id="git-rebase---strategyltgt"> <a class="anchor" href="#git-rebase---strategyltgt"></a>--strategy=&lt;策略&gt; </dt>
<dd>
<p>使用给定的合并策略，而不是默认的 <code>ort</code>。暗指 <code>--merge</code>。</p>
<div class="paragraph">
<p>由于 <code>git rebase</code> 会使用给定的策略在 <code>&lt;上游&gt;</code> 分支之上重复工作分支的每次提交，因此使用 <code>ours</code> 策略只会清空 <code>&lt;分支&gt;</code> 中的所有补丁，这没有什么意义。</p>
</div>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase--Xltgt"> <a class="anchor" href="#git-rebase--Xltgt"></a>-X &lt;策略选项&gt; </dt>
<dt class="hdlist1" id="git-rebase---strategy-optionltgt"> <a class="anchor" href="#git-rebase---strategy-optionltgt"></a>--strategy-option=&lt;策略选项&gt; </dt>
<dd>
<p>将 &lt;策略选项&gt; 传递给合并策略。 这意味着 <code>--merge</code>，如果没有指定策略，则是 <code>--s ort</code>。 请注意 <em>ours</em> 和 <em>theirs</em> 的颠倒，就像上面的 `-m`选项一样。</p>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---rerere-autoupdate"> <a class="anchor" href="#git-rebase---rerere-autoupdate"></a>--rerere-autoupdate </dt>
<dt class="hdlist1" id="git-rebase---no-rerere-autoupdate"> <a class="anchor" href="#git-rebase---no-rerere-autoupdate"></a>--no-rerere-autoupdate </dt>
<dd>
<p>在 rerere 机制重用当前冲突的记录解析来更新工作树中的文件后，允许它也用解析的结果来更新索引。 <code>--no-rerere-autoupdate`是一个很好的方法，在用单独的 `git add</code> 提交结果到索引之前，可以反复检查 <code>rerere</code> 所做的事情，并抓住潜在的错误合并。</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase--Sltkeyidgt"> <a class="anchor" href="#git-rebase--Sltkeyidgt"></a>-S[&lt;keyid&gt;] </dt>
<dt class="hdlist1" id="git-rebase---gpg-signltIDgt"> <a class="anchor" href="#git-rebase---gpg-signltIDgt"></a>--gpg-sign[=&lt;键 ID&gt;] </dt>
<dt class="hdlist1" id="git-rebase---no-gpg-sign"> <a class="anchor" href="#git-rebase---no-gpg-sign"></a>--no-gpg-sign </dt>
<dd>
<p>GPG 签名提交。<code>keyid</code> 参数是可选的，默认为提交者身份；如果指定了，则必须与选项相连，不加空格。<code>--no-gpg-sign</code> 用于还原 <code>commit.gpgSign</code> 配置变量和先前的 <code>--gpg-sign</code>。</p>
</dd>
<dt class="hdlist1" id="git-rebase--q"> <a class="anchor" href="#git-rebase--q"></a>-q </dt>
<dt class="hdlist1" id="git-rebase---quiet"> <a class="anchor" href="#git-rebase---quiet"></a>--quiet </dt>
<dd>
<p>静默。暗含 <code>--no-stat</code> 选项。</p>
</dd>
<dt class="hdlist1" id="git-rebase--v"> <a class="anchor" href="#git-rebase--v"></a>-v </dt>
<dt class="hdlist1" id="git-rebase---verbose"> <a class="anchor" href="#git-rebase---verbose"></a>--verbose </dt>
<dd>
<p>详尽输出。暗含 <code>--stat</code> 选项。</p>
</dd>
<dt class="hdlist1" id="git-rebase---stat"> <a class="anchor" href="#git-rebase---stat"></a>--stat </dt>
<dd>
<p>显示上次变基后上游变化的差异状态。差异状态也由配置选项 rebase.stat 控制。</p>
</dd>
<dt class="hdlist1" id="git-rebase--n"> <a class="anchor" href="#git-rebase--n"></a>-n </dt>
<dt class="hdlist1" id="git-rebase---no-stat"> <a class="anchor" href="#git-rebase---no-stat"></a>--no-stat </dt>
<dd>
<p>不要将差异状态作为变基过程的一部分。</p>
</dd>
<dt class="hdlist1" id="git-rebase---no-verify"> <a class="anchor" href="#git-rebase---no-verify"></a>--no-verify </dt>
<dd>
<p>该选项会绕过 pre-rebase 钩子。 另请参阅 <a href='{{< relurl "docs/githooks/zh_HANS-CN" >}}'>githooks[5]</a>。</p>
</dd>
<dt class="hdlist1" id="git-rebase---verify"> <a class="anchor" href="#git-rebase---verify"></a>--verify </dt>
<dd>
<p>允许运行 pre-rebase 钩子，这是默认选项。 该选项可用于覆盖 <code>--no-verify</code>。 另请参见 <a href='{{< relurl "docs/githooks/zh_HANS-CN" >}}'>githooks[5]</a>。</p>
</dd>
<dt class="hdlist1" id="git-rebase--Cltngt"> <a class="anchor" href="#git-rebase--Cltngt"></a>-C&lt;n&gt; </dt>
<dd>
<p>确保每次更改前后至少有 <code>&lt;n&gt;</code> 行周围上下文匹配。 如果周围的上下文行数较少，则必须全部匹配。 默认情况下，不会忽略任何上下文。 暗指 <code>--apply</code>。</p>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---no-ff"> <a class="anchor" href="#git-rebase---no-ff"></a>--no-ff </dt>
<dt class="hdlist1" id="git-rebase---force-rebase"> <a class="anchor" href="#git-rebase---force-rebase"></a>--force-rebase </dt>
<dt class="hdlist1" id="git-rebase--f"> <a class="anchor" href="#git-rebase--f"></a>-f </dt>
<dd>
<p>单独重放所有重定向的提交，而不是快进不变的提交。 这样就能确保重建分支的整个历史都是由新提交组成的。</p>
<div class="paragraph">
<p>在还原主题分支合并后，你可能会发现这很有帮助，因为该选项会用新提交的内容重新创建主题分支，这样就可以成功地重新合并，而无需 “恢复原状”（详见<a href="{{< relurl "docs/howto/revert-a-faulty-merge/zh_HANS-CN" >}}">如何还原故障合并</a>）。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---fork-point"> <a class="anchor" href="#git-rebase---fork-point"></a>--fork-point </dt>
<dt class="hdlist1" id="git-rebase---no-fork-point"> <a class="anchor" href="#git-rebase---no-fork-point"></a>--no-fork-point </dt>
<dd>
<p>在计算哪些提交由 <code>&lt;分支&gt;</code> 引入时，使用引用日志在 <code>&lt;上游仓库&gt;</code> 和 <code>&lt;分支&gt;</code> 之间找到更好的共同祖先。</p>
<div class="paragraph">
<p>当启用 <code>--fork-point</code> 时，将使用 <em>fork_point</em> 而不是 <code>&lt;上游仓库&gt;</code> 来计算要重置的提交集，其中 <em>fork_point</em> 是 <code>git merge-base --fork-point &lt;上游仓库&gt; &lt;分支&gt;</code> 命令的结果（参见 <a href='{{< relurl "docs/git-merge-base/zh_HANS-CN" >}}'>git-merge-base[1]</a>）。 如果 <em>fork_point</em> 最终为空，<code>&lt;上游仓库&gt;</code> 将作为备用。</p>
</div>
<div class="paragraph">
<p>如果在命令行中提供了 <code>&lt;上游仓库&gt; ` 或 `--keep-base</code> 参数，则默认为 <code>--no-fork-point</code>，否则默认为 <code>--fork-point</code>。另请参阅 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a> 中的 <code>rebase.forkpoint</code>。</p>
</div>
<div class="paragraph">
<p>如果你的分支基于 <code>&lt;上游仓库&gt;</code>，但 <code>&lt;上游仓库&gt;</code> 被回退了，而你的分支包含了被删除的提交，那么可以使用 <code>--keep-base</code> 选项来从你的分支中删除那些提交。</p>
</div>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---ignore-whitespace"> <a class="anchor" href="#git-rebase---ignore-whitespace"></a>--ignore-whitespace </dt>
<dd>
<p>在尝试协调差异时空格的差异。目前，每个后端都实现了对此行为的近似处理：</p>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase-"> <a class="anchor" href="#git-rebase-"></a>应用后端 </dt>
<dd>
<p>在应用补丁时，忽略上下文行中的空格更改。不幸的是，这意味着如果补丁中要替换的“旧”行与现有文件中的行仅在空格方面有差异，你将得到一个合并冲突而不是成功的补丁应用。</p>
</dd>
<dt class="hdlist1" id="git-rebase--1"> <a class="anchor" href="#git-rebase--1"></a>合并后端 </dt>
<dd>
<p>在合并时，将仅包含空格更改的行视为未更改。不幸的是，这意味着任何旨在修改空格而不涉及其他更改的补丁块将被丢弃，即使另一方没有发生冲突的更改。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---whitespaceltgt"> <a class="anchor" href="#git-rebase---whitespaceltgt"></a>--whitespace=&lt;选项&gt; </dt>
<dd>
<p>这个标志被传递给应用补丁的 <code>git apply</code> 程序（参阅 <a href='{{< relurl "docs/git-apply/zh_HANS-CN" >}}'>git-apply[1]</a>）。它隐含了 <code>--apply</code>。</p>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---committer-date-is-author-date"> <a class="anchor" href="#git-rebase---committer-date-is-author-date"></a>--committer-date-is-author-date </dt>
<dd>
<p>不使用当前时间作为提交者日期，而是使用被重定向的提交的作者日期作为提交者日期。该选项暗含 <code>--force-rebase</code> 选项。</p>
</dd>
<dt class="hdlist1" id="git-rebase---ignore-date"> <a class="anchor" href="#git-rebase---ignore-date"></a>--ignore-date </dt>
<dt class="hdlist1" id="git-rebase---reset-author-date"> <a class="anchor" href="#git-rebase---reset-author-date"></a>--reset-author-date </dt>
<dd>
<p>不使用原始提交的作者日期，而使用当前时间作为重建提交的作者日期。 此选项暗含 <code>--force-rebase</code> 选项。</p>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---signoff"> <a class="anchor" href="#git-rebase---signoff"></a>--signoff </dt>
<dd>
<p>在所有重写的提交中添加 <code>Signed-off-by</code> 尾注。请注意，如果给定了 <code>--interactive</code>，则只有标记为被选中、编辑或重写的提交才会添加尾注。</p>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase--i"> <a class="anchor" href="#git-rebase--i"></a>-i </dt>
<dt class="hdlist1" id="git-rebase---interactive"> <a class="anchor" href="#git-rebase---interactive"></a>--interactive </dt>
<dd>
<p>列出即将重写的提交列表。 让用户在重写前编辑该列表。 这种模式也可用于拆分提交（见下文的拆分提交）。</p>
<div class="paragraph">
<p>提交列表格式可通过设置配置选项 rebase.instructionFormat 进行更改。 自定义的指令格式会自动在格式前加上长提交哈希值。</p>
</div>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase--r"> <a class="anchor" href="#git-rebase--r"></a>-r </dt>
<dt class="hdlist1" id="git-rebase---rebase-mergesrebase-cousinsno-rebase-cousins"> <a class="anchor" href="#git-rebase---rebase-mergesrebase-cousinsno-rebase-cousins"></a>--rebase-merges[=(rebase-cousins|no-rebase-cousins)] </dt>
<dt class="hdlist1" id="git-rebase---no-rebase-merges"> <a class="anchor" href="#git-rebase---no-rebase-merges"></a>--no-rebase-merges </dt>
<dd>
<p>默认情况下，变基操作会简单地从待办事项列表中删除合并提交，并将被重置的提交放入一个单一的线性分支中。 使用 <code>--rebase-merges</code> 后，变基操作会通过重新创建合并提交，尝试保留要被重置的提交中的分支结构。在这些合并提交中，任何已解决的合并冲突或手动修正都必须手动解决/重新应用。<code>--no-rebase-merges</code> 可以用来抵消 <code>rebase.rebaseMerges</code> 配置选项和之前的 `--rebase-merges 选项。</p>
<div class="paragraph">
<p>重定向合并时，有两种模式： <code>rebase-cousins</code> 和 <code>no-rebase-cousins</code>。如果未指定模式，则默认为 <code>no-rebase-cousins</code>。在 <code>no-rebase-cousins</code> 模式下，没有 <code>&lt;上游仓库&gt;</code> 作为直接祖先的提交将保留其原始分支点，也就是说，被 <a href='{{< relurl "docs/git-log/zh_HANS-CN" >}}'>git-log[1]</a> 的 <code>--ancestry-path</code> 选项排除在外的提交将默认保留其原始祖先。在 <code>rebase-cousins</code> 模式下，此类提交会被重定向到 <code>&lt;上游仓库&gt;</code>（或是`&lt;onto&gt;`，如果指定了）。</p>
</div>
<div class="paragraph">
<p>目前只能使用 <code>ort</code> 合并策略重新创建合并提交；只有通过明确的 <code>exec git merge -s &lt;strategy&gt; [...]</code> 命令才能使用不同的合并策略。</p>
</div>
<div class="paragraph">
<p>另请参阅下面的重置合并和不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase--xltgt"> <a class="anchor" href="#git-rebase--xltgt"></a>-x &lt;命令&gt; </dt>
<dt class="hdlist1" id="git-rebase---execltgt"> <a class="anchor" href="#git-rebase---execltgt"></a>--exec &lt;命令&gt; </dt>
<dd>
<p>在最终历史记录中创建提交的每一行后添加 "exec &lt;命令&gt;"。<code>&lt;命令&gt;</code> 将被解释为一个或多个 shell 命令。任何失败的命令都会中断重置，退出代码为 1。</p>
<div class="paragraph">
<p>您可以通过使用一个包含多个命令的 <code>--exec</code> 实例来执行多个命令：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase -i --exec "cmd1 &amp;&amp; cmd2 &amp;&amp; ..."</pre>
</div>
</div>
<div class="paragraph">
<p>或给出多个 <code>--exec</code>：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase -i --exec "cmd1" --exec "cmd2" --exec ...</pre>
</div>
</div>
<div class="paragraph">
<p>如果使用了 <code>--autosquash</code>，则不会为中间提交附加 <code>exec</code> 行，而只会出现在每个 squash/fixup 系列的末尾。</p>
</div>
<div class="paragraph">
<p>它在内部使用 <code>--interactive</code> 机制，但也可以在没有显式 <code>--interactive</code> 的情况下运行。</p>
</div>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---root"> <a class="anchor" href="#git-rebase---root"></a>--root </dt>
<dd>
<p>重置从 <code>&lt;分支&gt;</code> 到的所有提交，而不是用 <code>&lt;上游分支&gt;</code> 来限制它们。 这样就可以重定向分支上的根提交。</p>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---autosquash"> <a class="anchor" href="#git-rebase---autosquash"></a>--autosquash </dt>
<dt class="hdlist1" id="git-rebase---no-autosquash"> <a class="anchor" href="#git-rebase---no-autosquash"></a>--no-autosquash </dt>
<dd>
<p>自动将带有特殊格式信息的提交压制到正在重建的前提交中。如果提交信息以 "squash!"、"fixup!" 或 "amend!" 开头，则主题行的其余部分将作为提交说明符，如果与主题行或该提交的哈希值相匹配，则与之前的提交相匹配。如果没有完全匹配的提交，则会考虑与提交主题开头的指定符匹配。</p>
<div class="paragraph">
<p>在 rebase todo 列表中，squash、fixup 和 amend 提交的操作将分别从 <code>pick</code> 改为 <code>squash</code>、<code>fixup</code> 或 <code>fixup -C</code>，而且它们会被移到所修改的提交之后。在继续之前，可以使用 <code>--interactive</code> 选项查看和编辑待办事项列表。</p>
</div>
<div class="paragraph">
<p>建议使用 <a href='{{< relurl "docs/git-commit/zh_HANS-CN" >}}'>git-commit[1]</a> 的 <code>--squash</code>、<code>--fixup</code>、<code>--fixup=amend:</code> 或 <code>--fixup=reword:</code> 选项来创建带有压扁标记的提交。</p>
</div>
<div class="paragraph">
<p>Setting configuration variable <code>rebase.autoSquash</code> to true enables auto-squashing by default for interactive rebase. The <code>--no-autosquash</code> option can be used to override that setting.</p>
</div>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---autostash"> <a class="anchor" href="#git-rebase---autostash"></a>--autostash </dt>
<dt class="hdlist1" id="git-rebase---no-autostash"> <a class="anchor" href="#git-rebase---no-autostash"></a>--no-autostash </dt>
<dd>
<p>在操作开始前自动创建临时存储条目，并在操作结束后应用它。 这意味着你可以在脏工作树上运行变基操作。 不过，请谨慎使用：成功重储后的最终储藏应用可能会导致非实质性冲突。</p>
</dd>
<dt class="hdlist1" id="git-rebase---reschedule-failed-exec"> <a class="anchor" href="#git-rebase---reschedule-failed-exec"></a>--reschedule-failed-exec </dt>
<dt class="hdlist1" id="git-rebase---no-reschedule-failed-exec"> <a class="anchor" href="#git-rebase---no-reschedule-failed-exec"></a>--no-reschedule-failed-exec </dt>
<dd>
<p>自动重新安排执行失败的 <code>exec</code> 命令。这只有在交互模式下（或提供了 <code>--exec</code> 选项时）才有意义。</p>
<div class="paragraph">
<p>一旦启动变基程序，该选项就会生效。它会在整个变基过程和中保留，依次基于初始 <code>git rebase</code> 所提供的命令行选项、<code>rebase.rescheduleFailedExec</code> 配置（参见 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a> 或下文的“配置”），或者默认为 false。</p>
</div>
<div class="paragraph">
<p>为整个 rebase 记录该选项是为了方便起见。否则，当调用 <code>git rebase --continue</code> 时，在开始时显式的 <code>--no-reschedule-failed-exec</code> 会被 <code>rebase.rescheduleFailedExec=true</code> 配置覆盖。目前，不能向 <code>git rebase --continue</code> 传递 <code>--[no-]reschedule-failed-exec</code>。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase---update-refs"> <a class="anchor" href="#git-rebase---update-refs"></a>--update-refs </dt>
<dt class="hdlist1" id="git-rebase---no-update-refs"> <a class="anchor" href="#git-rebase---no-update-refs"></a>--no-update-refs </dt>
<dd>
<p>自动强制更新任何指向正在重定向的提交的分支。任何在工作区中签出的分支都不会以这种方式更新。</p>
<div class="paragraph">
<p>如果设置了配置变量 <code>rebase.updateRefs</code>, 则可使用此选项覆盖并禁用此设置。</p>
</div>
<div class="paragraph">
<p>另请参阅下面的不兼容选项。</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_不兼容选项"><a class="anchor" href="#_不兼容选项"></a>不兼容选项</h2>
<div class="sectionbody">
<div class="paragraph">
<p>下列选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>--apply</p>
</li>
<li>
<p>--whitespace</p>
</li>
<li>
<p>-C</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与下列选项不兼容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>--merge</p>
</li>
<li>
<p>--strategy</p>
</li>
<li>
<p>--strategy-option</p>
</li>
<li>
<p>--autosquash</p>
</li>
<li>
<p>--rebase-merges</p>
</li>
<li>
<p>--interactive</p>
</li>
<li>
<p>--exec</p>
</li>
<li>
<p>--no-keep-empty</p>
</li>
<li>
<p>--empty=</p>
</li>
<li>
<p>--[no-]reapply-cherry-picks when used without --keep-base</p>
</li>
<li>
<p>--update-refs</p>
</li>
<li>
<p>--root when used without --onto</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，以下几对选项是不兼容的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>--keep-base and --onto</p>
</li>
<li>
<p>--keep-base and --root</p>
</li>
<li>
<p>--fork-point and --root</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_行为差异"><a class="anchor" href="#_行为差异"></a>行为差异</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>git rebase</code> 有两个主要的后台：‘应用’ 和 ‘合并’（‘应用’ 后台曾被称为 <em>am</em> 后台，但这个名字看起来像动词而非名词，因此引起了混淆）。 此外，‘合并’ 后台曾被称为交互式后台，但现在也用于非交互式情况。 两者都是根据各自的底层功能重新命名的）。这两个后台在行为方式上有一些微妙的区别：</p>
</div>
<div class="sect2">
<h3 id="_空提交"><a class="anchor" href="#_空提交"></a>空提交</h3>
<div class="paragraph">
<p>不幸的是，‘应用’ 后台会丢弃故意为空的提交，即开始时为空的提交，不过这种情况在实践中并不多见。 它还会丢弃变为空的提交，而且没有控制这种行为的选项。</p>
</div>
<div class="paragraph">
<p>默认情况下，‘合并’ 后台会保留故意为空的提交（不过，如果使用 <code>-i</code> 选项，这些提交会在待办事项列表编辑器中标记为空，或者使用 <code>--no-keep-empty</code> 自动删除）。</p>
</div>
<div class="paragraph">
<p>Similar to the apply backend, by default the merge backend drops commits that become empty unless <code>-i</code>/<code>--interactive</code> is specified (in which case it stops and asks the user what to do). The merge backend also has an <code>--empty=(drop|keep|stop)</code> option for changing the behavior of handling commits that become empty.</p>
</div>
</div>
<div class="sect2">
<h3 id="_目录重命名检测"><a class="anchor" href="#_目录重命名检测"></a>目录重命名检测</h3>
<div class="paragraph">
<p>由于缺乏准确的目录树信息（利用补丁中的有限信息构建假祖先），‘应用’ 后台禁用了目录重命名检测。 禁用目录重命名检测意味着，如果历史记录的一方重命名了一个目录，而另一方在旧目录中添加了新文件，那么新文件就会被留在旧目录中，而不会在重新编排时发出任何警告，提醒您可能需要将这些文件移到新目录中。</p>
</div>
<div class="paragraph">
<p>目录重命名检测与 ‘合并’ 后台协同工作，在这种情况下会向你发出警告。</p>
</div>
</div>
<div class="sect2">
<h3 id="_上下文"><a class="anchor" href="#_上下文"></a>上下文</h3>
<div class="paragraph">
<p>‘应用’ 后台的工作方式是创建一系列补丁（在内部调用 <code>format-patch</code>），然后依次应用这些补丁（在内部调用 <code>am</code>）。 补丁由多个块组成，每个块包含行号、上下文区域和实际更改。 行号的获取必须谨慎，因为另一方很可能在文件中插入或删除了更早的行。 上下文区域的目的是帮助找到如何调整行号，以便将更改应用到正确的行上。 但是，如果代码的多个区域有相同的上下文行，就可能选错。 在现实世界中，这种情况曾导致提交被错误地重新应用，而没有报告任何冲突。 将 <code>diff.context</code> 设置为更大的值可能会避免此类问题，但会增加发生虚假冲突的几率（因为需要更多行匹配的上下文才能应用）。</p>
</div>
<div class="paragraph">
<p>‘合并’ 后台使用每个相关文件的完整副本，从而避免了此类问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_给冲突标记贴标签"><a class="anchor" href="#_给冲突标记贴标签"></a>给冲突标记贴标签</h3>
<div class="paragraph">
<p>当出现内容冲突时，合并机制会尝试在每一方的冲突标记上标注内容来源的提交。 由于 ‘应用’ 后台丢弃了关于重建的提交及其父提交的原始信息（而是根据生成的补丁中的有限信息生成新的假提交），因此无法识别这些提交，而只能使用提交摘要。 此外，当 <code>merge.conflictStyle</code> 设置为 <code>diff3</code> 或 <code>zdiff3</code> 时，‘应用’ 后端将使用 "constructed merge base"（构建的合并基础）来标注来自合并基础的内容，因此不会提供任何关于合并基础提交的信息。</p>
</div>
<div class="paragraph">
<p>‘合并’ 后台使用历史上双方的完整提交，因此没有这些限制。</p>
</div>
</div>
<div class="sect2">
<h3 id="_钩子"><a class="anchor" href="#_钩子"></a>钩子</h3>
<div class="paragraph">
<p>传统上，‘应用’ 后台并不调用提交后（post-commit）钩子，而 ‘合并’ 后台却调用了。 虽然 ‘合并’ 后台已取消了其输出，但两者都调用了检出后（post-checkout）钩子。 此外，这两个后端都只调用了变基操作的起点提交，而不是中间提交或最终提交的检出后（post-checkout）钩子。 在每种情况下，调用这些钩子都是偶然的，而不是设计出来的（两个后台最初都是以 shell 脚本的形式实现的，碰巧调用了其他会调用钩子的命令，如 <code>git checkout</code> 或 <code>git commit</code>）。 这两个后台应该具有相同的行为，但目前还不完全清楚哪一个才是正确的。 我们将来可能会让变基操作停止调用这些钩子。</p>
</div>
</div>
<div class="sect2">
<h3 id="_可中断性"><a class="anchor" href="#_可中断性"></a>可中断性</h3>
<div class="paragraph">
<p>如果用户在错误的时间按下 Ctrl-C 试图终止重置，重置就会进入无法通过后续的 <code>git rebase --abort</code> 终止的状态。 ‘合并’ 后台似乎不存在同样的缺陷。 (详见 <a href="https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/）" class="bare">https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/）</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_重写提交"><a class="anchor" href="#_重写提交"></a>重写提交</h3>
<div class="paragraph">
<p>当重建过程中发生冲突时，变基操作停止并要求用户解决。 由于用户可能需要在解决冲突的同时做一些显著的改动，因此在冲突解决且用户运行了 <code>git rebase --continue</code> 之后，变基时应打开一个编辑器并要求用户更新提交信息。 ‘合并’ 后台会这样做，而 ‘应用’ 后台则会盲目应用原始的提交信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_其他差异"><a class="anchor" href="#_其他差异"></a>其他差异</h3>
<div class="paragraph">
<p>还有一些行为上的差异，大多数人可能会认为无关紧要，但为了完整起见，还是要提一下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>引用日志： 两个后台在描述引用日志中的更改时会使用不同的措辞，但都会使用 “变基（rebase）” 一词。</p>
</li>
<li>
<p>进度、信息和错误信息： 两个后端提供的进度和信息略有不同。 此外，应用后端会将错误信息（如 “您的文件将被覆盖&#8230;&#8203;&#8230;&#8203;”）写入标准输出流，而合并后台则写入标准错误流。</p>
</li>
<li>
<p>状态目录：两个后台将状态保存在不同的目录中，分别位于`.git/`下</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_合并战略"><a class="anchor" href="#_合并战略"></a>合并战略</h2>
<div class="sectionbody">
<div class="paragraph">
<p>合并机制（ <code>git merge</code> 和 <code>git pull</code> 命令）允许用 <code>-s</code> 选项来选择后端&#8217;合并策略'。 一些策略也可以采取自己的选项，可以通过给 <code>git merge</code> 和/或 <code>git pull</code> 的 <code>-X&lt;选项&gt;</code> 参数来传递。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase-ort"> <a class="anchor" href="#git-rebase-ort"></a>ort 策略 </dt>
<dd>
<p>这是拉取或合并一个分支时的默认合并策略。 这个策略只能使用三方合并算法解决两个头。 当有一个以上的共同祖先可用于三方合并时，它会创建一个共同祖先的合并树，并将其作为三方合并的参考树。 据报道，通过对Linux 2.6内核开发历史中的实际合并提交的测试，这导致了较少的合并冲突，而不会引起错误的合并。 此外，这个策略可以检测并处理涉及重命名的合并。 它并不使用检测到的副本。 这个算法的名字是一个缩写（"Ostensibly Recursive&#8217;s Twin"），来自于它是作为以前的默认算法`recursive`的替代而编写的。</p>
<div class="paragraph">
<p><em>ort</em> 策略可以采取以下选项：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase-ours"> <a class="anchor" href="#git-rebase-ours"></a>ours </dt>
<dd>
<p>这个选项通过倾向于 "我们" 的版本，迫使冲突的猎物被自动解决。 另一棵目录树上与我们这边不冲突的变化会反映在合并结果中。 对于一个二进制文件，整个内容都来自我们这边。</p>
<div class="paragraph">
<p>这不应该与 "我们的" 合并策略相混淆，后者甚至根本不看另一棵目录树包含了什么。 它抛弃了其他树所做的一切，宣布 "我们的" 历史包含了其中所发生的一切。</p>
</div>
</dd>
<dt class="hdlist1" id="git-rebase-theirs"> <a class="anchor" href="#git-rebase-theirs"></a>theirs </dt>
<dd>
<p>这与 "我们的" 相反；注意，与 "我们的" 不同，没有 "他们的" 合并策略来混淆这个合并选项。</p>
</dd>
<dt class="hdlist1" id="git-rebase-ignore-space-change"> <a class="anchor" href="#git-rebase-ignore-space-change"></a>ignore-space-change </dt>
<dt class="hdlist1" id="git-rebase-ignore-all-space"> <a class="anchor" href="#git-rebase-ignore-all-space"></a>ignore-all-space </dt>
<dt class="hdlist1" id="git-rebase-ignore-space-at-eol"> <a class="anchor" href="#git-rebase-ignore-space-at-eol"></a>ignore-space-at-eol </dt>
<dt class="hdlist1" id="git-rebase-ignore-cr-at-eol"> <a class="anchor" href="#git-rebase-ignore-cr-at-eol"></a>ignore-cr-at-eol </dt>
<dd>
<p>为了进行三方合并，将具有指定类型的空白变化的行视为没有变化。 但混合了其他改动的行的空白改动不会被忽略。 参见<a href='{{< relurl "docs/git-diff/zh_HANS-CN" >}}'>git-diff[1]</a> <code>-b</code>, <code>-w</code>, <code>--ignore-space-at-eol</code>, 和 <code>--ignore-cr-at-eol</code>。</p>
<div class="ulist">
<ul>
<li>
<p>如果 "他们的" 版本只在一行中引入了空白的变化，则使用 "我们的" 版本；</p>
</li>
<li>
<p>如果 "我们的" 版本引入了空白的变化，但 "他们的" 版本包括一个实质性的变化，则使用 "他们的" 版本;</p>
</li>
<li>
<p>否则，合并将以常规方式进行。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1" id="git-rebase-renormalize"> <a class="anchor" href="#git-rebase-renormalize"></a>renormalize </dt>
<dd>
<p>在解决三方合并时，这将对一个文件的所有三个阶段运行虚拟检出和检入。 这个选项是为了在合并具有不同清洁过滤器或行末规范化规则的分支时使用。 详情见 <a href='{{< relurl "docs/gitattributes/zh_HANS-CN" >}}'>gitattributes[5]</a> 中的 "合并具有不同检入/检出属性的分支"。</p>
</dd>
<dt class="hdlist1" id="git-rebase-no-renormalize"> <a class="anchor" href="#git-rebase-no-renormalize"></a>no-renormalize </dt>
<dd>
<p>禁用 <code>renormalize</code> 选项。 这覆盖了 <code>merge.renormalize</code> 配置变量。</p>
</dd>
<dt class="hdlist1" id="git-rebase-find-renamesltngt"> <a class="anchor" href="#git-rebase-find-renamesltngt"></a>find-renames[=&lt;n&gt;] </dt>
<dd>
<p>开启重名检测，可选择设置相似度阈值。 这是默认的。这覆盖了 <em>merge.renames</em> 配置变量。 参见<a href='{{< relurl "docs/git-diff/zh_HANS-CN" >}}'>git-diff[1]</a> <code>--find-renames</code>。</p>
</dd>
<dt class="hdlist1" id="git-rebase-rename-thresholdltngt"> <a class="anchor" href="#git-rebase-rename-thresholdltngt"></a>rename-threshold=&lt;n&gt; </dt>
<dd>
<p>废弃的，<code>find-renames=&lt;n&gt;</code> 的同义词。</p>
</dd>
<dt class="hdlist1" id="git-rebase-subtreeltgt"> <a class="anchor" href="#git-rebase-subtreeltgt"></a>subtree[=&lt;路径&gt;] </dt>
<dd>
<p>这个选项是 <em>子树</em> 策略的更高级形式，该策略对两棵树在合并时必须如何移位以相互匹配进行猜测。 相反，指定的路径是前缀（或从开始剥离），以使两棵树的形状相匹配。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-rebase-recursive"> <a class="anchor" href="#git-rebase-recursive"></a>recursive </dt>
<dd>
<p>这只能用三方合并算法解决两个头。 当有一个以上的共同祖先可用于三方合并时，它会创建一个共同祖先的合并树，并使用它作为三方合并的参考树。 据报道，通过对Linux 2.6内核开发历史中的实际合并提交的测试，这导致了较少的合并冲突，而不会引起错误的合并。 此外，它可以检测并处理涉及重命名的合并。 它并不使用检测到的副本。 从Git v0.99.9k到v2.33.0，这是解决双头的默认策略。</p>
<div class="paragraph">
<p><em>recursive</em> 策略采用与 <em>ort</em> 相同的选项。 然而，有三个 <em>ort</em> 忽略的额外选项（上面没有记录），对 <em>recursive</em> 策略有潜在的作用：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase-patience"> <a class="anchor" href="#git-rebase-patience"></a>patience </dt>
<dd>
<p>废弃的，<code>diff-algorithm=patience</code> 的同义词。</p>
</dd>
<dt class="hdlist1" id="git-rebase-diff-algorithmpatienceminimalhistogrammyers"> <a class="anchor" href="#git-rebase-diff-algorithmpatienceminimalhistogrammyers"></a>diff-algorithm=[patience|minimal|histogram|myers] </dt>
<dd>
<p>在合并时使用不同的差异算法，这可以帮助避免由于不重要的匹配行（比如不同函数的大括号）而发生的错误合并。 参见<a href='{{< relurl "docs/git-diff/zh_HANS-CN" >}}'>git-diff[1]</a> <code>--diff-algorithm</code>。 注意，<code>ort</code> 特定 <code>diff-algorithm=histogram</code>，而`recursive`默认为`diff.algorithm`配置设置。</p>
</dd>
<dt class="hdlist1" id="git-rebase-no-renames"> <a class="anchor" href="#git-rebase-no-renames"></a>no-renames </dt>
<dd>
<p>关闭重名检测。这覆盖了 <code>merge.renames</code> 的配置变量。 参见<a href='{{< relurl "docs/git-diff/zh_HANS-CN" >}}'>git-diff[1]</a> <code>--no-renames</code>。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-rebase-resolve"> <a class="anchor" href="#git-rebase-resolve"></a>resolve </dt>
<dd>
<p>这只能用三方合并算法解决两个头（即当前分支和你拉来的另一个分支）。 它试图仔细检测纵横交错的合并歧义。 它不处理重名。</p>
</dd>
<dt class="hdlist1" id="git-rebase-octopus"> <a class="anchor" href="#git-rebase-octopus"></a>octopus </dt>
<dd>
<p>这可以解决有两个以上头的情况，但拒绝做复杂的合并，需要手动解决。 它主要是用于将主题分支头捆绑在一起。 当拉动或合并一个以上的分支时，这是默认的合并策略。</p>
</dd>
<dt class="hdlist1" id="git-rebase-ours-1"> <a class="anchor" href="#git-rebase-ours-1"></a>ours </dt>
<dd>
<p>这可以解决任何数量的头，但合并的结果总是当前分支头的树，有效地忽略了所有其他分支的变化。 它是用来取代侧边分支的旧开发历史的。 注意，这与 <em>recursive</em> 合并策略的-Xours选项不同。</p>
</dd>
<dt class="hdlist1" id="git-rebase-subtree"> <a class="anchor" href="#git-rebase-subtree"></a>subtree </dt>
<dd>
<p>这是一个修正的 <code>ort</code> 策略。当合并树A和B时，如果B对应于A的子树，B首先被调整为与A的树结构相匹配，而不是在同一级别读取树。这种调整也是针对共同祖先树进行的。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>对于使用三方合并的策略（包括默认的 <em>ort</em> 策略），如果在两个分支上都做了修改，但后来在其中一个分支上被撤销，那么这个修改就会出现在合并后的结果中；有些人觉得这种行为令人困惑。 出现这种情况是因为在执行合并时只考虑头部和合并基数，而不是单个提交。 因此，合并算法认为被恢复的修改根本就没有变化，而是用被修改的版本来代替。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_注释"><a class="anchor" href="#_注释"></a>注释</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您应该了解在共享的版本库中使用 <code>git rebase</code> 的影响。 另请参阅下面的从上游重建中恢复。</p>
</div>
<div class="paragraph">
<p>在运行变基命令时，如果存在 <code>pre-rebase</code> （变基前）钩子，它会首先执行该钩子。 您可以使用此钩子进行正确性检查，并在不合适时拒绝重置。 有关示例，请参阅模板 <code>pre-rebase</code>（变基前） 钩子脚本。</p>
</div>
<div class="paragraph">
<p>完成后，<code>&lt;分支&gt;</code> 将成为当前分支。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_交互模式"><a class="anchor" href="#_交互模式"></a>交互模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>交互式重定向意味着你有机会编辑被重定向的提交。 你可以重新排列提交的顺序，也可以删除它们（剔除坏的或不需要的补丁）。</p>
</div>
<div class="paragraph">
<p>互动模式就是为这种工作流程设计的：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>灵机一动</p>
</li>
<li>
<p>敲代码</p>
</li>
<li>
<p>编写提交系列</p>
</li>
<li>
<p>提交</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>其中第 2 点由以下几个实例组成</p>
</div>
<div class="paragraph">
<p>a) 常规使用</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>完成值得提交的事情</p>
</li>
<li>
<p>提交</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>b) 独立修复</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>发现有什么东西没有用</p>
</li>
<li>
<p>解决这个问题</p>
</li>
<li>
<p>提交</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>有时，b.2.中修正的内容无法修正到它所修正的并不完美的提交中，因为该提交深埋在一系列补丁中。 这正是交互式变基的用途：在大量的 "a" 和 "b" 之后使用它，重新排列和编辑提交，将多个提交合并为一个提交。</p>
</div>
<div class="paragraph">
<p>从您希望保留原样的最后一次提交开始：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git rebase -i &lt;本次提交后&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>编辑器会弹出当前分支的所有提交（忽略合并提交），这些提交都在给定提交之后。 你可以随心所欲地调整列表中提交的顺序，也可以删除它们。 列表大致如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>选择 deadbee ，本次提交的上线
选中 fa1afe1 ，下一次提交的上线
...</pre>
</div>
</div>
<div class="paragraph">
<p>上线描述纯粹是为了方便您查看；<em>git rebase</em> 不会查看这些描述，只会查看提交名称（本例中为 "deadbee" 和 "fa1afe1"），因此请勿删除或编辑这些名称。</p>
</div>
<div class="paragraph">
<p>用 "edit" 命令替换 "pick" 命令后，你可以告诉 <code>git rebase</code> 在应用该提交后停止，这样你就可以编辑文件和/或提交信息，修改提交，然后继续重置。</p>
</div>
<div class="paragraph">
<p>要中断重置（就像 "edit" 命令一样，但不会先选择任何提交），请使用 "break "命令。</p>
</div>
<div class="paragraph">
<p>如果只想编辑提交信息，请用 "reword" 命令替换 "pick" 命令。</p>
</div>
<div class="paragraph">
<p>要放弃提交，请用 "drop" 替换 "pick" 命令，或直接删除匹配的行。</p>
</div>
<div class="paragraph">
<p>如果要将两个或更多提交折叠为一个提交，请用 "squash" 或 "fixup" 代替命令 "pick" 来处理第二个及后续提交。 如果提交的作者不同，折叠后的提交将归属于第一个提交的作者。 除非使用了 "fixup -c" 命令，否则折叠提交的建议提交信息是第一个提交信息与 "squash" 命令确定的提交信息的合并，省略了 "fixup" 命令确定的提交信息。 在这种情况下，建议的提交信息只是 "fixup -c" 提交的信息，而且会打开一个编辑器允许你编辑信息。 "fixup -c" 提交的内容（补丁）仍然包含在折叠提交中。如果有多个 "fixup -c" 提交，则使用最后一个提交的信息。 您也可以使用 "fixup -C" 获得与 "fixup -c" 相同的效果，但不需要打开编辑器。</p>
</div>
<div class="paragraph">
<p>当 "pick" 命令被替换为 "编辑" 命令或命令因合并错误而失败时，<code>git rebase</code> 将停止。完成编辑和/或解决冲突后，可以使用 <code>git rebase --continue</code> 继续。</p>
</div>
<div class="paragraph">
<p>例如，如果您想重新排列最近 5 次提交的顺序，让原来的 <code>HEAD~4</code> 变成新的 <code>HEAD</code>。要做到这一点，可以这样调用 <code>git rebase</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git rebase -i HEAD~5</pre>
</div>
</div>
<div class="paragraph">
<p>并将第一个补丁移到列表末尾。</p>
</div>
<div class="paragraph">
<p>例如，如果您有这样的历史记录，您可能需要重新创建合并提交：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>           X
            \
         A---M---B
        /
---o---O---P---Q</pre>
</div>
</div>
<div class="paragraph">
<p>假设要将从 "A" 开始的侧分支重置为 "Q"。确保当前的 <code>HEAD</code> 是 "B"，然后调用</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git rebase -i -r --onto Q O</pre>
</div>
</div>
<div class="paragraph">
<p>重新排序和编辑提交通常会产生未经测试的中间步骤。 您可能想通过运行测试来检查您的历史编辑是否破坏了任何东西，或者至少使用 "exec" 命令（快捷键 "x"）在历史的中间点重新编译。 为此，您可以创建类似这样的待办事项列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>选择 deadbee 执行功能 XXX
修复 f1a5c00 修复功能 XXX
执行 make
选取 c0ffeee 下一次提交的上线
编辑 deadbab 之后提交的上线
exec cd subdir; make test
...</pre>
</div>
</div>
<div class="paragraph">
<p>当命令失败（即以非 0 状态退出）时，交互式变基操作就会停止，以便您有机会解决问题。您可以使用 <code>git rebase --continue</code> 继续。</p>
</div>
<div class="paragraph">
<p>"exec" 命令在 shell（默认的 shell，通常是/bin/sh）中执行命令，因此可以使用 shell 功能（如 "cd"、"&gt;"、";"&#8230;&#8203;&#8230;&#8203;）。命令从工作目录树的根目录运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git rebase -i --exec "make test"</pre>
</div>
</div>
<div class="paragraph">
<p>该命令用于检查中间提交是否可编译。 待办事项列表就会变成这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>选择 5928aea one
exec make test
选 04d0fda 二
exec make test
选择 ba46169 三
执行制作测试
选择 f4593F9 四
exec make test</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_拆分提交"><a class="anchor" href="#_拆分提交"></a>拆分提交</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在交互模式下，可以用 "edit"（编辑）来标记提交。 不过，这并不一定意味着 <code>git rebase</code> 希望编辑的结果是一个提交。 事实上，你可以撤销提交，也可以添加其他提交。 这可以用来将一个提交一分为二：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 <code>git rebase -i &lt;提交&gt;^</code> 开始交互式变基，其中 `&lt;提交&gt;`是要分割的提交。 事实上，只要包含该提交，任何提交范围都可以。</p>
</li>
<li>
<p>用 "edit" 操作标记要分割的提交。</p>
</li>
<li>
<p>在编辑该提交时，执行 <code>git reset HEAD^</code>。 其效果是将 <code>HEAD</code> 重绕一圈，索引也跟着重绕一圈。 但工作区保持不变。</p>
</li>
<li>
<p>现在，将您希望在第一次提交中的改动添加到索引中。 你可以使用 <code>git add</code> （可能是交互式的）或 <code>git gui</code> （或两者）来完成。</p>
</li>
<li>
<p>以任何合适的提交信息提交当前索引。</p>
</li>
<li>
<p>重复最后两个步骤，直到工作区干净为止。</p>
</li>
<li>
<p>使用 <code>git rebase --continue</code> 继续变基。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果不能绝对确定中间修订是一致的（编译、通过 testsuite 等），则应使用 <code>git stash</code> 在每次提交、测试之后，将尚未提交的改动保存起来，并在必要时修改提交。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_从上有仓库变基中恢复"><a class="anchor" href="#_从上有仓库变基中恢复"></a>从上有仓库变基中恢复</h2>
<div class="sectionbody">
<div class="paragraph">
<p>变基（或以任何其他形式改写）他人基于其工作的分支是个坏主意：其下游的任何人都不得不手动修正自己的历史。 本节将从下游的角度解释如何进行修复。 不过，真正的修复方法是首先避免重置上游分支。</p>
</div>
<div class="paragraph">
<p>举例说明，假设有人开发了一个 ‘子系统’ 分支，而你正在开发一个依赖于该 ‘子系统’ 的 ‘主题’。 你可能会有如下的历史记录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o---o---o---o  master
	 \
	  o---o---o---o---o  subsystem
			   \
			    *---*---*  topic</pre>
</div>
</div>
<div class="paragraph">
<p>如果 ‘子系统’ 针对 <em>master</em> 进行重定向，会出现以下情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o---o---o---o  master
	 \			 \
	  o---o---o---o---o	  o'--o'--o'--o'--o'  subsystem
			   \
			    *---*---*  topic</pre>
</div>
</div>
<div class="paragraph">
<p>如果现在像往常一样继续开发，并最终将 ‘主题’ 合并到 ‘子系统’，那么 ‘子系统’ 中的提交将永远重复：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    o---o---o---o---o---o---o---o  master
	 \			 \
	  o---o---o---o---o	  o'--o'--o'--o'--o'--M	 subsystem
			   \			     /
			    *---*---*-..........-*--*  topic</pre>
</div>
</div>
<div class="paragraph">
<p>这种重复通常是不受欢迎的，因为它们会使历史记录变得杂乱无章，难以跟踪。 要清理这些重复提交，就需要将 ‘主题’ 上的提交移植到新的 ‘子系统’ tip 上，即重置 ‘主题’。 这就会产生连锁反应：‘主题’ 的任何下游提交都会被迫重置，依此类推！</p>
</div>
<div class="paragraph">
<p>有两种修复方法，将在下面的小节中讨论：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rebase--1-1"> <a class="anchor" href="#git-rebase--1-1"></a>简单的例子： 变化完全相同。 </dt>
<dd>
<p>如果 ‘子系统’ 变基是简单的重置，没有冲突，就会出现这种情况。</p>
</dd>
<dt class="hdlist1" id="git-rebase--1-1-1"> <a class="anchor" href="#git-rebase--1-1-1"></a>较难的例子： 变化不一样。 </dt>
<dd>
<p>如果 ‘子系统’ 变基有冲突，或者使用了 <code>--interactive</code> 来省略、编辑、压制或修复提交，或者上游使用了 <code>commit --amend</code>, <code>reset</code> 或完整历史重写命令（如 <a href="https://github.com/newren/git-filter-repo"><code>filter-repo</code></a>），就会发生这种情况。</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_简单案例"><a class="anchor" href="#_简单案例"></a>简单案例</h3>
<div class="paragraph">
<p>只有当 ‘子系统’ 上的更改（基于差异内容的补丁 ID）在 ‘子系统’ 变基前后完全相同时才有效。</p>
</div>
<div class="paragraph">
<p>在这种情况下，修复就很简单了，因为 <em>git rebase</em> 知道跳过新上游中已经存在的改动（除非给出 <code>--reapply-cherry-picks</code> 选项）。所以，如果你说（假设你在 ‘主题’ 分支上）</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    $ git rebase subsystem</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_您将获得固定的历史记录"><a class="anchor" href="#_您将获得固定的历史记录"></a>您将获得固定的历史记录</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre>o---o---o---o---o---o---o---o  master
 \
  o'--o'--o'--o'--o'  subsystem
		   \
		    *---*---*  topic</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>困难的例子
~~~~~

如果 ‘子系统’ 的变化与重置前的变化不完全一致，情况就会变得更加复杂。

NOTE: 虽然 ‘简单恢复案例’ 有时看似成功
      即使在疑难案件中，也可能产生意想不到的后果。
      例如，通过 `git rebase
      --interactive` 删除的提交将被**恢复**！

我们的想法是手动告诉 `git rebase` “旧的 ‘子系统’ 分支在哪里结束，而您的 ‘主题’ 分支在哪里开始”，也就是说，它们之间的旧合并基础是什么。 例如，你必须找到一种方法来命名旧 ‘子系统’ 分支的最后一次提交：

* 使用 ‘子系统’ 引用日志：在 `git fetch` 之后，‘子系统’ 的旧 tip 位于 `subsystem@{1}`。 随后的获取将增加这个数字。 (参见 <a href='{{< relurl "docs/git-reflog/zh_HANS-CN" >}}'>git-reflog[1]</a>）

* 与 ‘主题’ 分支的 tip 有关：由于 ‘topic’ 分支有三次提交，所以 ‘子系统’ 分支的旧提示必须是 `topic~3`。

然后，您可以将旧的 `subsystem..topic`（子系统..主题）移植到新的提示中，方法是（对于引用日志的情况，假设您已经在 ‘主题’ 分支中）：</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git rebase --onto subsystem subsystem@{1}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>“困难例子” 恢复的连锁反应尤其糟糕：‘主题’ 下游的 ‘每个人’ 现在也必须执行 “困难例子” 恢复！

变基合并
----

交互式变基命令最初是为处理单个补丁系列而设计的。因此，将合并提交排除在待办事项列表之外是有道理的，因为开发人员在分支上工作时，可能已经合并了当时的 `master`，只是最终将所有提交重置到了 `master`上（跳过了合并提交）。

不过，开发人员想要重新创建合并提交也有合理的原因：在多个相互关联的分支上工作时，为了保持分支结构（或 “提交拓扑”）。

在下面的示例中，开发人员在一个重构了按钮定义方式的特性分支上工作，并在另一个特性分支上使用重构实现了 “报告错误” 按钮。`git log --graph --format=%s -5` 的输出可能是这样的：</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>合并分支 <em>report-a-bug</em>
|\
| * 添加反馈按钮</p>
</li>
<li>
<p>| 合并分支 <em>refactor-button</em>
|\ \
| |/
| * 为所有的按钮使用 Button 类
| * 从 DownloadButton 类中提取一个通用 Button 类</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>开发人员可能希望在保留分支拓扑的同时，将这些提交重定向到更新的 `master` 分支，例如，当第一个特性分支比第二个分支更早集成到 `master` 分支时，开发人员可能希望解决与 “下载按钮” 类的合并冲突，因为 “下载按钮” 类已经集成到了 `master` 分支。

可以使用 `--rebase-merges` 选项进行重置。 它将生成如下的待办事项列表：</pre>
</div>
</div>
<div class="paragraph">
<p>标签上的</p>
</div>
</div>
</div>
<h1 id="_分支重构按钮" class="sect0"><a class="anchor" href="#_分支重构按钮"></a>分支：重构按钮</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>重置到
选 123456 从下载按钮类中提取一个通用按钮类
选取 654321 对所有按钮使用按钮类
label refactor-button（重构按钮）</p>
</div>
</div>
</div>
<h1 id="_分支报告一个错误" class="sect0"><a class="anchor" href="#_分支报告一个错误"></a>分支：报告一个错误</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>reset refactor-button （重构按钮）# 所有按钮都使用按钮类
pick abcdef 添加反馈按钮
label report-a-bug（报告一个错误）</p>
</div>
<div class="paragraph">
<p>重置到
merge -C a1b2c3 refactor-button # 合并 “重构按钮”
merge -C 6f5e4d report-a-bug # 合并 “报告一个错误”</p>
</div>
<div class="listingblock">
<div class="content">
<pre>与常规的交互式变基不同，除了 `pick`（选取）命令外，还有 `label`（标签）、`reset`（重置） 和 `merge`（合并） 命令。

`label` 命令会在执行该命令时将一个标签与当前 HEAD 关联。这些标签被创建为工作树本地引用（`refs/rewritten/&lt;label&gt;`），并将在重置完成后被删除。这样，链接到同一仓库的多个工作树中的重置操作就不会相互干扰。如果 `label` 命令失败，会立即重新安排，并给出如何继续的提示信息。

`reset` 命令会将 HEAD、索引和工作树重置为指定的版本。它类似于 `exec git reset --hard &lt;label&gt;`，但拒绝覆盖未跟踪的文件。如果 `reset` 命令失败，会立即重新安排，并附带如何编辑待办事项列表的提示信息（这种情况通常发生在 `reset` 命令被手动插入待办事项列表且包含错字的情况下）。

`merge`（合并）命令会将指定的版本合并到当时的 HEAD 中。使用 `-C &lt;源提交&gt;` 时，将使用指定合并提交的提交信息。如果将 `-C` 改为小写的 `-c`，合并成功后，提交信息将在编辑器中打开，以便用户编辑信息。

如果 `merge`（合并）命令因合并冲突以外的任何原因失败（即合并操作甚至没有开始），则会立即重新安排。

默认情况下，`merge`（合并）命令将对常规合并使用 `ort ` 合并策略，对多路合并使用 `octopus` 合并策略。 我们可以在调用变基命令时使用 `--strategy` 参数为所有合并指定一个默认策略，也可以在交互式命令列表中使用 `exec` 命令显式地调用 `git merge` 并加上 `--strategy` 参数来覆盖特定的合并策略。 需要注意的是，像这样显式调用 `git merge` 时，可以利用标签是工作区本地引用（例如，引用 `refs/rewritten/onto` 将对应标签 `onto`）这一事实来引用要合并的分支。

注意：第一条命令（`label onto`）会标注提交所基于的修订版本；`onto ` 只是一个约定俗成的名称，是对 `--onto` 选项的一种提示。

也可以通过添加 `merge &lt;合并起点&gt;` 命令，从头开始引入全新的合并提交。这种形式会生成暂定提交信息，并始终打开编辑器让用户编辑。例如，当一个特性分支要解决的问题不止一个，需要拆分成两个甚至更多特性分支时，这个命令就很有用。请看这个待办事项列表：</pre>
</div>
</div>
<div class="paragraph">
<p>pick 192837 从 GNU Makefiles 切换到 CMake
pick 5a6c7e 记录切换到 CMake 的过程
pick 918273 修复 CMake 中的 OpenSSL 检测问题
pick afbecd http：添加对 TLS v1.3 的支持
pick fdbaec 在 Windows 上修复 CMake 对 cURL 的检测</p>
</div>
<div class="listingblock">
<div class="content">
<pre>该列表中与 CMake 无关的一个提交很可能是为了修复所有因改用 CMake 而引入的错误，但它解决的是另一个问题。要把这个分支分成两个主题分支，可以这样编辑待办事项列表：</pre>
</div>
</div>
<div class="paragraph">
<p>标签上的</p>
</div>
<div class="paragraph">
<p>选择 afbecd http：添加对 TLS v1.3 的支持
label tlsv1.3</p>
</div>
<div class="paragraph">
<p>reset onto
pick 192837 从 GNU Makefiles 切换到 CMake
pick 918273 修复 CMake 中的 OpenSSL 检测问题
pick fdbaec 在 Windows 上修复 CMake 对 cURL 的检测
pick 5a6c7e 记录切换到 CMake 的过程
label cmake</p>
</div>
<div class="paragraph">
<p>reset onto
merge tlsv1.3
merge cmake</p>
</div>
<div class="listingblock">
<div class="content">
<pre>配置
--



[WARNING]
====
Missing `zh_HANS-CN/includes/cmd-config-section-all.txt`

See original version for this content.
====

[]



[WARNING]
====
Missing `zh_HANS-CN/config/rebase.txt`

See original version for this content.
====

[]


[WARNING]
====
Missing `zh_HANS-CN/config/sequencer.txt`

See original version for this content.
====

[]

GIT
---
属于 <a href='{{< relurl "docs/git/zh_HANS-CN" >}}'>git[1]</a> 文档</pre>
</div>
</div>
</div>
</div>