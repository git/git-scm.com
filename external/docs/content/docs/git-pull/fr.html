---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-pull Documentation
docname: git-pull
lang: fr
aliases:
- "/docs/git-pull/fr/index.html"
---
<div class="sect1">
<h2 id="_nom"><a class="anchor" href="#_nom"></a>NOM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-pull - Rapatrier et intégrer un autre dépôt ou une branche locale</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_synopsis"><a class="anchor" href="#_synopsis"></a>SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git pull</em> [&lt;options&gt;] [&lt;dépôt&gt; [&lt;spécification-de-référence&gt;&#8230;&#8203;]]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description"><a class="anchor" href="#_description"></a>DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Incorpore les modifications d&#8217;un dépôt distant dans la branche courante. Si la branche courante est en retard par rapport à la branche distante, alors par défaut, cela avancera rapidement la branche courante pour correspondre à la branche distante. Si la branche courante et le dépôt distant ont divergé, l&#8217;utilisateur doit spécifier comment réconcilier les branches divergentes avec <code>--rebase</code> ou <code>--no-rebase</code> (ou l&#8217;option de configuration correspondante dans <code>pull.rebase</code>).</p>
</div>
<div class="paragraph">
<p>Plus précisément, <code>git pull</code> exécute <code>git fetch</code> avec les paramètres donnés et ensuite, selon les options de configuration ou les drapeaux de la ligne de commande, appellera soit <code>git rebase</code> soit <code>git merge</code> pour réconcilier les branches divergentes.</p>
</div>
<div class="paragraph">
<p>&lt;dépôt&gt; doit être le nom d&#8217;un dépôt distant tel que passé à <a href='{{< relurl "docs/git-fetch/fr" >}}'>git-fetch[1]</a>. &lt;spéc-de-réf&gt; peut nommer une réf distante arbitraire (par exemple, le nom d&#8217;une étiquette) ou même une collection de réfs avec les branches de suivi à distance correspondantes (par exemple, refs/heads/*:refs/remotes/origin/*), mais c&#8217;est généralement le nom d&#8217;une branche du dépôt distant.</p>
</div>
<div class="paragraph">
<p>Les valeurs par défaut pour &lt;dépôt&gt; et &lt;branche&gt; sont lues à partir de la configuration "remote" et "merge" pour la branche actuelle comme défini par <a href='{{< relurl "docs/git-branch/fr" >}}'>git-branch[1]</a> <code>--track</code>.</p>
</div>
<div class="paragraph">
<p>Supposons que l&#8217;historique suivant existe et que la branche actuelle est <code>master</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  A---B---C master sur origin
	 /
    D---E---F---G master
	^
	origin/master dans votre dépôt</pre>
</div>
</div>
<div class="paragraph">
<p>Ensuite, "<code>git pull</code>" récupère et rejoue les modifications de la branche <code>master</code> distante, puisqu&#8217;elle a divergé du <code>master</code> local (c&#8217;est-à-dire <code>E</code>) jusqu&#8217;à son commit actuel (<code>C</code>) en plus de <code>master</code> et enregistre le résultat dans un nouveau commit avec les noms des deux commits parents et un message de journal de l&#8217;utilisateur décrivant les modifications.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  A---B---C origin/master
	 /         \
    D---E---F---G---H master</pre>
</div>
</div>
<div class="paragraph">
<p>Voir <a href='{{< relurl "docs/git-merge/fr" >}}'>git-merge[1]</a> pour plus de détails, notamment sur la manière dont les conflits sont présentés et traités.</p>
</div>
<div class="paragraph">
<p>Dans Git 1.7.0 ou une version ultérieure, pour annuler une fusion conflictuelle, utilisez <code>git reset --merge</code>. <strong>Avertissement</strong> : dans les anciennes versions de Git, il est déconseillé d&#8217;exécuter <em>git pull</em> avec des modifications non validées : bien que cela soit possible, cela vous laisse dans un état dont il peut être difficile de se défaire en cas de conflit.</p>
</div>
<div class="paragraph">
<p>Si l&#8217;une des modifications sur le distant chevauche des modifications locales non validées, la fusion sera automatiquement annulée et l&#8217;arbre de travail sera conservé. Il est généralement préférable de mettre les modifications locales en ordre de marche ou de les remiser avec <a href='{{< relurl "docs/git-stash/fr" >}}'>git-stash[1]</a> avant de tirer.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_options"><a class="anchor" href="#_options"></a>OPTIONS</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull--q"> <a class="anchor" href="#git-pull--q"></a>-q </dt>
<dt class="hdlist1" id="git-pull---quiet"> <a class="anchor" href="#git-pull---quiet"></a>--quiet </dt>
<dd>
<p>Ceci est transmis à la fois au git-fetch sous-jacent pour éliminer les rapports lors du transfert et au git-merge sous-jacent pour éliminer les rapports lors de la fusion.</p>
</dd>
<dt class="hdlist1" id="git-pull--v"> <a class="anchor" href="#git-pull--v"></a>-v </dt>
<dt class="hdlist1" id="git-pull---verbose"> <a class="anchor" href="#git-pull---verbose"></a>--verbose </dt>
<dd>
<p>Passer --verbose à git-fetch et git-merge.</p>
</dd>
<dt class="hdlist1" id="git-pull---no-recurse-submodulesyeson-demandno"> <a class="anchor" href="#git-pull---no-recurse-submodulesyeson-demandno"></a>--[no-]recurse-submodules[=(yes|on-demand|no)] </dt>
<dd>
<p>Cette option contrôle si les nouveaux commits des sous-modules peuplés doivent être récupérés et si les arbres de travail des sous-modules actifs devraient être aussi mis à jour (voir <a href='{{< relurl "docs/git-fetch/fr" >}}'>git-fetch[1]</a>, <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a> et <a href='{{< relurl "docs/gitmodules/fr" >}}'>gitmodules[5]</a>).</p>
<div class="paragraph">
<p>Si l&#8217;extraction est effectuée via un rebasage, les commits des sous-module locaux sont également rebasés.</p>
</div>
<div class="paragraph">
<p>Si la mise à jour est effectuée par fusion, les conflits de sous-module sont résolus et extraits.</p>
</div>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_options_relatives_à_la_fusion"><a class="anchor" href="#_options_relatives_à_la_fusion"></a>Options relatives à la fusion</h3>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull---commit"> <a class="anchor" href="#git-pull---commit"></a>--commit </dt>
<dt class="hdlist1" id="git-pull---no-commit"> <a class="anchor" href="#git-pull---no-commit"></a>--no-commit </dt>
<dd>
<p>Effectuer la fusion et valider le résultat. Cette option peut être utilisée pour passer outre --no-commit.
Seulement utile lors de la fusion.</p>
<div class="paragraph">
<p>Avec --no-commit, effectuer la fusion et s&#8217;arrêter juste avant de créer un commit de fusion, pour donner à l&#8217;utilisateur une chance d&#8217;inspecter et de peaufiner le résultat de la fusion avant de valider.</p>
</div>
<div class="paragraph">
<p>Notez que les mises à jour en avance rapide ne créent pas de commit de fusion et qu&#8217;il n&#8217;y a donc aucun moyen d&#8217;arrêter ces fusions avec --no-commit. Ainsi, si vous voulez vous assurer que votre branche n&#8217;est pas modifiée ou mise à jour par la commande de fusion, utilisez --no-ff avec --no-commit.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---edit"> <a class="anchor" href="#git-pull---edit"></a>--edit </dt>
<dt class="hdlist1" id="git-pull--e"> <a class="anchor" href="#git-pull--e"></a>-e </dt>
<dt class="hdlist1" id="git-pull---no-edit"> <a class="anchor" href="#git-pull---no-edit"></a>--no-edit </dt>
<dd>
<p>Avant de procéder à une fusion automatisée réussie, lancer un éditeur pour modifier le message de fusion généré automatiquement, afin que l&#8217;utilisateur puisse expliquer et justifier la fusion. L&#8217;option <code>--no-edit</code> peut être utilisée pour accepter le message généré automatiquement (ce qui est généralement déconseillé).</p>
<div class="paragraph">
<p>Les scripts plus anciens peuvent dépendre du comportement historique de ne pas autoriser l&#8217;utilisateur à modifier le message du journal de fusion. Ils verront un éditeur ouvert lorsqu&#8217;ils exécuteront <code>git merge</code>. Pour faciliter l&#8217;ajustement de ces scripts au comportement mis à jour, la variable d&#8217;environnement <code>GIT_MERGE_AUTOEDIT</code> peut être définie sur <code>no</code> à leur début.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---cleanupltmodegt"> <a class="anchor" href="#git-pull---cleanupltmodegt"></a>--cleanup=&lt;mode&gt; </dt>
<dd>
<p>Cette option détermine comment le message de fusion sera nettoyé avant d&#8217;être envoyé. Voir <a href='{{< relurl "docs/git-commit/fr" >}}'>git-commit[1]</a> pour plus de détails. De plus, si le <em>&lt;mode&gt;</em> a la valeur <code>scissors</code>, les ciseaux seront ajoutés à <em>MERGE_MSG</em> avant d&#8217;être transmis à la machinerie de commit dans le cas d&#8217;un conflit de fusion.</p>
</dd>
<dt class="hdlist1" id="git-pull---ff-only"> <a class="anchor" href="#git-pull---ff-only"></a>--ff-only </dt>
<dd>
<p>Mettre à jour vers le nouvel historique seulement s&#8217;il n&#8217;y a pas d&#8217;historique local divergent. C&#8217;est la valeur par défaut lorsqu&#8217;aucune méthode pour réconcilier des historiques divergents n&#8217;est fournie (via les drapeaux --rebase=*).</p>
</dd>
<dt class="hdlist1" id="git-pull---ff"> <a class="anchor" href="#git-pull---ff"></a>--ff </dt>
<dt class="hdlist1" id="git-pull---no-ff"> <a class="anchor" href="#git-pull---no-ff"></a>--no-ff </dt>
<dd>
<p>Lors d&#8217;une fusion plutôt qu&#8217;un rebasage, précise comment une fusion est traitée lorsque l&#8217;historique fusionné est déjà un descendant de l&#8217;historique actuel. <code>--ff</code> est la valeur par défaut, sauf si l&#8217;on fusionne une étiquette annotée (et éventuellement signée) qui n&#8217;est pas stockée à sa place naturelle dans la hiérarchie <code>refs/tags/</code>, auquel cas <code>--no-ff</code> est supposé.</p>
<div class="paragraph">
<p>Avec <code>--ff</code>, lorsque c&#8217;est possible, résoudre la fusion comme une avance rapide (ne mettre à jour le pointeur de branche que pour qu&#8217;il corresponde à la branche fusionnée ; ne pas créer de commit de fusion). Lorsque ce n&#8217;est pas possible (lorsque l&#8217;historique fusionné n&#8217;est pas un descendant de l&#8217;historique actuel), créer un commit de fusion.</p>
</div>
<div class="paragraph">
<p>Avec <code>--no-ff</code>, créer un commit de fusion dans tous les cas, même si la fusion peut être résolue en avance rapide.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull--Sltidclgt"> <a class="anchor" href="#git-pull--Sltidclgt"></a>-S[&lt;idclé&gt;] </dt>
<dt class="hdlist1" id="git-pull---gpg-signltidclgt"> <a class="anchor" href="#git-pull---gpg-signltidclgt"></a>--gpg-sign[=&lt;idclé&gt;] </dt>
<dt class="hdlist1" id="git-pull---no-gpg-sign"> <a class="anchor" href="#git-pull---no-gpg-sign"></a>--no-gpg-sign </dt>
<dd>
<p>Signer le commit résultant de la fusion avec GPG. L&#8217;argument <code>idclé</code> est optionnel avec par défaut l&#8217;identité du validateur ; si spécifiée, elle doit être collée à l&#8217;option sans aucun espace. <code>--no-gpg-sign</code> est utile pour annuler l&#8217;effet de la variable de configuration <code>commit.gpgSign</code> ainsi que tout <code>--gpg-sign</code> précédent.</p>
</dd>
<dt class="hdlist1" id="git-pull---logltngt"> <a class="anchor" href="#git-pull---logltngt"></a>--log[=&lt;n&gt;] </dt>
<dt class="hdlist1" id="git-pull---no-log"> <a class="anchor" href="#git-pull---no-log"></a>--no-log </dt>
<dd>
<p>En plus des noms de branches, remplir le message du journal avec les descriptions d&#8217;une ligne depuis au maximum &lt;n&gt; commits réels qui sont en train d&#8217;être fusionnés. Voir aussi <a href='{{< relurl "docs/git-fmt-merge-msg/fr" >}}'>git-fmt-merge-msg[1]</a>.
Seulement utile lors de la fusion.</p>
<div class="paragraph">
<p>Avec --no-log, ne pas indiquer les descriptions d&#8217;une ligne des commits réels qui sont fusionnés.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---signoff"> <a class="anchor" href="#git-pull---signoff"></a>--signoff </dt>
<dt class="hdlist1" id="git-pull---no-signoff"> <a class="anchor" href="#git-pull---no-signoff"></a>--no-signoff </dt>
<dd>
<p>Ajouter une ligne finale <code>Signed-off-by</code> du validateur à la fin du message de validation. La signification de signoff dépend du projet sur lequel vous validez. Par exemple, cela peut certifier que le validateur a le droit de soumettre son travail sous la licence du projet ou accepte une certaine représentation du contributeur, tel qu&#8217;un Certificat d&#8217;Origine de Développeur. (Voir <a href="https://developercertificate.org/" class="bare">https://developercertificate.org/</a> pour celui utilisé par les projet du noyau Linux ou de Git). Consultez la documentation ou la direction du projet auquel vous contribuez pour comprendre comment les signatures sont utilisées dans ce projet.</p>
<div class="paragraph">
<p>L&#8217;option --no-signoff peut être utilisée pour contrecarrer une option --signoff précédente sur la ligne de commande.</p>
</div>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull---stat"> <a class="anchor" href="#git-pull---stat"></a>--stat </dt>
<dt class="hdlist1" id="git-pull--n"> <a class="anchor" href="#git-pull--n"></a>-n </dt>
<dt class="hdlist1" id="git-pull---no-stat"> <a class="anchor" href="#git-pull---no-stat"></a>--no-stat </dt>
<dd>
<p>Afficher un diffstat à la fin de la fusion. Le diffstat est également contrôlé par l&#8217;option de configuration merge.stat.</p>
<div class="paragraph">
<p>Avec -n ou --no-stat, ne pas afficher de diffstat à la fin de la fusion.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---squash"> <a class="anchor" href="#git-pull---squash"></a>--squash </dt>
<dt class="hdlist1" id="git-pull---no-squash"> <a class="anchor" href="#git-pull---no-squash"></a>--no-squash </dt>
<dd>
<p>Produire l&#8217;arbre de travail et l&#8217;état d&#8217;index comme si une fusion réelle s&#8217;était produite (sauf pour les informations de fusion), mais ne pas faire de commit, déplacer la <code>HEAD</code>, ou enregistrer <code>$GIT_DIR/MERGE_HEAD</code> (pour forcer le prochain <code>git commit</code> à créer un commit de fusion). Cela vous permet de créer un seul commit au-dessus de la branche actuelle dont l&#8217;effet est identique à la fusion d&#8217;une autre branche (ou plus dans le cas d&#8217;une fusion pieuvre).</p>
<div class="paragraph">
<p>Avec --no-squash, effectuer la fusion et valider le résultat. Cette option peut être utilisée pour passer outre --squash.</p>
</div>
<div class="paragraph">
<p>Avec --squash, --commit n&#8217;est pas permis, et échouera.</p>
</div>
<div class="paragraph">
<p>Seulement utile lors de la fusion.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---no-verify"> <a class="anchor" href="#git-pull---no-verify"></a>--[no-]verify </dt>
<dd>
<p>Par défaut, les crochets pre-merge et commit-msg sont exécutés. Lorsque <code>--no-verify</code> est donné, ils sont contournés. Voir aussi <a href='{{< relurl "docs/githooks/fr" >}}'>githooks[5]</a>.
Seulement utile lors de la fusion.</p>
</dd>
<dt class="hdlist1" id="git-pull--sltstratgiegt"> <a class="anchor" href="#git-pull--sltstratgiegt"></a>-s &lt;stratégie&gt; </dt>
<dt class="hdlist1" id="git-pull---strategyltstrategiegt"> <a class="anchor" href="#git-pull---strategyltstrategiegt"></a>--strategy=&lt;strategie&gt; </dt>
<dd>
<p>Utiliser la stratégie de fusion donnée ; peut être fourni plus d&#8217;une fois pour spécifier l&#8217;ordre dans lequel elles doivent être essayées. S&#8217;il n&#8217;y a pas d&#8217;option <code>-s</code>, une liste intégrée de stratégies est utilisée à la place (<code>ort</code> lors de la fusion d&#8217;une seule tête, <code>octopus</code> sinon).</p>
</dd>
<dt class="hdlist1" id="git-pull--Xltoptiongt"> <a class="anchor" href="#git-pull--Xltoptiongt"></a>-X &lt;option&gt; </dt>
<dt class="hdlist1" id="git-pull---strategy-optionltoptiongt"> <a class="anchor" href="#git-pull---strategy-optionltoptiongt"></a>--strategy-option=&lt;option&gt; </dt>
<dd>
<p>Faire passer l&#8217;option spécifique de la stratégie de fusion à la stratégie de fusion.</p>
</dd>
<dt class="hdlist1" id="git-pull---verify-signatures"> <a class="anchor" href="#git-pull---verify-signatures"></a>--verify-signatures </dt>
<dt class="hdlist1" id="git-pull---no-verify-signatures"> <a class="anchor" href="#git-pull---no-verify-signatures"></a>--no-verify-signatures </dt>
<dd>
<p>Vérifier que le commit sommet de la branche latérale à fusionner est signé avec une clé valide, c&#8217;est-à-dire une clé qui a un uid valide : dans le modèle de confiance par défaut, cela signifie que la clé de signature a été signée par une clé de confiance. Si le commit sommet de la branche latérale n&#8217;est pas signé avec une clé valide, la fusion est annulée.</p>
<div class="paragraph">
<p>Seulement utile lors de la fusion.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---summary"> <a class="anchor" href="#git-pull---summary"></a>--summary </dt>
<dt class="hdlist1" id="git-pull---no-summary"> <a class="anchor" href="#git-pull---no-summary"></a>--no-summary </dt>
<dd>
<p>Synonymes de --stat et --no-stat ; ils sont déconseillés et seront supprimés à l&#8217;avenir.</p>
</dd>
<dt class="hdlist1" id="git-pull---autostash"> <a class="anchor" href="#git-pull---autostash"></a>--autostash </dt>
<dt class="hdlist1" id="git-pull---no-autostash"> <a class="anchor" href="#git-pull---no-autostash"></a>--no-autostash </dt>
<dd>
<p>Créer automatiquement une entrée temporaire de remisage avant le début de l&#8217;opération, l&#8217;enregistrer dans la réf <code>MERGE_AUTOSTASH</code> et l&#8217;appliquer après la fin de l&#8217;opération. Cela signifie que vous pouvez exécuter l&#8217;opération sur un arbre de travail sale. Cependant, utilisez-le avec précaution : l&#8217;application finale du remisage après une fusion réussie peut entraîner des conflits non négligeables.</p>
</dd>
<dt class="hdlist1" id="git-pull---allow-unrelated-histories"> <a class="anchor" href="#git-pull---allow-unrelated-histories"></a>--allow-unrelated-histories </dt>
<dd>
<p>Par défaut, la commande <code>git merge</code> refuse de fusionner les historiques qui ne partagent pas un ancêtre commun. Cette option peut être utilisée pour passer outre cette sécurité lors de la fusion des historiques de deux projets qui ont commencé leur vie indépendamment l&#8217;un de l&#8217;autre. Comme c&#8217;est une occasion très rare, il n&#8217;existe pas de variable de configuration pour activer cette option par défaut et elle ne sera pas ajoutée.</p>
<div class="paragraph">
<p>Seulement utile lors de la fusion.</p>
</div>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull--r"> <a class="anchor" href="#git-pull--r"></a>-r </dt>
<dt class="hdlist1" id="git-pull---rebasefalsetruemergesinteractive"> <a class="anchor" href="#git-pull---rebasefalsetruemergesinteractive"></a>--rebase[=(false|true|merges|interactive)] </dt>
<dd>
<p>Lorsque c&#8217;est le cas, rebaser la branche actuelle sur la branche amont après l&#8217;avoir récupérée. S&#8217;il existe une branche de suivi à distance correspondant à la branche en amont et que la branche en amont a été rebasée depuis la dernière extraction, le rebasage utilise cette information pour éviter de rebaser des modifications non locales.</p>
<div class="paragraph">
<p>Lorsqu&#8217;il est défini sur <code>merges</code>, rebaser en utilisant <code>git rebase --rebase-merges</code> de sorte que les commits de fusion locaux soient inclus dans le rebasage (voir <a href='{{< relurl "docs/git-rebase/fr" >}}'>git-rebase[1]</a> pour plus de détails).</p>
</div>
<div class="paragraph">
<p>Lorsqu&#8217;elle est fausse, fusionner la branche amont dans la branche actuelle.</p>
</div>
<div class="paragraph">
<p>Lorsque vous êtes en mode <code>interactive</code>, activer le mode interactif de rebase.</p>
</div>
<div class="paragraph">
<p>Voir <code>pull.rebase</code>, <code>branch. &lt;nom&gt; .rebase</code> et <code>branch.autoSetupRebase</code> dans <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a> si vous voulez que <code>git pull</code> utilise toujours <code>--rebase</code> au lieu de fusionner .</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
C&#8217;est un mode de fonctionnement potentiellement <em>dangereux</em>. Il réécrit l&#8217;historique, ce qui n&#8217;est pas de bon augure lorsque vous avez déjà publié cette historique. N&#8217;utilisez <strong>pas</strong> cette option à moins d&#8217;avoir lu attentivement <a href='{{< relurl "docs/git-rebase/fr" >}}'>git-rebase[1]</a>.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1" id="git-pull---no-rebase"> <a class="anchor" href="#git-pull---no-rebase"></a>--no-rebase </dt>
<dd>
<p>C&#8217;est un raccourci pour --rebase=false.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_options_relatives_au_rapatriement"><a class="anchor" href="#_options_relatives_au_rapatriement"></a>Options relatives au rapatriement</h3>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull---no-all"> <a class="anchor" href="#git-pull---no-all"></a>--[no-]all </dt>
<dd>
<p>Récupérer tous les distants . Cela surcharge la variable de configuration <code>fetch.all</code> .</p>
</dd>
<dt class="hdlist1" id="git-pull--a"> <a class="anchor" href="#git-pull--a"></a>-a </dt>
<dt class="hdlist1" id="git-pull---append"> <a class="anchor" href="#git-pull---append"></a>--append </dt>
<dd>
<p>Ajouter les noms de références et les noms d&#8217;objets des références récupérées au contenu existant de <code>.git/FETCH_HEAD</code>. Sans cette option, les anciennes données dans <code>.git/FETCH_HEAD</code> seront écrasées.</p>
</dd>
<dt class="hdlist1" id="git-pull---atomic"> <a class="anchor" href="#git-pull---atomic"></a>--atomic </dt>
<dd>
<p>Utiliser une transaction atomique pour mettre à jour les références locales. Soit toutes les références sont mises à jour, soit, en cas d&#8217;erreur, aucune référence n&#8217;est mise à jour.</p>
</dd>
<dt class="hdlist1" id="git-pull---depthltprofondeurgt"> <a class="anchor" href="#git-pull---depthltprofondeurgt"></a>--depth=&lt;profondeur&gt; </dt>
<dd>
<p>Limiter la récupération au nombre spécifié de commits à partir du sommet de l&#8217;historique de chaque branche distante. Si vous allez chercher dans un dépôt "superficiel" créé par <code>git clone</code> avec l&#8217;option <code>--depth=&lt;profondeur&gt;</code> (voir <a href='{{< relurl "docs/git-clone/fr" >}}'>git-clone[1]</a>), approfondir ou raccourcir l&#8217;historique jusqu&#8217;au nombre spécifié de validations. Les étiquettes pour les commits approfondis ne sont pas récupérées.</p>
</dd>
<dt class="hdlist1" id="git-pull---deepenltprofondeurgt"> <a class="anchor" href="#git-pull---deepenltprofondeurgt"></a>--deepen=&lt;profondeur&gt; </dt>
<dd>
<p>Semblable à --depth, sauf que cela précise le nombre de commits à partir de la limite actuelle superficielle au lieu du sommet de l&#8217;historique de chaque branche distante.</p>
</dd>
<dt class="hdlist1" id="git-pull---shallow-sinceltdategt"> <a class="anchor" href="#git-pull---shallow-sinceltdategt"></a>--shallow-since=&lt;date&gt; </dt>
<dd>
<p>Approfondir ou raccourcir l&#8217;historique d&#8217;un dépôt superficiel pour inclure tous les commits accessibles après &lt;date&gt;.</p>
</dd>
<dt class="hdlist1" id="git-pull---shallow-excludeltrvisiongt"> <a class="anchor" href="#git-pull---shallow-excludeltrvisiongt"></a>--shallow-exclude=&lt;révision&gt; </dt>
<dd>
<p>Approfondir ou raccourcir l&#8217;historique d&#8217;un dépôt superficiel afin d&#8217;exclure les commits accessibles depuis une branche ou une étiquette distante spécifiée. Cette option peut être spécifiée plusieurs fois.</p>
</dd>
<dt class="hdlist1" id="git-pull---unshallow"> <a class="anchor" href="#git-pull---unshallow"></a>--unshallow </dt>
<dd>
<p>Si le dépôt de sources est complet, convertir un dépôt superficiel en un dépôt complet, en supprimant toutes les limitations imposées par les dépôts superficiels.</p>
<div class="paragraph">
<p>Si le dépôt source est superficiel, il faut en extraire le plus possible afin que le dépôt actuel ait le même historique que le dépôt source.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---update-shallow"> <a class="anchor" href="#git-pull---update-shallow"></a>--update-shallow </dt>
<dd>
<p>Par défaut, lors de la récupération d&#8217;un dépôt superficiel, <code>git fetch</code> refuse les références qui nécessitent une mise à jour de .git/shallow. Cette option met à jour le fichier .git/shallow et accepte de telles références.</p>
</dd>
<dt class="hdlist1" id="git-pull---negotiation-tipltcommitglobgt"> <a class="anchor" href="#git-pull---negotiation-tipltcommitglobgt"></a>--negotiation-tip=&lt;commit|glob&gt; </dt>
<dd>
<p>Par défaut, Git signalera au serveur les commits accessibles à partir de toutes les références locales pour trouver les commits communs afin de réduire la taille du fichier de paquet à recevoir. Si ceci est spécifié, Git ne signalera que les commits accessibles à partir des sommets donnés. Ceci est utile pour accélérer les recherches lorsque l&#8217;utilisateur sait quelle réf locale est susceptible d&#8217;avoir des commits en commun avec la réf amont qui est recherchée.</p>
<div class="paragraph">
<p>Cette option peut être spécifiée plus d&#8217;une fois ; si c&#8217;est le cas, Git signalera les commits accessibles à partir de l&#8217;un des commits donnés.</p>
</div>
<div class="paragraph">
<p>L&#8217;argument de cette option peut être un glob sur les noms de référence, une référence ou le SHA-1 (éventuellement abrégé) d&#8217;un commit. La spécification d&#8217;un glob équivaut à spécifier cette option plusieurs fois, une pour chaque nom de référence correspondant.</p>
</div>
<div class="paragraph">
<p>Voir aussi les variables de configuration <code>fetch.negotiationAlgorithm</code> et <code>push.negotiate</code> documentées dans <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>, ainsi que l&#8217;option <code>--negotiate-only</code> ci-après.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---negotiate-only"> <a class="anchor" href="#git-pull---negotiate-only"></a>--negotiate-only </dt>
<dd>
<p>Ne rien récupérer du serveur, et à la place afficher les ancêtres des arguments fournis par <code>--negotiation-tip=*</code>, que nous avons en commun avec le serveur.</p>
<div class="paragraph">
<p>C&#8217;est incompatible avec <code>--recurse-submodules=[yes|on-demand]</code>. En interne, ceci est utilisé pour implémenter l&#8217;option <code>push.negotiate</code>, voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---dry-run"> <a class="anchor" href="#git-pull---dry-run"></a>--dry-run </dt>
<dd>
<p>Montrer ce qui serait fait, sans faire de changements.</p>
</dd>
<dt class="hdlist1" id="git-pull---porcelain"> <a class="anchor" href="#git-pull---porcelain"></a>--porcelain </dt>
<dd>
<p>Afficher la sortie sur la sortie standard dans un format facile à décrypter pour les scripts. Voir la section SORTIE dans <a href='{{< relurl "docs/git-fetch/fr" >}}'>git-fetch[1]</a> pour plus de détails.</p>
<div class="paragraph">
<p>C&#8217;est incompatible avec <code>--recurse-submodules=[yes|on-demand]`et a la priorité sur l'option de configuration `fetch.output</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull--f"> <a class="anchor" href="#git-pull--f"></a>-f </dt>
<dt class="hdlist1" id="git-pull---force"> <a class="anchor" href="#git-pull---force"></a>--force </dt>
<dd>
<p>Lorsque <em>git fetch</em> est utilisé avec la spécification de référence <code>&lt;src&gt;:&lt;dst&gt;</code>, il peut refuser de mettre à jour la branche locale comme cela a été discuté
dans la partie <code>&lt;spécificateur-de-référence&gt;</code> de la documentation
<a href='{{< relurl "docs/git-fetch/fr" >}}'>git-fetch[1]</a>.
Cette option permet de passer outre à ce contrôle.</p>
</dd>
<dt class="hdlist1" id="git-pull--k"> <a class="anchor" href="#git-pull--k"></a>-k </dt>
<dt class="hdlist1" id="git-pull---keep"> <a class="anchor" href="#git-pull---keep"></a>--keep </dt>
<dd>
<p>Conserver le paquet téléchargé.</p>
</dd>
<dt class="hdlist1" id="git-pull---prefetch"> <a class="anchor" href="#git-pull---prefetch"></a>--prefetch </dt>
<dd>
<p>Modifier le spécificateur de référence configuré pour placer toutes les refs dans l&#8217;espace de noms <code>refs/prefetch/</code>. Voir la tâche <code>prefetch</code> dans <a href='{{< relurl "docs/git-maintenance/fr" >}}'>git-maintenance[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-pull--p"> <a class="anchor" href="#git-pull--p"></a>-p </dt>
<dt class="hdlist1" id="git-pull---prune"> <a class="anchor" href="#git-pull---prune"></a>--prune </dt>
<dd>
<p>Avant de récupérer, supprimer toutes les références de suivi à distance qui n&#8217;existent plus sur le dépôt distant. Les étiquettes ne sont pas sujettes à l&#8217;élagage si elles ne sont récupérées qu&#8217;en raison du suivi automatique de l&#8217;étiquette par défaut ou en raison d&#8217;une option --tags. Cependant, si les étiquettes sont récupérées en raison d&#8217;un spécificateur de référence explicite (soit en ligne de commande, soit dans la configuration distante, par exemple si le dépôt distant a été cloné avec l&#8217;option --mirror), alors elles sont également sujettes à l&#8217;élagage. La fourniture de <code>--prune-tags</code> est une abréviation pour la fourniture du spécificateur de référence d&#8217;étiquette.</p>
</dd>
<dt class="hdlist1" id="git-pull---no-tags"> <a class="anchor" href="#git-pull---no-tags"></a>--no-tags </dt>
<dd>
<p>Par défaut, les étiquettes qui pointent sur des objets téléchargés à partir du dépôt distant sont récupérées et stockées localement. Cette option désactive le suivi automatique des étiquettes. Le comportement par défaut d&#8217;un distant peut être spécifié avec le paramètre remote.&lt;nom&gt;.tagOpt. Voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-pull---refmapltspcificateur-de-rfrencegt"> <a class="anchor" href="#git-pull---refmapltspcificateur-de-rfrencegt"></a>--refmap=&lt;spécificateur-de-référence&gt; </dt>
<dd>
<p>Lors de la récupération des références listées en ligne de commande, utiliser la spécification de référence (qui peut être donnée plusieurs fois) pour mapper les références sur les branches de suivi à distance, au lieu des valeurs des variables de configuration <code>remote.*.fetch</code> pour le dépôt distant. Fournir un <code>&lt;spécificateur-de-référence&gt;</code> vide à l&#8217;option <code>--refmap</code> fait que Git ignore les spécification de référence configurées et se fie entièrement aux spécifications de référence fournies comme arguments de la ligne de commande. Voir la section sur les "Branches de suivi à distance configurées" pour plus de détails.</p>
</dd>
<dt class="hdlist1" id="git-pull--t"> <a class="anchor" href="#git-pull--t"></a>-t </dt>
<dt class="hdlist1" id="git-pull---tags"> <a class="anchor" href="#git-pull---tags"></a>--tags </dt>
<dd>
<p>Récupérer toutes les étiquettes à distance (c&#8217;est-à-dire, récupérer les étiquettes <code>refs/tags/*</code> dans les étiquettes locales avec le même nom), en plus de tout ce qui serait récupéré autrement. L&#8217;utilisation de cette seule option ne soumet pas les étiquettes à un élagage, même si --prune est utilisé (bien que les étiquettes puissent être élaguées de toute façon si elles sont aussi la destination d&#8217;une spécification de référence explicite ; voir <code>--prune</code>).</p>
</dd>
<dt class="hdlist1" id="git-pull--j"> <a class="anchor" href="#git-pull--j"></a>-j </dt>
<dt class="hdlist1" id="git-pull---jobsltngt"> <a class="anchor" href="#git-pull---jobsltngt"></a>--jobs=&lt;n&gt; </dt>
<dd>
<p>Nombre d&#8217;enfants parallèles à utiliser pour toutes les formes d&#8217;extraction.</p>
<div class="paragraph">
<p>Si l&#8217;option <code>--multiple</code> a été spécifiée, les différents distants seront récupérés en parallèle. Si plusieurs sous-modules sont récupérés, ils seront récupérés en parallèle. Pour les contrôler indépendamment, utilisez les paramètres de configuration <code>fetch.parallel</code> et <code>submodule.fetchJobs</code> (voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>Généralement, les recherches récursives parallèles et sur des distants multiples seront plus rapides. Par défaut, les recherches sont effectuées de manière séquentielle, et non en parallèle.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---set-upstream"> <a class="anchor" href="#git-pull---set-upstream"></a>--set-upstream </dt>
<dd>
<p>Si le distant est récupéré avec succès, ajouter la référence (de suivi) amont , utilisée par les commandes sans argument <a href='{{< relurl "docs/git-pull/fr" >}}'>git-pull[1]</a> et autres. Pour plus d&#8217;informations, voir <code>branch.&lt;nom&gt;.merge</code> et <code>branch.&lt;nom&gt;.remote</code> dans <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-pull---upload-packltupload-packgt"> <a class="anchor" href="#git-pull---upload-packltupload-packgt"></a>--upload-pack &lt;upload-pack&gt; </dt>
<dd>
<p>Lorsqu&#8217;il est donné, et que le dépôt à récupérer est géré par <em>git fetch-pack</em>, <code>--exec=&lt;upload-pack&gt;</code> est passé à la commande pour spécifier le chemin par défaut pour la commande exécutée à l&#8217;autre bout.</p>
</dd>
<dt class="hdlist1" id="git-pull---progress"> <a class="anchor" href="#git-pull---progress"></a>--progress </dt>
<dd>
<p>L&#8217;état d&#8217;avancement est affiché sur la sortie d&#8217;erreur standard quand elle est attachée à un terminal, à moins que -q soit spécifié. Ce drapeau force l&#8217;état d&#8217;avancement même si le flux d&#8217;erreur standard n&#8217;est pas dirigé vers un terminal.</p>
</dd>
<dt class="hdlist1" id="git-pull--oltoptiongt"> <a class="anchor" href="#git-pull--oltoptiongt"></a>-o &lt;option&gt; </dt>
<dt class="hdlist1" id="git-pull---server-optionltoptiongt"> <a class="anchor" href="#git-pull---server-optionltoptiongt"></a>--server-option=&lt;option&gt; </dt>
<dd>
<p>Transmettre la chaîne donnée au serveur lors d&#8217;une communication utilisant la version 2 du protocole. La chaîne donnée ne doit pas contenir de caractère NUL ou LF. La gestion par le serveur des options du serveur, y compris les options inconnues, est spécifique au serveur. Lorsque plusieurs <code>--server-option=&lt;option&gt;</code> sont donnés, ils sont tous envoyés à l&#8217;autre côté dans l&#8217;ordre indiqué sur la ligne de commande.</p>
</dd>
<dt class="hdlist1" id="git-pull---show-forced-updates"> <a class="anchor" href="#git-pull---show-forced-updates"></a>--show-forced-updates </dt>
<dd>
<p>Par défaut, git vérifie si une branche est mise à jour de force pendant la récupération. Cela peut être désactivé via fetch.showForcedUpdates, mais l&#8217;option --show-forced-updates garantit que cette vérification a lieu. Voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-pull---no-show-forced-updates"> <a class="anchor" href="#git-pull---no-show-forced-updates"></a>--no-show-forced-updates </dt>
<dd>
<p>Par défaut, git vérifie si une branche est mise à jour de force pendant la récupération. Passer --no-show-forced-updates ou régler fetch.showForcedUpdates à false pour sauter cette vérification pour des raisons de performance. Si elle est utilisée pendant <em>git-pull</em>, l&#8217;option --ff-only vérifiera toujours les mises à jour forcées avant de tenter une mise à jour rapide. Voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-pull--4"> <a class="anchor" href="#git-pull--4"></a>-4 </dt>
<dt class="hdlist1" id="git-pull---ipv4"> <a class="anchor" href="#git-pull---ipv4"></a>--ipv4 </dt>
<dd>
<p>Utiliser uniquement les adresses IPv4, en ignorant les adresses IPv6.</p>
</dd>
<dt class="hdlist1" id="git-pull--6"> <a class="anchor" href="#git-pull--6"></a>-6 </dt>
<dt class="hdlist1" id="git-pull---ipv6"> <a class="anchor" href="#git-pull---ipv6"></a>--ipv6 </dt>
<dd>
<p>Utiliser uniquement les adresses IPv6, en ignorant les adresses IPv4.</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull-ltdptgt"> <a class="anchor" href="#git-pull-ltdptgt"></a>&lt;dépôt&gt; </dt>
<dd>
<p>Le dépôt "distant" qui est la source d&#8217;une opération de récupération ou de tirage. Ce paramètre peut être soit une URL (voir la section <a href="#URLS">URLS GIT</a> ci-dessous) soit le nom d&#8217;un remote (voir la section <a href="#REMOTES">DISTANTS</a> ci-dessous).</p>
</dd>
<dt class="hdlist1" id="git-pull-ltspcificateur-de-rfrencegt"> <a class="anchor" href="#git-pull-ltspcificateur-de-rfrencegt"></a>&lt;spécificateur-de-référence&gt; </dt>
<dd>
<p>Préciser les références à récupérer et les références locales à mettre à jour. Lorsqu&#8217;aucun &lt;spéc-de-réf&gt; n&#8217;apparaît sur la ligne de commande, les références à récupérer sont lues à partir des variables <code>remote.&lt;dépôt&gt;.fetch</code> à la place
(voir la section "<a href="#BRANCHES DE SUIVI À DISTANCE CONFIGURÉES">[BRANCHES DE SUIVI À DISTANCE CONFIGURÉES]</a>"
dans <a href='{{< relurl "docs/git-fetch/fr" >}}'>git-fetch[1]</a>).</p>
<div class="paragraph">
<p>Le format d&#8217;un paramètre &lt;spéc-de-réf&gt; est un plus <code>+</code> optionnel, suivi de la source &lt;src&gt;, suivi de deux points <code>:</code>, suivi de la destination ref &lt;dst&gt;. Les deux points peuvent être omis lorsque &lt;dst&gt; est vide. &lt;src&gt; est typiquement une réf, mais cela peut aussi être un nom d&#8217;objet hexadécimal entier.</p>
</div>
<div class="paragraph">
<p>Un &lt;spec-de-réf&gt; peut contenir un <code>*</code> dans son &lt;src&gt; pour indiquer une simple correspondance de motif. Un tel refspec fonctionne comme un motif qui correspond à n&#8217;importe quelle ref avec le même préfixe. Un motif &lt;spec-de-réf&gt; doit avoir un <code>*</code> dans les deux &lt;src&gt; et &lt;dst&gt;. Il va faire correspondre les références à la destination en remplaçant le <code>*</code> par le contenu correspondant de la source.</p>
</div>
<div class="paragraph">
<p>Si un spécificateur de référence est préfixé par <code>^</code>, il sera interprété comme un spécificateur de référence négatif. Plutôt que de spécifier les références à récupérer ou les références locales à mettre à jour, un tel spécificateur de référence spécifiera les références à exclure. Une référence sera considérée comme correspondante si elle correspond à au moins une référence positive, et ne correspond à aucune référence négative. Les spécificateurs de référence négatifs peuvent être utiles pour restreindre le champ d&#8217;application d&#8217;un spécificateur modèle de référence afin qu&#8217;il n&#8217;inclue pas de références spécifiques. Les spécificateurs de référence négatifs peuvent eux-mêmes être des spécificateurs modèles de référence . Cependant, ils ne peuvent contenir qu&#8217;un &lt;src&gt; et ne peuvent pas spécifier un &lt;dst&gt;. Les noms d&#8217;objets hexagonaux complets ne sont pas non plus pris en charge.</p>
</div>
<div class="paragraph">
<p><code>tag &lt;étiquette&gt;</code> signifie la même chose que <code>refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</code> ; cela demande de tout récupérer jusqu&#8217;à l&#8217;étiquette donnée.</p>
</div>
<div class="paragraph">
<p>La référence distante qui correspond à &lt;src&gt; est récupérée, et si &lt;dst&gt; n&#8217;est pas une chaîne vide, une tentative est faite pour mettre à jour la référence locale qui lui correspond.</p>
</div>
<div class="paragraph">
<p>Le fait que cette mise à jour soit autorisée sans <code>--force</code> dépend de l&#8217;espace de noms de référence vers lequel elle est récupérée, du type d&#8217;objet récupéré, et si la mise à jour est considérée comme une avance rapide. Généralement, les mêmes règles s&#8217;appliquent pour la récupération que pour la poussée, voir la section <code>&lt;spéc-de-réf&gt;...</code> de <a href='{{< relurl "docs/git-push/fr" >}}'>git-push[1]</a> pour les connaître. Les exceptions à ces règles particulières à <em>git fetch</em> sont notées ci-dessous.</p>
</div>
<div class="paragraph">
<p>Jusqu&#8217;à la version 2.20 de Git, et contrairement à ce qui se passe avec <a href='{{< relurl "docs/git-push/fr" >}}'>git-push[1]</a>, toute mise à jour de <code>refs/tags/*</code> serait acceptée sans <code>+</code> dans la spéc-de-réf (ou <code>--force</code>). Lors de la récupération, nous considérons sans distinction toutes les mises à jour d&#8217;étiquettes depuis un dépôt distance comme des récupérations forcées. Depuis la version 2.20 de Git, la récupération pour mettre à jour les <code>refs/tags/*</code> fonctionne de la même manière que lors de la poussée. C&#8217;est-à-dire que toute mise à jour sera rejetée sans "+" dans le spécificateur de référence (ou <code>--force</code>).</p>
</div>
<div class="paragraph">
<p>Contrairement à une poussée avec <a href='{{< relurl "docs/git-push/fr" >}}'>git-push[1]</a>, toute mise à jour en dehors de <code>refs/{tags,heads}/*</code> sera acceptée sans <code>+</code> dans le spéc-de-réf (ou <code>--force</code>), que ce soit en échangeant par exemple un objet arbre pour un blob, ou un commit pour un autre commit qui n&#8217;a pas le commit précédent comme ancêtre etc.</p>
</div>
<div class="paragraph">
<p>Contrairement à une poussée avec <a href='{{< relurl "docs/git-push/fr" >}}'>git-push[1]</a>, il n&#8217;y a pas de configuration qui modifie ces règles, et rien de tel qu&#8217;un crochet pré-récupération <code>pre-fetch</code> analogue à celui de pré-réception`pre-receive`.</p>
</div>
<div class="paragraph">
<p>Comme pour la poussée avec <a href='{{< relurl "docs/git-push/fr" >}}'>git-push[1]</a>, toutes les règles décrites ci-dessus concernant ce qui n&#8217;est pas autorisé comme une mise à jour, peuvent être annulées en ajoutant un "+" optionnel à un spécificateur de référence (ou en utilisant l&#8217;option de ligne de commande <code>--force</code>). La seule exception à cette règle est qu&#8217;aucun forçage ne fera accepter à l&#8217;espace de noms <code>refs/heads/*</code> un objet non commit.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Lorsque la branche distante que vous voulez récupérer est connue pour être régulièrement rembobinée et rebasée, on s&#8217;attend à ce que son nouveau sommet ne soit pas un descendant de son sommet précédent (telle qu&#8217;il était stocké dans votre branche de suivi à distance la dernière fois que vous l&#8217;avez récupéré). Vous pouvez utiliser le signe "+" pour indiquer que des mises à jour non en avance rapide seront nécessaires pour ces branches. Il n&#8217;y a aucun moyen de déterminer ou de déclarer qu&#8217;une branche sera rendue disponible dans un dépôt avec ce comportement ; l&#8217;utilisateur qui tire doit simplement savoir que c&#8217;est le modèle d&#8217;utilisation attendu pour une branche.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Il y a une différence entre le fait de lister plusieurs &lt;spéc-de-réf&gt; directement sur la ligne de commande <em>git pull</em> et le fait d&#8217;avoir plusieurs entrées <code>remote.&lt;dépôt&gt;.fetch</code> dans votre configuration pour un &lt;dépôt&gt; et d&#8217;exécuter une commande <em>git pull</em> sans aucun paramètre &lt;spéc-de-réf&gt; explicite. Les &lt;spéc-de-réf&gt;s listés explicitement sur la ligne de commande sont toujours fusionnés dans la branche actuelle après avoir été récupérées. En d&#8217;autres termes, si vous listez plus d&#8217;une référence distante, <em>git pull</em> créera une fusion Octopus. D&#8217;un autre côté, si vous n&#8217;indiquez aucun paramètre &lt;spéc-de-réf&gt; explicite sur la ligne de commande, <em>git pull</em> récupérera tous les &lt;spéc-de-réf&gt;s qu&#8217;il trouve dans la configuration <code>remote.&lt;dépôt&gt;.fetch</code> et fusionnera seulement le premier &lt;réf-de-spéc&gt; trouvé dans la branche actuelle. C&#8217;est parce que faire un Octopus à partir de références distantes est rarement fait, alors que garder la trace de plusieurs têtes distantes en un seul coup en en récupérant plusieurs est souvent utile.
</td>
</tr>
</table>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_url_git"><a class="anchor" href="#_url_git"></a>URL GIT<a id="URLS"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>En général, les URL contiennent une information sur le protocole de transport, l&#8217;adresse du serveur distant et le chemin vers le dépôt. En fonction du protocole de transport, certaines de ces informations peuvent être absentes.</p>
</div>
<div class="paragraph">
<p>Git supporte les protocoles ssh, git, http et https (en plus, ftp et ftps peuvent être utilisés pour la récupération, mais ceux-ci sont inefficaces et déconseillés ; ne les utilisez pas).</p>
</div>
<div class="paragraph">
<p>Le transport natif (c&#8217;est-à-dire l&#8217;URL git://) n&#8217;utilise pas d&#8217;authentification et ne devrait être utilisé qu&#8217;avec précaution sur des réseaux non sécurisés.</p>
</div>
<div class="paragraph">
<p>Les syntaxes suivantes peuvent être utilisées avec eux :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ssh://</code>[<em>&lt;utilisateur&gt;</em><code>@</code>]<em>&lt;hôte&gt;</em>[<code>:</code><em>&lt;port&gt;</em>]<code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
<li>
<p><code>git://</code><em>&lt;hôte&gt;</em>[:<em>&lt;port&gt;</em>]<code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
<li>
<p><code>http</code>[<code>s</code>]<code>://</code><em>&lt;hôtet&gt;</em>[<code>:</code><em>&lt;port&gt;</em>]<code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
<li>
<p><code>ftp</code>[<code>s</code>]<code>://</code><em>&lt;hôte&gt;</em>[<code>:</code><em>&lt;port&gt;</em>]<code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Une syntaxe alternative de type scp peut aussi être utilisée pour le protocole ssh :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[<em>&lt;utilisateur&gt;</em><code>@</code>]<em>&lt;hôte&gt;</em><code>:/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cette syntaxe n&#8217;est reconnue que s&#8217;il n&#8217;y a pas de barre oblique devant les premiers deux-points. Cela permet de prendre en charge des chemins locaux qui contiendraient des deux-points. Par exemple, le chemin local <code>toto:titi</code> pourrait être spécifié comme un chemin absolu ou <code>./toto:titi</code> pour éviter d&#8217;être interprété comme une url ssh.</p>
</div>
<div class="paragraph">
<p>Les protocoles ssh et git supportent en plus l&#8217;expansion <code>~</code><em>&lt;utilisateur&gt;</em>  :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ssh://</code>[<em>&lt;utilisateur&gt;</em><code>@</code>]<em>&lt;hôte&gt;</em>[<code>:</code><em>&lt;port&gt;</em>]<code>/~</code><em>&lt;utilisateur&gt;</em><code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
<li>
<p><code>git://</code><em>&lt;hôte&gt;</em>[<code>:</code><em>&lt;port&gt;</em>]<code>/~</code><em>&lt;utilisateur&gt;</em><code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
<li>
<p>[<em>&lt;utilisateur&gt;</em><code>@</code>]<em>&lt;hôte&gt;</em><code>:~</code><em>&lt;utilisateur&gt;</em><code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Pour les dépôts locaux, supportés aussi nativement par Git, les syntaxes suivantes sont aussi admises :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/chemin/du/dépôt.git/</code></p>
</li>
<li>
<p><code><a href="file:///chemin/du/dépôt.git/" class="bare">file:///chemin/du/dépôt.git/</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ces deux syntaxes sont à peu près équivalentes, à part lors d&#8217;un clonage, où la première implique l&#8217;option <code>--local</code>. Voir <a href='{{< relurl "docs/git-clone/fr" >}}'>git-clone[1]</a> pour plus de détails.</p>
</div>
<div class="paragraph">
<p><code>git clone</code>, <code>git fetch</code> et <code>git pull</code>, mais pas <code>git push</code>, acceptent également un fichier paquet approprié. Voir <a href='{{< relurl "docs/git-bundle/fr" >}}'>git-bundle[1]</a>.</p>
</div>
<div class="paragraph">
<p>Quand Git ne sait pas comment gérer un certain protocole, il essaie d&#8217;utiliser l&#8217;assistant de gestion de distant <code>remote-</code><em>&lt;transport&gt;</em>, s&#8217;il existe. Pour requérir l&#8217;emploi d&#8217;un assistant spécifique, la syntaxe suivante peut être utilisée :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>&lt;transport&gt;</em>::<em>&lt;adresse&gt;</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>où <em>&lt;adresse&gt;</em> peut être un chemin, un serveur et chemin, ou une chaîne URL arbitraire reconnue par l&#8217;assistant de gestion de distant invoqué. Voir <a href='{{< relurl "docs/gitremote-helpers/fr" >}}'>gitremote-helpers[7]</a> pour plus de détails.</p>
</div>
<div class="paragraph">
<p>S&#8217;il y a un grand nombre de dépôts aux noms similaires et que vous souhaitez utiliser un format différent pour eux (de telle sorte que les URL que vous utiliserez seront réécrites en URL fonctionnelles), vous pouvez créer une section de configuration de la forme :</p>
</div>
<div class="verseblock">
<pre class="content">	[url "<em>&lt;veritable-base-d-url&gt;</em>"]
		insteadOf = <em>&lt;autre-base-d&#8217;URL&gt;</em></pre>
</div>
<div class="paragraph">
<p>Par exemple, avec ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "git://git.host.xz/"]
		insteadOf = host.xz:/chemin/vers/
		insteadOf = travail:</pre>
</div>
</div>
<div class="paragraph">
<p>une URL comme « travail:depot.git » ou « host.xz:/chemin/vers/depot.git » sera réécrite dans tout contexte qui requiert une URL en « git://git.host.xz/depot.git ».</p>
</div>
<div class="paragraph">
<p>Si vous souhaitez réécrire les URL seulement pour pousser, vous pouvez créer une section de configuration de la forme :</p>
</div>
<div class="verseblock">
<pre class="content">	[url "<em>&lt;veritable-base-d&#8217;URL&gt;</em>"]
		pushInsteadOf = <em>&lt;autre-base-d-URL&gt;</em></pre>
</div>
<div class="paragraph">
<p>Par exemple, avec ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "ssh://exemple.org/"]
		pushInsteadOf = git://exemple.org/</pre>
</div>
</div>
<div class="paragraph">
<p>une URL telle que « git://exemple.org/chemin/vers/le/depot.git » sera réécrite en « ssh://exemple.org/chemin/vers/le/depot.git » pour les poussées, mais les tirages utiliseront encore l&#8217;URL originale.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_distants"><a class="anchor" href="#_distants"></a>DISTANTS<a id="REMOTES"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Le nom de l&#8217;un des éléments suivants peut être utilisé à la place d&#8217;une URL en tant qu&#8217;argument <code>&lt;dépôt&gt;</code> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>un distant dans le fichier de configuration Git : <code>$GIT_DIR/config</code>,</p>
</li>
<li>
<p>un fichier dans le répertoire <code>$GIT_DIR/remotes</code>, ou</p>
</li>
<li>
<p>un fichier dans le répertoire <code>$GIT_DIR/branches</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Toutes ces options vous permettent également d&#8217;omettre le spécificateur de référence de la ligne de commande car elles contiennent chacune un spécificateur de référence que git utilisera par défaut.</p>
</div>
<div class="sect2">
<h3 id="_distant_nommé_dans_le_fichier_de_configuration"><a class="anchor" href="#_distant_nommé_dans_le_fichier_de_configuration"></a>distant nommé dans le fichier de configuration</h3>
<div class="paragraph">
<p>Vous pouvez choisir de fournir le nom d&#8217;un distant que vous aviez précédemment configuré en utilisant <a href='{{< relurl "docs/git-remote/fr" >}}'>git-remote[1]</a>, <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a> ou même par une modification manuelle du fichier <code>$GIT_DIR/config</code>. L&#8217;URL de ce distant sera utilisée pour accéder au dépôt. Le spécificateur de référence de ce distant sera utilisé par défaut lorsque vous ne fournissez pas de spécificateur de référence sur la ligne de commande. L&#8217;entrée dans le fichier de configuration apparaîtra comme ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[remote "&lt;nom&gt;"]
		url = &lt;URL&gt;
		pushurl = &lt;url-poussée&gt;
		push = &lt;spéc-de-réf&gt;
		fetch = &lt;spéc-de-réf&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Le <code>&lt;url-de-poussée&gt;</code> est utilisé uniquement pour les poussées. Il est optionnel et sa valeur par défaut est <code>&lt;URL&gt;</code>. Pousser vers un distant affecte tous les urls-de-poussés définis ou tous les urls définis si aucun url-de-poussée n&#8217;est défini. Fetch, cependant, ne récupérera que le premier url défini si plusieurs urls sont définis.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fichier_nommé_dans_git_dirremotes"><a class="anchor" href="#_fichier_nommé_dans_git_dirremotes"></a>Fichier nommé dans <code>$GIT_DIR/remotes</code></h3>
<div class="paragraph">
<p>Vous pouvez choisir de fournir le nom d&#8217;un fichier dans <code>$GIT_DIR/remotes</code>. L&#8217;URL dans ce fichier sera utilisée pour accéder au dépôt. Le spécificateur de référence dans ce fichier sera utilisé par défaut lorsque vous ne fournissez pas de spécificateur de référence sur la ligne de commande. Ce fichier doit avoir le format suivant :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	URL: un des format d'URL ci-dessus
	Push: &lt;spéc-de-réf&gt;
	Pull: &lt;spéc-de-réf&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Les lignes <code>Push:</code>" sont utilisées par <em>git push</em> et les lignes <code>Pull:</code> sont utilisées par <em>git pull</em> et <em>git fetch</em>. Des lignes <code>Push:</code> et <code>Pull:</code> multiples peuvent être spécifiées pour des mappages supplémentaires de branches.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fichier_nommé_dans_git_dirbranches"><a class="anchor" href="#_fichier_nommé_dans_git_dirbranches"></a>Fichier nommé dans <code>$GIT_DIR/branches</code></h3>
<div class="paragraph">
<p>Vous pouvez choisir de fournir le nom d&#8217;un fichier dans <code>$GIT_DIR/branches</code>. L&#8217;URL de ce fichier sera utilisée pour accéder au dépôt. Ce fichier doit avoir le format suivant :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	&lt;URL&gt;#&lt;tête&gt;</pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;URL&gt;</code> est obligatoire ; <code>#&lt;tête&gt;</code> est facultatif.</p>
</div>
<div class="paragraph">
<p>En fonction de l&#8217;opération, git utilisera l&#8217;un des spécificateurs de référence suivants, si vous n&#8217;en fournissez pas un en ligne de commande. <code>&lt;branche&gt;</code> est le nom de ce fichier dans <code>$GIT_DIR/branches</code> et <code>&lt;tête&gt;</code> vaut par défaut <code>master</code>.</p>
</div>
<div class="paragraph">
<p>git fetch utilise :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	refs/heads/&lt;tête&gt;:refs/heads/&lt;branche&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>git push utilise :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	HEAD:refs/heads/&lt;tête&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_les_stratégies_de_fusion"><a class="anchor" href="#_les_stratégies_de_fusion"></a>LES STRATÉGIES DE FUSION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Le mécanisme de fusion (commandes <code>git merge</code> et <code>git pull</code>) permet de choisir les <em>stratégies de fusion</em> du backend avec l&#8217;option <code>-s</code>. Certaines stratégies peuvent également prendre leurs propres options, qui peuvent être passées en donnant des arguments <code>-X&lt;option&gt;</code> à <code>git merge</code> et/ou <code>git pull</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull-ort"> <a class="anchor" href="#git-pull-ort"></a>ort </dt>
<dd>
<p>C&#8217;est la stratégie de fusion par défaut lors du tirage ou de la fusion d&#8217;une branche. Cette stratégie ne peut résoudre que deux têtes en utilisant un algorithme de fusion à trois voies. Lorsqu&#8217;il y a plus d&#8217;un ancêtre commun qui peut être utilisé pour la fusion à trois, il crée un arbre fusionné des ancêtres communs et l&#8217;utilise comme arbre de référence pour la fusion à trois. Il a été rapporté que cela permettait de réduire les conflits de fusion sans provoquer de fausses fusions, grâce à des tests effectués sur de vraies fusions tirées de l&#8217;historique de développement du noyau Linux 2.6. En outre, cette stratégie permet de détecter et de gérer les fusions impliquant des renommages. Elle ne peut actuellement pas utiliser les copies détectées. Le nom de cet algorithme est un acronyme ("Ostensibly Recursive&#8217;s Twin" : Jumeau ostensible de recurse) et vient du fait qu&#8217;il a été écrit pour remplacer l&#8217;algorithme par défaut précédent, <code>recursive</code>.</p>
<div class="paragraph">
<p>La stratégie <em>ort</em> peut prendre les options suivantes :</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull-ours"> <a class="anchor" href="#git-pull-ours"></a>ours </dt>
<dd>
<p>Cette option oblige à résoudre les sections en conflit de manière autonome et propre en favorisant notre version (<em>our</em>). Les modifications par rapport à l&#8217;autre arbre qui n&#8217;entrent pas en conflit avec notre version se reflètent dans le résultat de la fusion. Pour un fichier binaire, tout le contenu est pris de notre côté.</p>
<div class="paragraph">
<p>Il ne faut pas la confondre avec la stratégie de fusion <em>ours</em>, qui ne tient même pas compte de ce que contient l&#8217;autre arbre. Elle rejette tout ce que l&#8217;autre arbre a fait, déclarant que "notre" historique (<em>our</em>) contient tout ce qui s&#8217;y est passé.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull-theirs"> <a class="anchor" href="#git-pull-theirs"></a>theirs </dt>
<dd>
<p>C&#8217;est le contraire de <em>ours</em> ; notez que, contrairement à <em>ours</em>, il n&#8217;y a pas de stratégie de fusion <em>theirs</em> avec laquelle confondre cette option de fusion.</p>
</dd>
<dt class="hdlist1" id="git-pull-ignore-space-change"> <a class="anchor" href="#git-pull-ignore-space-change"></a>ignore-space-change </dt>
<dt class="hdlist1" id="git-pull-ignore-all-space"> <a class="anchor" href="#git-pull-ignore-all-space"></a>ignore-all-space </dt>
<dt class="hdlist1" id="git-pull-ignore-space-at-eol"> <a class="anchor" href="#git-pull-ignore-space-at-eol"></a>ignore-space-at-eol </dt>
<dt class="hdlist1" id="git-pull-ignore-cr-at-eol"> <a class="anchor" href="#git-pull-ignore-cr-at-eol"></a>ignore-cr-at-eol </dt>
<dd>
<p>Traiter les lignes avec le type de changement d&#8217;espace indiqué comme inchangées dans l&#8217;intérêt d&#8217;une fusion à trois points. Les changements d&#8217;espacement mélangés à d&#8217;autres changements de ligne ne sont pas ignorés. Voir aussi <a href='{{< relurl "docs/git-diff/fr" >}}'>git-diff[1]</a> <code>-b</code>, <code>-w</code>, <code>--ignore-space-at-eol</code>, et <code>--ignore-cr-at-eol</code>.</p>
<div class="ulist">
<ul>
<li>
<p>Si "leur" version (<em>theirs</em>) n&#8217;introduit que des changements d&#8217;espacement sur une ligne, "notre" version (<em>our</em>) est utilisée ;</p>
</li>
<li>
<p>Si "notre" version introduit des modifications dans l&#8217;espace blanc mais que "leur" version inclut un changement substantiel, "leur" version est utilisée ;</p>
</li>
<li>
<p>Dans le cas contraire, la fusion se déroule de la manière habituelle.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1" id="git-pull-renormalize"> <a class="anchor" href="#git-pull-renormalize"></a>renormalize </dt>
<dd>
<p>Il s&#8217;agit d&#8217;une extraction et d&#8217;un validation virtuelle des trois étapes d&#8217;un fichier lors de la résolution d&#8217;une fusion à trois points. Cette option est destinée à être utilisée lors de la fusion de branches avec différents filtres clean ou règles de normalisation de fin de ligne. Voir "Fusion de branches avec différents attributs de validation/extraction" dans <a href='{{< relurl "docs/gitattributes/fr" >}}'>gitattributes[5]</a> pour plus de détails.</p>
</dd>
<dt class="hdlist1" id="git-pull-no-renormalize"> <a class="anchor" href="#git-pull-no-renormalize"></a>no-renormalize </dt>
<dd>
<p>Désactiver l&#8217;option <code>renormalize</code>. Cela surcharge la variable de configuration <code>merge.renormalize</code> .</p>
</dd>
<dt class="hdlist1" id="git-pull-find-renamesltngt"> <a class="anchor" href="#git-pull-find-renamesltngt"></a>find-renames[=&lt;n&gt;] </dt>
<dd>
<p>Activer la détection de renommage, en fixant éventuellement le seuil de similarité. C&#8217;est la valeur par défaut. Cela surcharge la variable de configuration <code>merge.renames</code>. Voir aussi <a href='{{< relurl "docs/git-diff/fr" >}}'>git-diff[1]</a> <code>--find-renames</code>.</p>
</dd>
<dt class="hdlist1" id="git-pull-rename-thresholdltngt"> <a class="anchor" href="#git-pull-rename-thresholdltngt"></a>rename-threshold=&lt;n&gt; </dt>
<dd>
<p>Synonyme obsolète pour <code>find-renames=&lt;n&gt;</code>.</p>
</dd>
<dt class="hdlist1" id="git-pull-subtreeltchemingt"> <a class="anchor" href="#git-pull-subtreeltchemingt"></a>subtree[=&lt;chemin&gt;] </dt>
<dd>
<p>Cette option est une forme plus avancée de stratégie <em>subtree</em>, où la stratégie fait une estimation de la façon dont deux arbres doivent être déplacés pour correspondre l&#8217;un à l&#8217;autre lors de la fusion. Au lieu de cela, le chemin spécifié est préfixé (ou tronqué au debut) pour faire correspondre la forme de deux arbres.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-pull-recursive"> <a class="anchor" href="#git-pull-recursive"></a>recursive </dt>
<dd>
<p>Cela ne peut résoudre que deux têtes en utilisant un algorithme de fusion à trois voies. Lorsqu&#8217;il y a plus d&#8217;un ancêtre commun qui peut être utilisé pour la fusion à trois, il crée un arbre fusionné des ancêtres communs et l&#8217;utilise comme arbre de référence pour la fusion à trois. Il a été rapporté que cela permettait de réduire les conflits de fusion sans provoquer de fausses fusions, grâce à des tests effectués sur de vraies fusions tirées de l&#8217;historique de développement du noyau Linux 2.6. En outre, cela permet de détecter et de gérer les fusions impliquant des renommages. Cela n&#8217;utilise les copies détectées. C&#8217;était la stratégie par défaut lors de la résolution de deux sommets pour Git depuis la version v0.99.9k jusqu&#8217;à v2.33.0.</p>
<div class="paragraph">
<p>La stratégie <em>recursive</em> utilise les mêmes options que <em>ort</em>. Cependant, il y a trois options supplémentaires que <em>ort</em> ignore (non documentées ci-dessus) et qui sont potentiellement utiles avec la stratégie <em>recursive</em> :</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull-patience"> <a class="anchor" href="#git-pull-patience"></a>patience </dt>
<dd>
<p>Synonyme obsolète pour <code>diff-algorithm=patience</code>.</p>
</dd>
<dt class="hdlist1" id="git-pull-diff-algorithmpatienceminimalhistogrammyers"> <a class="anchor" href="#git-pull-diff-algorithmpatienceminimalhistogrammyers"></a>diff-algorithm=[patience|minimal|histogram|myers] </dt>
<dd>
<p>Utiliser un algorithme de diff différent lors des fusions, ce qui peut aider à éviter les erreurs de fusion dues à des lignes de correspondance sans importance (comme des accolades de fonctions distinctes). Voir aussi <a href='{{< relurl "docs/git-diff/fr" >}}'>git-diff[1]</a> <code>--diff-algorithm</code>. Notez que <code>ort</code> utilise spécifiquement <code>diff-algorithm=histogram</code>, alors que <code>recursive</code> utilise par défaut le paramètre de configuration <code>diff.algorithm</code>.</p>
</dd>
<dt class="hdlist1" id="git-pull-no-renames"> <a class="anchor" href="#git-pull-no-renames"></a>no-renames </dt>
<dd>
<p>Désactiver la détection de renommage. Ceci annule la variable de configuration <code>merge.renames</code>. Voir aussi <a href='{{< relurl "docs/git-diff/fr" >}}'>git-diff[1]</a> <code>--no-renames</code>.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-pull-resolve"> <a class="anchor" href="#git-pull-resolve"></a>resolve </dt>
<dd>
<p>Cela ne peut résoudre que deux têtes (c&#8217;est-à-dire la branche actuelle et une autre branche dont vous avez tiré) en utilisant un algorithme de fusion à trois points. Cela essaie de détecter avec soin les ambiguïtés de la fusion croisée. Les renommages ne sont pas gérés.</p>
</dd>
<dt class="hdlist1" id="git-pull-octopus"> <a class="anchor" href="#git-pull-octopus"></a>octopus </dt>
<dd>
<p>Cela permet de résoudre les cas à plus de deux têtes, mais refuse de faire une fusion complexe qui nécessite une résolution manuelle. C&#8217;est principalement destiné à être utilisé pour regrouper les têtes de branches thématiques. C&#8217;est la stratégie de fusion par défaut lorsque l&#8217;on tire ou fusionne plusieurs branches.</p>
</dd>
<dt class="hdlist1" id="git-pull-ours-1"> <a class="anchor" href="#git-pull-ours-1"></a>ours </dt>
<dd>
<p>Cela résout un nombre quelconque de têtes, mais l&#8217;arbre résultant de la fusion est toujours celui de la tête de la branche actuelle, ignorant effectivement toutes les modifications provenant de toutes les autres branches. C&#8217;est censé être utilisé pour remplacer l&#8217;ancienne historique du développement des branches latérales. Notez que cette stratégie est différente de l&#8217;option -Xours de la stratégie de fusion <em>recursive</em>.</p>
</dd>
<dt class="hdlist1" id="git-pull-subtree"> <a class="anchor" href="#git-pull-subtree"></a>subtree </dt>
<dd>
<p>Il s&#8217;agit d&#8217;une stratégie <code>ort</code> modifiée. Lors de la fusion des arbres A et B, si B correspond à un sous-arbre de A, B est d&#8217;abord ajusté pour correspondre à la structure arborescente de A, au lieu de lire les arbres au même niveau. Cet ajustement est également effectué sur l&#8217;arbre de l&#8217;ancêtre commun.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Avec les stratégies qui utilisent la fusion à trois points (y compris la fusion par défaut, <em>ort</em>), si une modification est effectuée sur les deux branches, mais qu&#8217;elle est ensuite inversée sur l&#8217;une des branches, ce changement sera présent dans le résultat de la fusion ; certaines personnes trouvent ce comportement déroutant. Cela se produit parce que seules les têtes et la base de la fusion sont prises en compte lors d&#8217;une fusion, et non le commit individuel. L&#8217;algorithme de fusion considère donc le changement inversé comme n&#8217;étant pas un changement du tout, et substitue la version modifiée à la place.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comportement_par_défaut"><a class="anchor" href="#_comportement_par_défaut"></a>COMPORTEMENT PAR DÉFAUT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Souvent, les gens utilisent <code>git pull</code> sans donner aucun paramètre. Traditionnellement, cela équivaut à dire <code>git pull origin</code>. Cependant, lorsque la configuration <code>branch.&lt;nom&gt;.remote</code> est présente alors que sur la branche <code>&lt;nom&gt;</code>, cette valeur est utilisée à la place de <code>origin</code>.</p>
</div>
<div class="paragraph">
<p>Afin de déterminer l&#8217;URL à utiliser pour récupérer, la valeur de la configuration <code>remote. &lt;origine&gt; .url</code> est consultée et s&#8217;il n&#8217;y a pas une telle variable, la valeur sur la ligne <code>URL:</code> dans <code>$GIT_DIR/remotes/&lt;origine&gt;</code> est utilisée.</p>
</div>
<div class="paragraph">
<p>Afin de déterminer les branches distantes à récupérer (et éventuellement stocker dans les branches de suivi à distance) lorsque la commande est exécutée sans aucun paramètre spéc-de-réf sur la ligne de commande, les valeurs de la variable de configuration <code>remote. &lt;origine&gt; .fetch</code> sont consultées , et s&#8217;il n&#8217;y en a pas, <code>$GIT_DIR/remotes/&lt;origine&gt;</code> est consulté et ses lignes <code>Pull :</code> sont utilisées. En plus des formats spéc-de-réf décrits dans la section OPTIONS, vous pouvez avoir un motif de spécificateur de référence qui ressemble à ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>refs/heads/*:refs/remotes/origin/*</pre>
</div>
</div>
<div class="paragraph">
<p>Un motif de spécificateur de référence doit avoir un partie droite non vide (c&#8217;est-à-dire qu&#8217;elle doit stocker ce qui a été récupéré dans des branches de suivi à distance), et ses parties gauches et parties droites doivent se terminer par <code>/*</code>. Ce qui précède précise que toutes les branches distantes sont suivies en utilisant les branches de suivi à distance dans la hiérarchie <code>refs/remotes/origin/</code> sous le même nom.</p>
</div>
<div class="paragraph">
<p>La règle qui consiste à déterminer quelle branche distante doit être fusionnée après avoir été récupérée est un peu compliquée, afin de ne pas rompre la rétrocompatibilité.</p>
</div>
<div class="paragraph">
<p>Si des spécificateurs de référence explicites ont été donnés sur la ligne de commande de <code>git pull</code>, elles sont toutes fusionnées.</p>
</div>
<div class="paragraph">
<p>Lorsqu&#8217;aucun spécificateur de référence n&#8217;a été donné sur la ligne de commande, alors <code>git pull</code> utilise le spécificateur de référence de la configuration ou <code>$GIT_DIR/remotes/&lt;origine&gt;</code>. Dans de tels cas, les règles suivantes s&#8217;appliquent :</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Si la configuration <code>branch.&lt;nom&gt;.merge</code> pour la branche actuelle <code>&lt;nom&gt;</code> existe, c&#8217;est le nom de la branche du site distant en cours de fusion.</p>
</li>
<li>
<p>Si le spécificateur de référence est un spécificateur motif, rien n&#8217;est fusionné.</p>
</li>
<li>
<p>Sinon, la branche distante du premier spécificateur de référence est fusionnée.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemples"><a class="anchor" href="#_exemples"></a>EXEMPLES</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Mettre à jour les branches de suivi à distance pour le dépôt d&#8217;où vous avez cloné, puis fusionner l&#8217;une d&#8217;entre elles dans votre branche actuelle :</p>
<div class="listingblock">
<div class="content">
<pre>$ git pull
$ git pull origin</pre>
</div>
</div>
<div class="paragraph">
<p>Normalement, la branche fusionnée est la HEAD du dépôt distant, mais le choix est déterminé par les options branch. &lt;nom&gt; .remote et branch. &lt;nom&gt; .merge ; voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a> pour plus de détails.</p>
</div>
</li>
<li>
<p>Fusionner dans la branche actuelle la branche distante <code>next</code> :</p>
<div class="listingblock">
<div class="content">
<pre>$ git pull origin next</pre>
</div>
</div>
<div class="paragraph">
<p>Cela laisse une copie de <code>next</code> temporairement dans FETCH_HEAD, et met pas à jour la branche de suivi à distance <code>origin/next</code>. La même chose peut être faite en invoquant fetch et merge :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fetch origin
$ git merge origin/next</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Si vous avez tenté un tirage qui a entraîné des conflits complexes et que vous souhaitez recommencer à zéro, vous pouvez vous rembobiner grâce à <em>git reset</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sécurité"><a class="anchor" href="#_sécurité"></a>SÉCURITÉ</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Les protocoles "fetch" et "push" ne sont pas conçus pour empêcher un tiers de voler des données de l&#8217;autre dépôt qui n&#8217;étaient pas destinées à être partagées. Si vous avez des données privées que vous devez protéger contre un tiers malveillant, la meilleure solution est de les stocker dans un autre dépôt. Cela s&#8217;applique aussi bien aux clients qu&#8217;aux serveurs. En particulier, les espaces de noms sur un serveur ne sont pas efficaces pour le contrôle de l&#8217;accès en lecture ; vous ne devez accorder l&#8217;accès en lecture à un espace de noms qu&#8217;aux clients auxquels vous feriez confiance pour l&#8217;accès en lecture à l&#8217;ensemble du dépôt.</p>
</div>
<div class="paragraph">
<p>Les vecteurs d&#8217;attaque connus sont les suivants :</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La victime envoie des lignes "have" annonçant les identifiants des objets qu&#8217;elle possède et qui ne sont pas explicitement destinés à être partagés, mais qui peuvent être utilisés pour optimiser le transfert si le pair les possède également. L&#8217;attaquant choisit un ID d&#8217;objet X à voler et envoie une référence à X, mais n&#8217;est pas obligé d&#8217;envoyer le contenu de X parce que la victime l&#8217;a déjà. La victime croit maintenant que l&#8217;attaquant a X, et elle lui renvoie le contenu de X plus tard. (Cette attaque est la plus simple à réaliser pour un client sur un serveur, en créant une référence à X dans l&#8217;espace de noms auquel le client a accès et en la récupérant ensuite. La façon la plus probable pour un serveur de l&#8217;exécuter sur un client est de "fusionner" X dans une branche publique et d&#8217;espérer que l&#8217;utilisateur fasse un travail supplémentaire sur cette branche et la repousse vers le serveur sans remarquer la fusion).</p>
</li>
<li>
<p>Comme en n°1, l&#8217;attaquant choisit un objet ID X à voler. La victime envoie un objet Y que l&#8217;attaquant possède déjà, et l&#8217;attaquant prétend faussement avoir X et non Y, de sorte que la victime envoie Y comme delta contre X. Le delta révèle à l&#8217;attaquant des régions de X qui sont similaires à Y.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bogues"><a class="anchor" href="#_bogues"></a>BOGUES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>L&#8217;utilisation de --recurse-submodules ne permet actuellement d&#8217;obtenir de nouveaux commits que dans les sous-modules déjà vérifiés . Lorsque, par exemple, un nouveau sous-module est ajouté dans les commit en amont qui viennent d&#8217;être récupérés du superprojet, le sous-module lui-même ne peut pas être récupéré, ce qui rend impossible de vérifier ce sous-module plus tard sans avoir à le récupérer à nouveau. Ce problème devrait être corrigé dans une prochaine version de Git.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_voir_aussi"><a class="anchor" href="#_voir_aussi"></a>VOIR AUSSI</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-fetch/fr" >}}'>git-fetch[1]</a>, <a href='{{< relurl "docs/git-merge/fr" >}}'>git-merge[1]</a>, <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fait partie de la suite <a href='{{< relurl "docs/git/fr" >}}'>git[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traduction"><a class="anchor" href="#_traduction"></a>TRADUCTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cette  page de manuel a été traduite par Jean-Noël Avila &lt;jn.avila AT free DOT fr&gt; et les membres du projet git-manpages-l10n. Veuillez signaler toute erreur de traduction par un rapport de bogue sur le site <a href="https://github.com/jnavila/git-manpages-l10n" class="bare">https://github.com/jnavila/git-manpages-l10n</a> .</p>
</div>
</div>
</div>