git-pack-refs(1)
================

名称
--
git-pack-refs - 打包头和标签，以便有效地访问仓库

概述
--
[verse]
'git pack-refs' [--all] [--no-prune] [--auto] [--include <pattern>] [--exclude <pattern>]

描述
--

传统上，分支和标签的提示（统称为 'refs'）是在 `$GIT_DIR/refs` 目录下的一个（子）目录中，为每个引用储存一个文件。 虽然许多分支的提示经常被更新，但大多数标签和一些分支的提示从未被更新。 当一个仓库库有成百上千的标签时，这种每个引用一个文件的格式既浪费了存储空间，又损害了性能。

这个命令是用来解决存储和性能问题的，将引用存储在一个文件中，`$GIT_DIR/packed-refs`。 当传统的 `$GIT_DIR/refs`目录层次中缺少一个引用时，就在这个文件中查找，如果找到就使用。

分支的后续更新总是在 `$GIT_DIR/refs` 目录层次下创建新文件。

处理一个有太多引用的仓库的推荐做法是，用 `--all` 来打包它的引用一次，然后偶尔运行 `git pack-refs` 。 根据定义，标签是固定的，不应该改变。 分支头会被初始的 `pack-refs --all` 打包，但只有当前活动的分支头会被解压，下一次 `pack-refs`（没有 `--all`）会让它们被解压。


选项
--

--all::

该命令默认打包所有已打包的标签和引用，而不打包其他引用。 这是因为分支会被积极开发，打包它们的提示无助于提高性能。 该选项会导致所有 引用也被打包，但隐藏引用、破损引用和符号引用除外。对于有许多具有历史意义的分支的仓库来说非常有用。

--no-prune::

该命令通常在打包后删除 `$GIT_DIR/refs` 层次下的松散引用。 这个选项告诉它不要这样做。

--auto::

根据引用数据库的当前状态按需打包引用。行为取决于仓库使用的引用格式，并可能在将来发生变化。
+
	- "files"：尚未为 `--auto` 实现特殊处理。
+
	- "reftable"：表被压缩，使得它们形成一个几何序列。对于两个表 N 和 N+1，其中 N+1 较新，这保持了 N 至少是 N+1 两倍大的属性。只有违反这个属性的表才会被压缩。

--include <模式>::

根据 `glob(7)` 模式打包引用。重复使用该选项会累积包含模式。如果一个引用同时包含在 `--include` 和 `--exclude` 中，则 `--exclude` 优先。使用 `--include` 会默认排除所有标记。符号引用和断开的引用将永远不会被打包。与 `--all` 一起使用时，它将是一个 空操作。使用 `--no-include` 清除并重置模式列表。

--exclude <模式>::

不打包与给定的 `glob(7)` 模式匹配的引用。重复使用此选项会累积排除模式。使用 `--no-exclude` 可以清除并重置模式列表。如果一个引用已经打包，使用 `--exclude`不会将其解包。

与 `--all` 一起使用时，只打包与所提供的 `--exclude` 模式不匹配的松散引用。

当与 `--include` 一起使用时，提供给 `--include` 的引用减去提供给 `--exclude` 的引用将被打包。


漏洞
--

在引入 packed-refs 机制之前编写的旧文档可能仍然会说 ".git/refs/heads/<branch>文件存在" 这样的话，而它的意思是 "<branch> 分支存在"。


GIT
---
属于 linkgit:git[1] 文档
