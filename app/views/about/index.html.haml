- @section = "about"
- @subsection = ""

- content_for :sidebar do
  %div.callout
    %p
      The entire <strong><a href="#">Pro Git book</a></strong> written by Scott Chacon is available to <a href="#">read online for free</a>. Dead tree versions are available on <a href="#">Amazon.com</a>.

%div#main
  %h1 About

  %ol#about-nav
    %li
      <a href="#" class="current three-line" id="nav-branching-and-merging" data-section-id="branching-and-merging">Branching and Merging</a>
    %li
      <a href="#" class="two-line" id="nav-small-and-fast" data-section-id="small-and-fast">Small and Fast</a>
    %li
      <a href="#" class="one-line" id="nav-distributed" data-section-id="distributed">Distributed</a>
    %li
      <a href="#" class="two-line" id="nav-multiple-workflows" data-section-id="multiple-workflows">Multiple Workflows</a>
    %li
      <a href="#" class="two-line" id="nav-staging-area" data-section-id="staging-area">Staging Area</a>
    %li
      <a href="#" class="three-line" id="nav-free-and-open-sourced" data-section-id="free-and-open-sourced">Free and Open Sourced</a>

  %section.about#branching-and-merging.current
    %h2 Branching and Merging

    %p
      Probably Git's most compelling feature that really makes it stand
      apart from nearly every other SCM out there is its branching
      model.  It is completely different from all of the models I'm 
      comparing it to here, most of which recommend that the best branch
      is basically a clone of the repository in a new directory.

    %p
      Git does not work like that.  Git will allow you to have multiple
      local branches that can be entirely independent of each other and
      the creation, merging and deletion of those lines of development
      take seconds.

    %p
      This means that you can do things like:

    %ul.bullets
      %li
        Create a branch to try out an idea, commit a few times, switch back to where you branched from, apply a patch, switch back to where you are experimenting, then merge it in.
      %li
        Have a branch that always contains only what goes to production, another that you merge work into for testing and several smaller ones for day to day work
      %li
        Create new branches for each new feature you're working on, so you can seamlessly switch back and forth between them, then delete each branch when that feature gets merged into your main line.
      %li
        Create a branch to experiment in, realize it's not going to work and just delete it, abandoning the work—with nobody else ever seeing it (even if you've pushed other branches in the meantime)

    %p
      <img src="/images/about/branches.png" alt="Branches" />

    %p
      Importantly, when you push to a remote repository, you do not have to push all of your branches. You can only share one of your branches and not all of them. This tends to free people to try new ideas without worrying about having to plan how and when they are going to merge it in or share it with others.

    %p
      You can find ways to do some of this with other systems, but the work involved is much more difficult and error-prone. Git makes this process incredibly easy and it changes the way most developers work when they learn it.

    %div.bottom-nav
      =link_to "Small and Fast →", "#", {:class => 'next', 'data-section-id' => 'small-and-fast'}


  %section.about#small-and-fast
    %h2 Small and Fast

    %p
      Git is fast. Everyone—even most of the hard core users of these other systems—generally give Git this title. With Git, all operations are performed locally giving it a bit of a leg up on SVN and Perforce, both of which require network access for certain operations. However, even compared to the other DSCMs that also perform operations locally, Git is pretty fast.

    %p
      Part of this is likely because it was built to work on the Linux kernel, which means that it has had to deal effectively with large repositories from day one. Additionally, Git is written in C, reducing the overhead of runtimes associated with higher-level languages. Another reason that Git is so fast is that the primary developers have made this a design goal of the application.

    %p
      The following are a number of benchmarks that I performed on three copies of the Django source code repository in 3 different SCMs: Git, Mercurial and Bazaar. I also tested some of this stuff in SVN, but trust me, it's slower—basically take the Bazaar numbers and then add network latency...

    <table>  
    <tr><td class="nowrap">
    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:2,5,60&amp;chds=0,60&amp;chxt=x&amp;chco=009099&amp;chl=git|hg|bzr&amp;chf=bg,s,fcfcfa&amp;chtt=Init" alt="init benchmarks" />

    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:85,3,23&amp;chds=0,100&amp;chxt=x&amp;chco=009099&amp;chl=git|hg|bzr&amp;chf=bg,s,fcfcfa&amp;chtt=Add" alt="add benchmarks" />

    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:45,194,1474&amp;chds=0,1474&amp;chxt=x&amp;chco=009099&amp;chl=git|hg|bzr&amp;chf=bg,s,fcfcfa&amp;chtt=Status" alt="status benchmarks" />

    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:5,21,142&amp;chds=0,142&amp;chxt=x&amp;chco=009099&amp;chl=git|hg|bzr&amp;chf=bg,s,fcfcfa&amp;chtt=Diff" alt="diff benchmarks" />
    </td><td rowspan="2">
    <img src="http://chart.apis.google.com/chart?cht=bvg&amp;chs=190x275&amp;chd=t:1,123,390|11,946,820&amp;chds=0,1210&amp;chxt=x&amp;chco=009099,7fc7cc&amp;chl=git|hg|bzr&amp;chf=bg,s,fcfcfa&amp;chtt=Branching" alt="branching benchmarks" />
    </td></tr>
    <tr><td class="nowrap">
    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:5,120,189&amp;chds=0,230&amp;chxt=x&amp;chco=009099&amp;chl=git|hg|bzr&amp;chf=bg,s,fcfcfa&amp;chtt=Tag" alt="tag benchmarks" />

    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:7,26,90&amp;chds=0,90&amp;chxt=x&amp;chco=009099&amp;chl=git|hg|bzr&amp;chf=bg,s,fcfcfa&amp;chtt=Log" alt="log benchmarks" />

    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:124,125,230&amp;chds=0,230&amp;chxt=x&amp;chco=009099&amp;chl=git|hg|bzr&amp;chf=bg,s,fcfcfa&amp;chtt=Commit+(Lg)" alt="large commit benchmarks" />

    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:8,51,113&amp;chds=0,113&amp;chxt=x&amp;chco=009099&amp;chl=git|hg|bzr&amp;chf=bg,s,fcfcfa&amp;chtt=Commit+(Sm)" alt="small commit benchmarks" />
    </td></tr>
    </table>

    %p
      The end result was that for everything but adding new files, Git was fastest. (Also really large commits, which Hg was basically the same at, but the commit I tested was so large that you're unlikely to ever do anything like it—normal commits are much faster in Git.)

    <table width="100%" class="data">
    <tr>
    <th></th>
    <th>Git</th>
    <th>Hg</th>
    <th>Bzr</th>
    </tr>
    <tr>
    <th>Init</th>
    <td class="sweet">0.024s</td>
    <td>0.059s</td>
    <td>0.600s</td>
    </tr>
    <tr>
    <th>Add</th>
    <td>8.535s</td>
    <td class="sweet">0.368s</td>
    <td>2.381s</td>
    </tr>
    <tr>
    <th>Status</th>
    <td class="sweet">0.451s</td>
    <td>1.946s</td>
    <td>14.744s</td>
    </tr>
    <tr>
    <th>Diff</th>
    <td class="sweet">0.543s</td>
    <td>2.189s</td>
    <td>14.248s</td>
    </tr>
    <tr>
    <th>Tag</th>
    <td class="sweet">0.056s</td>
    <td>1.201s</td>
    <td>1.892s</td>
    </tr>
    <tr>
    <th>Log</th>
    <td class="sweet">0.711s</td>
    <td>2.650s</td>
    <td>9.055s</td>
    </tr>
    <tr>
    <th>Commit (Large)</th>
    <td class="sweet">12.480s</td>
    <td>12.500s</td>
    <td>23.002s</td>
    </tr>
    <tr>
    <th>Commit (Small)</th>
    <td class="sweet">0.086s</td>
    <td>0.517s</td>
    <td>1.139s</td>
    </tr>
    <tr>
    <th>Branch (Cold)</th>
    <td class="sweet">1.161s</td>
    <td>94.681s</td>
    <td>82.249s</td>
    </tr>
    <tr>
    <th>Branch (Hot)</th>
    <td class="sweet">0.070s</td>
    <td>12.300s</td>
    <td>39.411s</td>
    </tr>
    </table>

    %p
      The cold and hot branching numbers are the numbers for the first and second times that I branched a repo—the second number being a branch with a hot disk cache.

    %p
      It should be noted that although the 'add' numbers are much slower, this was for a massive add operation—over 2000 files. For the majority of what most people do on a daily basis, add ops in any of these systems will only take a fraction of a second. All of the other ops tested here (except for the large commit, possibly) are more indicative of things you might actually do day to day.
    
    %p
      These numbers are really not difficult to recreate, simply clone the Django project in each of the systems and try out the same commands in each.
            

    %code
      git clone git://github.com/brosner/django.git dj-git

    %code
      hg clone http://hg.dpaste.com/django/trunk dj-hg

    %code
      bzr branch lp:django dj-bzr

    %code
      svn checkout http://code.djangoproject.com/svn/django/trunk dj-svn

    %div.bottom-nav
      =link_to "← Branching and Merging", "#", {:class => 'previous', 'data-section-id' => 'branching-and-merging'}
      =link_to "Distributed →", "#", {:class => 'next', 'data-section-id' => 'distributed'}

  %section.about#distributed
    %h2 Distributed

    %p
      One of the coolest features of any of the Distributed SCMs, Git included, is that it's distributed. This means that instead of doing a "checkout" of the current tip of the source code, you do a "clone" of the entire repository.

    %p
      This means that even if you're using a centralized workflow, every user has what is essentially a full backup of the main server, each of which could be pushed up to replace the main server in the event of a crash or corruption. There is basically no single point of failure with Git unless there is only a single point.

    %p
      This does not slow things down much, either. On average, an SVN checkout is only marginally faster than any of the DSCMs. Of the DSCMs I tested, Git was the fastest.

    <table>
    <tr><td>
    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=200x150&amp;chd=t:120,144,311,64&amp;chds=0,320&amp;chco=009099&amp;chl=git|hg|bzr|svn&amp;chf=bg,s,fcfcfa&amp;chtt=Clone" alt="cloning benchmarks" />
    </td><td style="width: 80%">
    <table width="100%" class="data">
    <tr>
    <th>Git</th>
    <td class="sweet">1m 59s</td>
    </tr>
    <tr>
    <th>Hg</th>
    <td>2m 24s</td>
    </tr>
    <tr>
    <th>Bzr</th>
    <td>5m 11s</td>
    </tr>
    <tr>
    <th>SVN</th>
    <td>1m 4s</td>
    </tr>
    </table>
    </td></tr>
    </table>

    %div.bottom-nav
      =link_to "← Small and Fast", "#", {:class => 'previous', 'data-section-id' => 'small-and-fast'}
      =link_to "Multiple Workflows →", "#", {:class => 'next', 'data-section-id' => 'multiple-workflows'}

  %section.about#multiple-workflows
    %h2 Multiple Workflows

    %p
      One of the amazing things about Git is that because of its distributed nature and super branching system, you can easily implement pretty much any workflow you can think of relatively easily.

    %h3 Subversion-Style Workflow

    %p
      A very common Git workflow, especially from people transitioning from a centralized system, is a centralized workflow. Git will not allow you to push if someone has pushed since the last time you fetched, so a centralized model where all developers push to the same server works just fine.

    %p
      <img src="/images/about/workflow-a.png" alt="Workflow A" />

    %h3 Integration Manager Workflow

    %p
      Another common Git workflow is where there is an integration manager—a single person who commits to the 'blessed' repository, and then a number of developers who clone from that repository, push to their own independent repositories and ask the integrator to pull in their changes. This is the type of development model you often see with open source or GitHub repositories.

    %p
      <img src="/images/about/workflow-b.png" alt="Workflow B" />

    %h3 Dictator and Lieutenants Workflow

    %p
      For more massive projects, you can setup your developers similar to the way the Linux kernel is run, where people are in charge of a specific subsystem of the project ('lieutenants') and merge in all changes that have to do with that subsystem. Then another integrator (the 'dictator') can pull changes from only his/her lieutenants and the push to the 'blessed' repository that everyone then clones from again.

    %p
      <img src="/images/about/workflow-c.png" alt="Workflow C" />

    %div.bottom-nav
      =link_to "← Distributed", "#", {:class => 'previous', 'data-section-id' => 'distributed'}
      =link_to "Staging Area →", "#", {:class => 'next', 'data-section-id' => 'staging-area'}

  %section.about#staging-area
    %h2 Staging Area

    %p
      Unlike the other systems, Git has what it calls the "staging area" or "index". This is an intermediate area that you can setup what you want your commit to look like before you commit it.

    %p
      The cool thing about the staging area, and what sets Git apart from all these other tools, is that you can easily stage some of your files as you finish them and then commit them without committing all the modified files in your working directory, or having to list them on the command line during the commit

    %p
      <img src="/images/about/index1.png" alt="Index 1" />

    %p
      This also allows you to stage only portions of a modified file. Gone are the days of making two logically unrelated modifications to a file before you realized that you forgot to commit one them. Now you can just stage the change you need for the current commit and stage the other change for the next commit. This feature scales up to as many different changes to your file as you need.

    %p
      Of course, Git also makes it pretty easy to ignore this feature if you don't want that kind of control—just slap a '-a' to your commit command in order to add all changes to all files to the staging area.

    %p
      <img src="/images/about/index2.png" alt="Index 2" />

    %div.bottom-nav
      =link_to "← Multiple Workflows", "#", {:class => 'previous', 'data-section-id' => 'multiple-workflows'}
      =link_to "Free and Open Sourced →", "#", {:class => 'next', 'data-section-id' => 'free-and-open-sourced'}


  %section.about#free-and-open-sourced
    %h2 Free and Open Sourced

    %p
      Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
      tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
      quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
      consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
      cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
      proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

    %p
      Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
      tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
      quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
      consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
      cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
      proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

    %div.bottom-nav
      =link_to "← Staging Area", "#", {:class => 'previous', 'data-section-id' => 'staging-area'}
