<div class='man-page'>
  <div id="header">
  <h1>
  git-rebase(1) Manual Page
  </h1>
  <h2>NAME</h2>
  <div class="sectionbody">
  <p>git-rebase -
     Forward-port local commits to the updated upstream head
  </p>
  </div>
  </div>
  <h2 id="_synopsis">SYNOPSIS</h2>
  <div class="sectionbody">
  <div class="verseblock">
  <div class="verseblock-content"><em>git rebase</em> [-i | --interactive] [options] [--onto &lt;newbase&gt;]
           [&lt;upstream&gt;] [&lt;branch&gt;]
<em>git rebase</em> [-i | --interactive] [options] --onto &lt;newbase&gt;
           --root [&lt;branch&gt;]
<em>git rebase</em> --continue | --skip | --abort</div>
  <div class="verseblock-attribution">
  </div></div>
  </div>
  <h2 id="_description">DESCRIPTION</h2>
  <div class="sectionbody">
  <div class="paragraph"><p>If &lt;branch&gt; is specified, <em>git rebase</em> will perform an automatic
  <tt>git checkout &lt;branch&gt;</tt> before doing anything else.  Otherwise
  it remains on the current branch.</p></div>
  <div class="paragraph"><p>If &lt;upstream&gt; is not specified, the upstream configured in
  branch.&lt;name&gt;.remote and branch.&lt;name&gt;.merge options will be used; see
  <a href="git-config.html">git-config(1)</a> for details.  If you are currently not on any
  branch or if the current branch does not have a configured upstream,
  the rebase will abort.</p></div>
  <div class="paragraph"><p>All changes made by commits in the current branch but that are not
  in &lt;upstream&gt; are saved to a temporary area.  This is the same set
  of commits that would be shown by <tt>git log &lt;upstream&gt;..HEAD</tt> (or
  <tt>git log HEAD</tt>, if --root is specified).</p></div>
  <div class="paragraph"><p>The current branch is reset to &lt;upstream&gt;, or &lt;newbase&gt; if the
  --onto option was supplied.  This has the exact same effect as
  <tt>git reset --hard &lt;upstream&gt;</tt> (or &lt;newbase&gt;).  ORIG_HEAD is set
  to point at the tip of the branch before the reset.</p></div>
  <div class="paragraph"><p>The commits that were previously saved into the temporary area are
  then reapplied to the current branch, one by one, in order. Note that
  any commits in HEAD which introduce the same textual changes as a commit
  in HEAD..&lt;upstream&gt; are omitted (i.e., a patch already accepted upstream
  with a different commit message or timestamp will be skipped).</p></div>
  <div class="paragraph"><p>It is possible that a merge failure will prevent this process from being
  completely automatic.  You will have to resolve any such merge failure
  and run <tt>git rebase --continue</tt>.  Another option is to bypass the commit
  that caused the merge failure with <tt>git rebase --skip</tt>.  To check out the
  original &lt;branch&gt; and remove the .git/rebase-apply working files, use the
  command <tt>git rebase --abort</tt> instead.</p></div>
  <div class="paragraph"><p>Assume the following history exists and the current branch is "topic":</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>          A---B---C topic&#x000A;         /&#x000A;    D---E---F---G master</tt></pre>
  </div></div>
  <div class="paragraph"><p>From this point, the result of either of the following commands:</p></div>
  <div class="literalblock">
  <div class="content">
  <pre><tt>git rebase master&#x000A;git rebase master topic</tt></pre>
  </div></div>
  <div class="paragraph"><p>would be:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>                  A'--B'--C' topic&#x000A;                 /&#x000A;    D---E---F---G master</tt></pre>
  </div></div>
  <div class="paragraph"><p><strong>NOTE:</strong> The latter form is just a short-hand of <tt>git checkout topic</tt>
  followed by <tt>git rebase master</tt>. When rebase exits <tt>topic</tt> will
  remain the checked-out branch.</p></div>
  <div class="paragraph"><p>If the upstream branch already contains a change you have made (e.g.,
  because you mailed a patch which was applied upstream), then that commit
  will be skipped. For example, running &#8216;git rebase master` on the
  following history (in which A&#8217; and A introduce the same set of changes,
  but have different committer information):</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>          A---B---C topic&#x000A;         /&#x000A;    D---E---A'---F master</tt></pre>
  </div></div>
  <div class="paragraph"><p>will result in:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>                   B'---C' topic&#x000A;                  /&#x000A;    D---E---A'---F master</tt></pre>
  </div></div>
  <div class="paragraph"><p>Here is how you would transplant a topic branch based on one
  branch to another, to pretend that you forked the topic branch
  from the latter branch, using <tt>rebase --onto</tt>.</p></div>
  <div class="paragraph"><p>First let&#8217;s assume your <em>topic</em> is based on branch <em>next</em>.
  For example, a feature developed in <em>topic</em> depends on some
  functionality which is found in <em>next</em>.</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>    o---o---o---o---o  master&#x000A;         \&#x000A;          o---o---o---o---o  next&#x000A;                           \&#x000A;                            o---o---o  topic</tt></pre>
  </div></div>
  <div class="paragraph"><p>We want to make <em>topic</em> forked from branch <em>master</em>; for example,
  because the functionality on which <em>topic</em> depends was merged into the
  more stable <em>master</em> branch. We want our tree to look like this:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>    o---o---o---o---o  master&#x000A;        |            \&#x000A;        |             o'--o'--o'  topic&#x000A;         \&#x000A;          o---o---o---o---o  next</tt></pre>
  </div></div>
  <div class="paragraph"><p>We can get this using the following command:</p></div>
  <div class="literalblock">
  <div class="content">
  <pre><tt>git rebase --onto master next topic</tt></pre>
  </div></div>
  <div class="paragraph"><p>Another example of --onto option is to rebase part of a
  branch.  If we have the following situation:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>                            H---I---J topicB&#x000A;                           /&#x000A;                  E---F---G  topicA&#x000A;                 /&#x000A;    A---B---C---D  master</tt></pre>
  </div></div>
  <div class="paragraph"><p>then the command</p></div>
  <div class="literalblock">
  <div class="content">
  <pre><tt>git rebase --onto master topicA topicB</tt></pre>
  </div></div>
  <div class="paragraph"><p>would result in:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>                 H'--I'--J'  topicB&#x000A;                /&#x000A;                | E---F---G  topicA&#x000A;                |/&#x000A;    A---B---C---D  master</tt></pre>
  </div></div>
  <div class="paragraph"><p>This is useful when topicB does not depend on topicA.</p></div>
  <div class="paragraph"><p>A range of commits could also be removed with rebase.  If we have
  the following situation:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>    E---F---G---H---I---J  topicA</tt></pre>
  </div></div>
  <div class="paragraph"><p>then the command</p></div>
  <div class="literalblock">
  <div class="content">
  <pre><tt>git rebase --onto topicA~5 topicA~3 topicA</tt></pre>
  </div></div>
  <div class="paragraph"><p>would result in the removal of commits F and G:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>    E---H'---I'---J'  topicA</tt></pre>
  </div></div>
  <div class="paragraph"><p>This is useful if F and G were flawed in some way, or should not be
  part of topicA.  Note that the argument to --onto and the &lt;upstream&gt;
  parameter can be any valid commit-ish.</p></div>
  <div class="paragraph"><p>In case of conflict, <em>git rebase</em> will stop at the first problematic commit
  and leave conflict markers in the tree.  You can use <em>git diff</em> to locate
  the markers (&lt;&lt;&lt;&lt;&lt;&lt;) and make edits to resolve the conflict.  For each
  file you edit, you need to tell git that the conflict has been resolved,
  typically this would be done with</p></div>
  <div class="literalblock">
  <div class="content">
  <pre><tt>git add &lt;filename&gt;</tt></pre>
  </div></div>
  <div class="paragraph"><p>After resolving the conflict manually and updating the index with the
  desired resolution, you can continue the rebasing process with</p></div>
  <div class="literalblock">
  <div class="content">
  <pre><tt>git rebase --continue</tt></pre>
  </div></div>
  <div class="paragraph"><p>Alternatively, you can undo the <em>git rebase</em> with</p></div>
  <div class="literalblock">
  <div class="content">
  <pre><tt>git rebase --abort</tt></pre>
  </div></div>
  </div>
  <h2 id="_configuration">CONFIGURATION</h2>
  <div class="sectionbody">
  <div class="dlist"><dl>
  <dt class="hdlist1">
  rebase.stat
  </dt>
  <dd>
  <p>
          Whether to show a diffstat of what changed upstream since the last
          rebase. False by default.
  </p>
  </dd>
  <dt class="hdlist1">
  rebase.autosquash
  </dt>
  <dd>
  <p>
          If set to true enable <em>--autosquash</em> option by default.
  </p>
  </dd>
  </dl></div>
  </div>
  <h2 id="_options">OPTIONS</h2>
  <div class="sectionbody">
  <div class="dlist"><dl>
  <dt class="hdlist1">
  &lt;newbase&gt;
  </dt>
  <dd>
  <p>
          Starting point at which to create the new commits. If the
          --onto option is not specified, the starting point is
          &lt;upstream&gt;.  May be any valid commit, and not just an
          existing branch name.
  </p>
  <div class="paragraph"><p>As a special case, you may use "A...B" as a shortcut for the
  merge base of A and B if there is exactly one merge base. You can
  leave out at most one of A and B, in which case it defaults to HEAD.</p></div>
  </dd>
  <dt class="hdlist1">
  &lt;upstream&gt;
  </dt>
  <dd>
  <p>
          Upstream branch to compare against.  May be any valid commit,
          not just an existing branch name. Defaults to the configured
          upstream for the current branch.
  </p>
  </dd>
  <dt class="hdlist1">
  &lt;branch&gt;
  </dt>
  <dd>
  <p>
          Working branch; defaults to HEAD.
  </p>
  </dd>
  <dt class="hdlist1">
  --continue
  </dt>
  <dd>
  <p>
          Restart the rebasing process after having resolved a merge conflict.
  </p>
  </dd>
  <dt class="hdlist1">
  --abort
  </dt>
  <dd>
  <p>
          Abort the rebase operation and reset HEAD to the original
          branch. If &lt;branch&gt; was provided when the rebase operation was
          started, then HEAD will be reset to &lt;branch&gt;. Otherwise HEAD
          will be reset to where it was when the rebase operation was
          started.
  </p>
  </dd>
  <dt class="hdlist1">
  --skip
  </dt>
  <dd>
  <p>
          Restart the rebasing process by skipping the current patch.
  </p>
  </dd>
  <dt class="hdlist1">
  -m
  </dt>
  <dt class="hdlist1">
  --merge
  </dt>
  <dd>
  <p>
          Use merging strategies to rebase.  When the recursive (default) merge
          strategy is used, this allows rebase to be aware of renames on the
          upstream side.
  </p>
  <div class="paragraph"><p>Note that a rebase merge works by replaying each commit from the working
  branch on top of the &lt;upstream&gt; branch.  Because of this, when a merge
  conflict happens, the side reported as <em>ours</em> is the so-far rebased
  series, starting with &lt;upstream&gt;, and <em>theirs</em> is the working branch.  In
  other words, the sides are swapped.</p></div>
  </dd>
  <dt class="hdlist1">
  -s &lt;strategy&gt;
  </dt>
  <dt class="hdlist1">
  --strategy=&lt;strategy&gt;
  </dt>
  <dd>
  <p>
          Use the given merge strategy.
          If there is no <tt>-s</tt> option <em>git merge-recursive</em> is used
          instead.  This implies --merge.
  </p>
  <div class="paragraph"><p>Because <em>git rebase</em> replays each commit from the working branch
  on top of the &lt;upstream&gt; branch using the given strategy, using
  the <em>ours</em> strategy simply discards all patches from the &lt;branch&gt;,
  which makes little sense.</p></div>
  </dd>
  <dt class="hdlist1">
  -X &lt;strategy-option&gt;
  </dt>
  <dt class="hdlist1">
  --strategy-option=&lt;strategy-option&gt;
  </dt>
  <dd>
  <p>
          Pass the &lt;strategy-option&gt; through to the merge strategy.
          This implies <tt>--merge</tt> and, if no strategy has been
          specified, <tt>-s recursive</tt>.  Note the reversal of <em>ours</em> and
          <em>theirs</em> as noted in above for the <tt>-m</tt> option.
  </p>
  </dd>
  <dt class="hdlist1">
  -q
  </dt>
  <dt class="hdlist1">
  --quiet
  </dt>
  <dd>
  <p>
          Be quiet. Implies --no-stat.
  </p>
  </dd>
  <dt class="hdlist1">
  -v
  </dt>
  <dt class="hdlist1">
  --verbose
  </dt>
  <dd>
  <p>
          Be verbose. Implies --stat.
  </p>
  </dd>
  <dt class="hdlist1">
  --stat
  </dt>
  <dd>
  <p>
          Show a diffstat of what changed upstream since the last rebase. The
          diffstat is also controlled by the configuration option rebase.stat.
  </p>
  </dd>
  <dt class="hdlist1">
  -n
  </dt>
  <dt class="hdlist1">
  --no-stat
  </dt>
  <dd>
  <p>
          Do not show a diffstat as part of the rebase process.
  </p>
  </dd>
  <dt class="hdlist1">
  --no-verify
  </dt>
  <dd>
  <p>
          This option bypasses the pre-rebase hook.  See also <a href="githooks.html">githooks(5)</a>.
  </p>
  </dd>
  <dt class="hdlist1">
  --verify
  </dt>
  <dd>
  <p>
          Allows the pre-rebase hook to run, which is the default.  This option can
          be used to override --no-verify.  See also <a href="githooks.html">githooks(5)</a>.
  </p>
  </dd>
  <dt class="hdlist1">
  -C&lt;n&gt;
  </dt>
  <dd>
  <p>
          Ensure at least &lt;n&gt; lines of surrounding context match before
          and after each change.  When fewer lines of surrounding
          context exist they all must match.  By default no context is
          ever ignored.
  </p>
  </dd>
  <dt class="hdlist1">
  -f
  </dt>
  <dt class="hdlist1">
  --force-rebase
  </dt>
  <dd>
  <p>
          Force the rebase even if the current branch is a descendant
          of the commit you are rebasing onto.  Normally non-interactive rebase will
          exit with the message "Current branch is up to date" in such a
          situation.
          Incompatible with the --interactive option.
  </p>
  <div class="paragraph"><p>You may find this (or --no-ff with an interactive rebase) helpful after
  reverting a topic branch merge, as this option recreates the topic branch with
  fresh commits so it can be remerged successfully without needing to "revert
  the reversion" (see the
  <a href="howto/revert-a-faulty-merge.txt">revert-a-faulty-merge How-To</a> for details).</p></div>
  </dd>
  <dt class="hdlist1">
  --ignore-whitespace
  </dt>
  <dt class="hdlist1">
  --whitespace=&lt;option&gt;
  </dt>
  <dd>
  <p>
          These flag are passed to the <em>git apply</em> program
          (see <a href="git-apply.html">git-apply(1)</a>) that applies the patch.
          Incompatible with the --interactive option.
  </p>
  </dd>
  <dt class="hdlist1">
  --committer-date-is-author-date
  </dt>
  <dt class="hdlist1">
  --ignore-date
  </dt>
  <dd>
  <p>
          These flags are passed to <em>git am</em> to easily change the dates
          of the rebased commits (see <a href="git-am.html">git-am(1)</a>).
          Incompatible with the --interactive option.
  </p>
  </dd>
  <dt class="hdlist1">
  -i
  </dt>
  <dt class="hdlist1">
  --interactive
  </dt>
  <dd>
  <p>
          Make a list of the commits which are about to be rebased.  Let the
          user edit that list before rebasing.  This mode can also be used to
          split commits (see SPLITTING COMMITS below).
  </p>
  </dd>
  <dt class="hdlist1">
  -p
  </dt>
  <dt class="hdlist1">
  --preserve-merges
  </dt>
  <dd>
  <p>
          Instead of ignoring merges, try to recreate them.
  </p>
  <div class="paragraph"><p>This uses the <tt>--interactive</tt> machinery internally, but combining it
  with the <tt>--interactive</tt> option explicitly is generally not a good
  idea unless you know what you are doing (see BUGS below).</p></div>
  </dd>
  <dt class="hdlist1">
  --root
  </dt>
  <dd>
  <p>
          Rebase all commits reachable from &lt;branch&gt;, instead of
          limiting them with an &lt;upstream&gt;.  This allows you to rebase
          the root commit(s) on a branch.  Must be used with --onto, and
          will skip changes already contained in &lt;newbase&gt; (instead of
          &lt;upstream&gt;).  When used together with --preserve-merges, <em>all</em>
          root commits will be rewritten to have &lt;newbase&gt; as parent
          instead.
  </p>
  </dd>
  <dt class="hdlist1">
  --autosquash
  </dt>
  <dt class="hdlist1">
  --no-autosquash
  </dt>
  <dd>
  <p>
          When the commit log message begins with "squash! &#8230;" (or
          "fixup! &#8230;"), and there is a commit whose title begins with
          the same &#8230;, automatically modify the todo list of rebase -i
          so that the commit marked for squashing comes right after the
          commit to be modified, and change the action of the moved
          commit from <tt>pick</tt> to <tt>squash</tt> (or <tt>fixup</tt>).
  </p>
  <div class="paragraph"><p>This option is only valid when the <em>--interactive</em> option is used.</p></div>
  <div class="paragraph"><p>If the <em>--autosquash</em> option is enabled by default using the
  configuration variable <tt>rebase.autosquash</tt>, this option can be
  used to override and disable this setting.</p></div>
  </dd>
  <dt class="hdlist1">
  --no-ff
  </dt>
  <dd>
  <p>
          With --interactive, cherry-pick all rebased commits instead of
          fast-forwarding over the unchanged ones.  This ensures that the
          entire history of the rebased branch is composed of new commits.
  </p>
  <div class="paragraph"><p>Without --interactive, this is a synonym for --force-rebase.</p></div>
  <div class="paragraph"><p>You may find this helpful after reverting a topic branch merge, as this option
  recreates the topic branch with fresh commits so it can be remerged
  successfully without needing to "revert the reversion" (see the
  <a href="howto/revert-a-faulty-merge.txt">revert-a-faulty-merge How-To</a> for details).</p></div>
  </dd>
  </dl></div>
  </div>
  <h2 id="_merge_strategies">MERGE STRATEGIES</h2>
  <div class="sectionbody">
  <div class="paragraph"><p>The merge mechanism (<em>git-merge</em> and <em>git-pull</em> commands) allows the
  backend <em>merge strategies</em> to be chosen with <tt>-s</tt> option.  Some strategies
  can also take their own options, which can be passed by giving <tt>-X&lt;option&gt;</tt>
  arguments to <em>git-merge</em> and/or <em>git-pull</em>.</p></div>
  <div class="dlist"><dl>
  <dt class="hdlist1">
  resolve
  </dt>
  <dd>
  <p>
          This can only resolve two heads (i.e. the current branch
          and another branch you pulled from) using a 3-way merge
          algorithm.  It tries to carefully detect criss-cross
          merge ambiguities and is considered generally safe and
          fast.
  </p>
  </dd>
  <dt class="hdlist1">
  recursive
  </dt>
  <dd>
  <p>
          This can only resolve two heads using a 3-way merge
          algorithm.  When there is more than one common
          ancestor that can be used for 3-way merge, it creates a
          merged tree of the common ancestors and uses that as
          the reference tree for the 3-way merge.  This has been
          reported to result in fewer merge conflicts without
          causing mis-merges by tests done on actual merge commits
          taken from Linux 2.6 kernel development history.
          Additionally this can detect and handle merges involving
          renames.  This is the default merge strategy when
          pulling or merging one branch.
  </p>
  <div class="paragraph"><p>The <em>recursive</em> strategy can take the following options:</p></div>
  <div class="dlist"><dl>
  <dt class="hdlist1">
  ours
  </dt>
  <dd>
  <p>
          This option forces conflicting hunks to be auto-resolved cleanly by
          favoring <em>our</em> version.  Changes from the other tree that do not
          conflict with our side are reflected to the merge result.
  </p>
  <div class="paragraph"><p>This should not be confused with the <em>ours</em> merge strategy, which does not
  even look at what the other tree contains at all.  It discards everything
  the other tree did, declaring <em>our</em> history contains all that happened in it.</p></div>
  </dd>
  <dt class="hdlist1">
  theirs
  </dt>
  <dd>
  <p>
          This is opposite of <em>ours</em>.
  </p>
  </dd>
  <dt class="hdlist1">
  patience
  </dt>
  <dd>
  <p>
          With this option, <em>merge-recursive</em> spends a little extra time
          to avoid mismerges that sometimes occur due to unimportant
          matching lines (e.g., braces from distinct functions).  Use
          this when the branches to be merged have diverged wildly.
          See also <a href="git-diff.html">git-diff(1)</a> <tt>--patience</tt>.
  </p>
  </dd>
  <dt class="hdlist1">
  ignore-space-change
  </dt>
  <dt class="hdlist1">
  ignore-all-space
  </dt>
  <dt class="hdlist1">
  ignore-space-at-eol
  </dt>
  <dd>
  <p>
          Treats lines with the indicated type of whitespace change as
          unchanged for the sake of a three-way merge.  Whitespace
          changes mixed with other changes to a line are not ignored.
          See also <a href="git-diff.html">git-diff(1)</a> <tt>-b</tt>, <tt>-w</tt>, and
          <tt>--ignore-space-at-eol</tt>.
  </p>
  <div class="ulist"><ul>
  <li>
  <p>
  If <em>their</em> version only introduces whitespace changes to a line,
    <em>our</em> version is used;
  </p>
  </li>
  <li>
  <p>
  If <em>our</em> version introduces whitespace changes but <em>their</em>
    version includes a substantial change, <em>their</em> version is used;
  </p>
  </li>
  <li>
  <p>
  Otherwise, the merge proceeds in the usual way.
  </p>
  </li>
  </ul></div>
  </dd>
  <dt class="hdlist1">
  renormalize
  </dt>
  <dd>
  <p>
          This runs a virtual check-out and check-in of all three stages
          of a file when resolving a three-way merge.  This option is
          meant to be used when merging branches with different clean
          filters or end-of-line normalization rules.  See "Merging
          branches with differing checkin/checkout attributes" in
          <a href="gitattributes.html">gitattributes(5)</a> for details.
  </p>
  </dd>
  <dt class="hdlist1">
  no-renormalize
  </dt>
  <dd>
  <p>
          Disables the <tt>renormalize</tt> option.  This overrides the
          <tt>merge.renormalize</tt> configuration variable.
  </p>
  </dd>
  <dt class="hdlist1">
  rename-threshold=&lt;n&gt;
  </dt>
  <dd>
  <p>
          Controls the similarity threshold used for rename detection.
          See also <a href="git-diff.html">git-diff(1)</a> <tt>-M</tt>.
  </p>
  </dd>
  <dt class="hdlist1">
  subtree[=&lt;path&gt;]
  </dt>
  <dd>
  <p>
          This option is a more advanced form of <em>subtree</em> strategy, where
          the strategy makes a guess on how two trees must be shifted to
          match with each other when merging.  Instead, the specified path
          is prefixed (or stripped from the beginning) to make the shape of
          two trees to match.
  </p>
  </dd>
  </dl></div>
  </dd>
  <dt class="hdlist1">
  octopus
  </dt>
  <dd>
  <p>
          This resolves cases with more than two heads, but refuses to do
          a complex merge that needs manual resolution.  It is
          primarily meant to be used for bundling topic branch
          heads together.  This is the default merge strategy when
          pulling or merging more than one branch.
  </p>
  </dd>
  <dt class="hdlist1">
  ours
  </dt>
  <dd>
  <p>
          This resolves any number of heads, but the resulting tree of the
          merge is always that of the current branch head, effectively
          ignoring all changes from all other branches.  It is meant to
          be used to supersede old development history of side
          branches.  Note that this is different from the -Xours option to
          the <em>recursive</em> merge strategy.
  </p>
  </dd>
  <dt class="hdlist1">
  subtree
  </dt>
  <dd>
  <p>
          This is a modified recursive strategy. When merging trees A and
          B, if B corresponds to a subtree of A, B is first adjusted to
          match the tree structure of A, instead of reading the trees at
          the same level. This adjustment is also done to the common
          ancestor tree.
  </p>
  </dd>
  </dl></div>
  </div>
  <h2 id="_notes">NOTES</h2>
  <div class="sectionbody">
  <div class="paragraph"><p>You should understand the implications of using <em>git rebase</em> on a
  repository that you share.  See also <a href="#_recovering_from_upstream_rebase">RECOVERING FROM UPSTREAM REBASE</a>
  below.</p></div>
  <div class="paragraph"><p>When the git-rebase command is run, it will first execute a "pre-rebase"
  hook if one exists.  You can use this hook to do sanity checks and
  reject the rebase if it isn&#8217;t appropriate.  Please see the template
  pre-rebase hook script for an example.</p></div>
  <div class="paragraph"><p>Upon completion, &lt;branch&gt; will be the current branch.</p></div>
  </div>
  <h2 id="_interactive_mode">INTERACTIVE MODE</h2>
  <div class="sectionbody">
  <div class="paragraph"><p>Rebasing interactively means that you have a chance to edit the commits
  which are rebased.  You can reorder the commits, and you can
  remove them (weeding out bad or otherwise unwanted patches).</p></div>
  <div class="paragraph"><p>The interactive mode is meant for this type of workflow:</p></div>
  <div class="olist arabic"><ol class="arabic">
  <li>
  <p>
  have a wonderful idea
  </p>
  </li>
  <li>
  <p>
  hack on the code
  </p>
  </li>
  <li>
  <p>
  prepare a series for submission
  </p>
  </li>
  <li>
  <p>
  submit
  </p>
  </li>
  </ol></div>
  <div class="paragraph"><p>where point 2. consists of several instances of</p></div>
  <div class="olist loweralpha"><ol class="loweralpha">
  <li>
  <p>
  regular use
  </p>
  <div class="olist arabic"><ol class="arabic">
  <li>
  <p>
  finish something worthy of a commit
  </p>
  </li>
  <li>
  <p>
  commit
  </p>
  </li>
  </ol></div>
  </li>
  <li>
  <p>
  independent fixup
  </p>
  <div class="olist arabic"><ol class="arabic">
  <li>
  <p>
  realize that something does not work
  </p>
  </li>
  <li>
  <p>
  fix that
  </p>
  </li>
  <li>
  <p>
  commit it
  </p>
  </li>
  </ol></div>
  </li>
  </ol></div>
  <div class="paragraph"><p>Sometimes the thing fixed in b.2. cannot be amended to the not-quite
  perfect commit it fixes, because that commit is buried deeply in a
  patch series.  That is exactly what interactive rebase is for: use it
  after plenty of "a"s and "b"s, by rearranging and editing
  commits, and squashing multiple commits into one.</p></div>
  <div class="paragraph"><p>Start it with the last commit you want to retain as-is:</p></div>
  <div class="literalblock">
  <div class="content">
  <pre><tt>git rebase -i &lt;after-this-commit&gt;</tt></pre>
  </div></div>
  <div class="paragraph"><p>An editor will be fired up with all the commits in your current branch
  (ignoring merge commits), which come after the given commit.  You can
  reorder the commits in this list to your heart&#8217;s content, and you can
  remove them.  The list looks more or less like this:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>pick deadbee The oneline of this commit&#x000A;pick fa1afe1 The oneline of the next commit&#x000A;...</tt></pre>
  </div></div>
  <div class="paragraph"><p>The oneline descriptions are purely for your pleasure; <em>git rebase</em> will
  not look at them but at the commit names ("deadbee" and "fa1afe1" in this
  example), so do not delete or edit the names.</p></div>
  <div class="paragraph"><p>By replacing the command "pick" with the command "edit", you can tell
  <em>git rebase</em> to stop after applying that commit, so that you can edit
  the files and/or the commit message, amend the commit, and continue
  rebasing.</p></div>
  <div class="paragraph"><p>If you just want to edit the commit message for a commit, replace the
  command "pick" with the command "reword".</p></div>
  <div class="paragraph"><p>If you want to fold two or more commits into one, replace the command
  "pick" for the second and subsequent commits with "squash" or "fixup".
  If the commits had different authors, the folded commit will be
  attributed to the author of the first commit.  The suggested commit
  message for the folded commit is the concatenation of the commit
  messages of the first commit and of those with the "squash" command,
  but omits the commit messages of commits with the "fixup" command.</p></div>
  <div class="paragraph"><p><em>git rebase</em> will stop when "pick" has been replaced with "edit" or
  when a command fails due to merge errors. When you are done editing
  and/or resolving conflicts you can continue with <tt>git rebase --continue</tt>.</p></div>
  <div class="paragraph"><p>For example, if you want to reorder the last 5 commits, such that what
  was HEAD~4 becomes the new HEAD. To achieve that, you would call
  <em>git rebase</em> like this:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>$ git rebase -i HEAD~5</tt></pre>
  </div></div>
  <div class="paragraph"><p>And move the first patch to the end of the list.</p></div>
  <div class="paragraph"><p>You might want to preserve merges, if you have a history like this:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>           X&#x000A;            \&#x000A;         A---M---B&#x000A;        /&#x000A;---o---O---P---Q</tt></pre>
  </div></div>
  <div class="paragraph"><p>Suppose you want to rebase the side branch starting at "A" to "Q". Make
  sure that the current HEAD is "B", and call</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>$ git rebase -i -p --onto Q O</tt></pre>
  </div></div>
  <div class="paragraph"><p>Reordering and editing commits usually creates untested intermediate
  steps.  You may want to check that your history editing did not break
  anything by running a test, or at least recompiling at intermediate
  points in history by using the "exec" command (shortcut "x").  You may
  do so by creating a todo list like this one:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>pick deadbee Implement feature XXX&#x000A;fixup f1a5c00 Fix to feature XXX&#x000A;exec make&#x000A;pick c0ffeee The oneline of the next commit&#x000A;edit deadbab The oneline of the commit after&#x000A;exec cd subdir; make test&#x000A;...</tt></pre>
  </div></div>
  <div class="paragraph"><p>The interactive rebase will stop when a command fails (i.e. exits with
  non-0 status) to give you an opportunity to fix the problem. You can
  continue with <tt>git rebase --continue</tt>.</p></div>
  <div class="paragraph"><p>The "exec" command launches the command in a shell (the one specified
  in <tt>$SHELL</tt>, or the default shell if <tt>$SHELL</tt> is not set), so you can
  use shell features (like "cd", "&gt;", ";" &#8230;). The command is run from
  the root of the working tree.</p></div>
  </div>
  <h2 id="_splitting_commits">SPLITTING COMMITS</h2>
  <div class="sectionbody">
  <div class="paragraph"><p>In interactive mode, you can mark commits with the action "edit".  However,
  this does not necessarily mean that <em>git rebase</em> expects the result of this
  edit to be exactly one commit.  Indeed, you can undo the commit, or you can
  add other commits.  This can be used to split a commit into two:</p></div>
  <div class="ulist"><ul>
  <li>
  <p>
  Start an interactive rebase with <tt>git rebase -i &lt;commit&gt;^</tt>, where
    &lt;commit&gt; is the commit you want to split.  In fact, any commit range
    will do, as long as it contains that commit.
  </p>
  </li>
  <li>
  <p>
  Mark the commit you want to split with the action "edit".
  </p>
  </li>
  <li>
  <p>
  When it comes to editing that commit, execute <tt>git reset HEAD^</tt>.  The
    effect is that the HEAD is rewound by one, and the index follows suit.
    However, the working tree stays the same.
  </p>
  </li>
  <li>
  <p>
  Now add the changes to the index that you want to have in the first
    commit.  You can use <tt>git add</tt> (possibly interactively) or
    <em>git gui</em> (or both) to do that.
  </p>
  </li>
  <li>
  <p>
  Commit the now-current index with whatever commit message is appropriate
    now.
  </p>
  </li>
  <li>
  <p>
  Repeat the last two steps until your working tree is clean.
  </p>
  </li>
  <li>
  <p>
  Continue the rebase with <tt>git rebase --continue</tt>.
  </p>
  </li>
  </ul></div>
  <div class="paragraph"><p>If you are not absolutely sure that the intermediate revisions are
  consistent (they compile, pass the testsuite, etc.) you should use
  <em>git stash</em> to stash away the not-yet-committed changes
  after each commit, test, and amend the commit if fixes are necessary.</p></div>
  </div>
  <h2 id="_recovering_from_upstream_rebase">RECOVERING FROM UPSTREAM REBASE</h2>
  <div class="sectionbody">
  <div class="paragraph"><p>Rebasing (or any other form of rewriting) a branch that others have
  based work on is a bad idea: anyone downstream of it is forced to
  manually fix their history.  This section explains how to do the fix
  from the downstream&#8217;s point of view.  The real fix, however, would be
  to avoid rebasing the upstream in the first place.</p></div>
  <div class="paragraph"><p>To illustrate, suppose you are in a situation where someone develops a
  <em>subsystem</em> branch, and you are working on a <em>topic</em> that is dependent
  on this <em>subsystem</em>.  You might end up with a history like the
  following:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>    o---o---o---o---o---o---o---o---o  master&#x000A;         \&#x000A;          o---o---o---o---o  subsystem&#x000A;                           \&#x000A;                            *---*---*  topic</tt></pre>
  </div></div>
  <div class="paragraph"><p>If <em>subsystem</em> is rebased against <em>master</em>, the following happens:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>    o---o---o---o---o---o---o---o  master&#x000A;         \                       \&#x000A;          o---o---o---o---o       o'--o'--o'--o'--o'  subsystem&#x000A;                           \&#x000A;                            *---*---*  topic</tt></pre>
  </div></div>
  <div class="paragraph"><p>If you now continue development as usual, and eventually merge <em>topic</em>
  to <em>subsystem</em>, the commits from <em>subsystem</em> will remain duplicated forever:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>    o---o---o---o---o---o---o---o  master&#x000A;         \                       \&#x000A;          o---o---o---o---o       o'--o'--o'--o'--o'--M  subsystem&#x000A;                           \                         /&#x000A;                            *---*---*-..........-*--*  topic</tt></pre>
  </div></div>
  <div class="paragraph"><p>Such duplicates are generally frowned upon because they clutter up
  history, making it harder to follow.  To clean things up, you need to
  transplant the commits on <em>topic</em> to the new <em>subsystem</em> tip, i.e.,
  rebase <em>topic</em>.  This becomes a ripple effect: anyone downstream from
  <em>topic</em> is forced to rebase too, and so on!</p></div>
  <div class="paragraph"><p>There are two kinds of fixes, discussed in the following subsections:</p></div>
  <div class="dlist"><dl>
  <dt class="hdlist1">
  Easy case: The changes are literally the same.
  </dt>
  <dd>
  <p>
          This happens if the <em>subsystem</em> rebase was a simple rebase and
          had no conflicts.
  </p>
  </dd>
  <dt class="hdlist1">
  Hard case: The changes are not the same.
  </dt>
  <dd>
  <p>
          This happens if the <em>subsystem</em> rebase had conflicts, or used
          <tt>--interactive</tt> to omit, edit, squash, or fixup commits; or
          if the upstream used one of <tt>commit --amend</tt>, <tt>reset</tt>, or
          <tt>filter-branch</tt>.
  </p>
  </dd>
  </dl></div>
  <h3 id="_the_easy_case">The easy case</h3><div style="clear:left"></div>
  <div class="paragraph"><p>Only works if the changes (patch IDs based on the diff contents) on
  <em>subsystem</em> are literally the same before and after the rebase
  <em>subsystem</em> did.</p></div>
  <div class="paragraph"><p>In that case, the fix is easy because <em>git rebase</em> knows to skip
  changes that are already present in the new upstream.  So if you say
  (assuming you&#8217;re on <em>topic</em>)</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>    $ git rebase subsystem</tt></pre>
  </div></div>
  <div class="paragraph"><p>you will end up with the fixed history</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>    o---o---o---o---o---o---o---o  master&#x000A;                                 \&#x000A;                                  o'--o'--o'--o'--o'  subsystem&#x000A;                                                   \&#x000A;                                                    *---*---*  topic</tt></pre>
  </div></div>
  <h3 id="_the_hard_case">The hard case</h3><div style="clear:left"></div>
  <div class="paragraph"><p>Things get more complicated if the <em>subsystem</em> changes do not exactly
  correspond to the ones before the rebase.</p></div>
  <div class="admonitionblock">
  <table><tr>
  <td class="icon">
  <div class="title">Note</div>
  </td>
  <td class="content">While an "easy case recovery" sometimes appears to be successful
        even in the hard case, it may have unintended consequences.  For
        example, a commit that was removed via <tt>git rebase
        --interactive</tt> will be <strong>resurrected</strong>!</td>
  </tr></table>
  </div>
  <div class="paragraph"><p>The idea is to manually tell <em>git rebase</em> "where the old <em>subsystem</em>
  ended and your <em>topic</em> began", that is, what the old merge-base
  between them was.  You will have to find a way to name the last commit
  of the old <em>subsystem</em>, for example:</p></div>
  <div class="ulist"><ul>
  <li>
  <p>
  With the <em>subsystem</em> reflog: after <em>git fetch</em>, the old tip of
    <em>subsystem</em> is at <tt>subsystem@{1}</tt>.  Subsequent fetches will
    increase the number.  (See <a href="git-reflog.html">git-reflog(1)</a>.)
  </p>
  </li>
  <li>
  <p>
  Relative to the tip of <em>topic</em>: knowing that your <em>topic</em> has three
    commits, the old tip of <em>subsystem</em> must be <tt>topic~3</tt>.
  </p>
  </li>
  </ul></div>
  <div class="paragraph"><p>You can then transplant the old <tt>subsystem..topic</tt> to the new tip by
  saying (for the reflog case, and assuming you are on <em>topic</em> already):</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>    $ git rebase --onto subsystem subsystem@{1}</tt></pre>
  </div></div>
  <div class="paragraph"><p>The ripple effect of a "hard case" recovery is especially bad:
  <em>everyone</em> downstream from <em>topic</em> will now have to perform a "hard
  case" recovery too!</p></div>
  </div>
  <h2 id="_bugs">BUGS</h2>
  <div class="sectionbody">
  <div class="paragraph"><p>The todo list presented by <tt>--preserve-merges --interactive</tt> does not
  represent the topology of the revision graph.  Editing commits and
  rewording their commit messages should work fine, but attempts to
  reorder commits tend to produce counterintuitive results.</p></div>
  <div class="paragraph"><p>For example, an attempt to rearrange</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>1 --- 2 --- 3 --- 4 --- 5</tt></pre>
  </div></div>
  <div class="paragraph"><p>to</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>1 --- 2 --- 4 --- 3 --- 5</tt></pre>
  </div></div>
  <div class="paragraph"><p>by moving the "pick 4" line will result in the following history:</p></div>
  <div class="listingblock">
  <div class="content">
  <pre><tt>        3&#x000A;       /&#x000A;1 --- 2 --- 4 --- 5</tt></pre>
  </div></div>
  </div>
  <h2 id="_git">GIT</h2>
  <div class="sectionbody">
  <div class="paragraph"><p>Part of the <a href="git.html">git(1)</a> suite</p></div>
  </div>
  <div id="footer">
  <div id="footer-text">
  Last updated 2011-07-23 00:49:30 UTC
  </div>
  </div>
</div>
