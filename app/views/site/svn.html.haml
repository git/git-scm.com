- @section    = 'documentation'
- @subsection = 'reference'
:css
  table.ccmd td { border: 1px; padding-left: 2em; padding-right: 2em; }
  table.ccmd    { width: 99%; border: 1px solid #000; margin-bottom: 15px; }
  table.ccmd, code.g { font-family: monospace; }
  table.ccmd td.g    { width: 33%; }
  table.ccmd td.g, code.g { font-weight: bold; }
  table.ccmd td.g         { background: #e9e8e1; color: #444; }
#main.book
  %h1 Git - SVN Crash Course
  %p
    Welcome to the Git version control system! Here we will briefly
    introduce you to Git usage based on your current Subversion knowledge. You will
    need the latest
    %a{:href => "http://git.or.cz/"} Git
    installed;
    There is also a potentially useful
    %a{:href => "http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html"}
      tutorial
    in the Git documentation.
  .doc-toc
    %ul
      %li
        %a{:href => "#read"} How to Read Me
      %li
        %a{:href => "#know"} Things To Know
      %li
        %a{:href => "#commit"} Commiting
      %li
        %a{:href => "#browse"} Browsing
      %li
        %a{:href => "#branch"} Tagging and Branching
      %li
        %a{:href => "#merge"} Merging
      %li
        %a{:href => "#remote"} Going Remote
      %li
        %a{:href => "#share"} Sharing the Work
  %div{:style => "text-align:center;"}
    %table.relnotes{:style => "margin-left: auto; margin-right: auto; border: 1px"}
      %tr
        %td{:style => "text-align:center;"}
          %p{:style => "margin: 0em 0.4em"}
            If you are just after tracking someone else's project,
            this get you started quickly:
          %p
          %table.ccmd{:style => "margin:0em; margin-left: auto; margin-right: auto;"}
            %tr
              %td.g
                git clone
                %em url
                = succeed "git" do
                  %br/
                pull
              %td
                svn&nbsp;checkout&nbsp;
                %em url
                = succeed "svn" do
                  %br/
                update
  %hr/
  %h2#read How to Read Me
  %p
    In those small tables, at the left we always list the Git commands
    for the task, while at the right the corresponding Subversion commands you would use
    for the job are listed.  If you are in hurry, just skimming over them should
    give you a good idea about the Git usage basics.
  %p
    Before running any command the first time, it's recommended that you
    at least quickly skim through its manual page. Many of the commands have
    very useful and interesting features (that we won't list here) and sometimes
    there are some extra notes you might want to know. There's a quick usage
    help available for the Git commands if you pass them the
    %code -h
    switch.
  %h2#know Things You Should Know
  %p
    There are couple important concepts it is good to know when
    starting with Git. If you are in hurry though, you can skip this
    section and only get back to it when you get seriously confused;
    it should be possible to pick up with just using your intuition.
  %ul
    %li
      %b Repositories.
      With Subversion, for each project there is a single repository at some
      detached central place where all the history is and which you checkout
      and commit into. Git works differently, each copy of the project tree
      (we call that the
      = succeed ")" do
        %em working copy
      carries its own repository
      around (in the
      %code .git
      subdirectory in the project tree root).
      So you can have local and remote branches.
      You can also have a so-called
      %em bare repository
      which is not
      attached to a working copy; that is useful especially when you want
      to publish your repository. We will get to that.
    %li
      %b URL.
      In Subversion the
      %em URL
      identifies the location of the repository
      and the path inside the repository, so you organize the layout of the
      repository and its meaning. Normally you would have
      = succeed "," do
        %code trunk/
      %code branches/
      and
      %code tags/
      directories. In Git
      the
      %em URL
      is just the location of the repository, and it always
      contains branches and tags. One of the branches is the default (normally named
      master).
    %li
      %b Revisions.
      Subversion identifies revisions with ids of decimal numbers growing
      monotonically which are typically small (although they can get quickly
      to hundreds of thousands for large projects).  That is impractical in distributed systems like Git. Git
      identifies revisions with SHA1 ids, which are long 160-bit numbers
      written in hexadecimal. It may look scary at first, but in practice it is
      not a big hurdle - you can refer to the latest revision by
      = succeed "," do
        %code HEAD
      its parent as
      %code HEAD^
      and its parent as
      %code HEAD^^ = HEAD~2
      (you can go on adding carrets),
      cut'n'paste helps a lot and you can write only the few leading digits
      of a revision - as long as it is unique, Git will guess the rest.
      (You can do even more advanced stuff with revision specifiers, see the
      %a{:href => "http://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html"} git-rev-parse manpage
      for details.)
    %li
      %b Commits.
      Each commit has an
      %em author
      and a
      %em committer
      field,
      which record who and when
      %em created
      the change and who
      %em committed
      it
      (Git is designed to work well with patches coming by mail - in that case,
      the author and the committer will be different). Git will try to guess
      your realname and email, but especially with email it is likely to get it wrong.
      You can check it using
      %code.g git config -l
      and set them with:
      %pre
        :preserve
          
            git config --global user.name "Your Name Comes Here"
            git config --global user.email you@yourdomain.example.com
                %li
      %b Commands.
      The Git commands are in the form
      = succeed "." do
        %code git command
      You can interchangeably use the
      %code git-command
      form as well.
    %li
      %b Colors.
      Git can produce colorful output with some commands; since
      some people hate colors way more than the rest likes them, by default
      the colors are turned off. If you would like to have colors in your
      output:
      %pre
        :preserve
          
            git config --global color.diff auto
            git config --global color.status auto
            git config --global color.branch auto
                %li
      %b Visualize.
      You may find it convenient to watch your repository using
      the
      %code.g gitk
      repository as you go.
  %h2#commit Commiting
  %p
    For the first introduction, let's make your project tracked by Git
    and see how we get around to do daily development in it. Let's
    %code cd
    to the directory with your project and initialize
    a brand new Git repository with it:
  %table.ccmd
    %tr
      %td.g
        git init
        %br>/
        git add .
        %br>/
        git commit
      %td
        svnadmin create
        %em repo
        = succeed "svn" do
          %br/
        import
        %em file://repo
  %p
    %code git init
    will initialize the repository,
    %code git add .
    will add all the files under the current directory
    and
    %code git commit
    will create the
    initial import, given that repositories are coupled with working copies.
  %p
    Now your tree is officially tracked by Git. You can explore the
    %code.g .git
    subdirectory a bit if you want, or don't if you
    don't care. Do some random changes to your tree now - poke into few
    files or such. Let's check what we've done:
  %table.ccmd
    %tr
      %td.g git diff
      %td svn diff | less
  %p
    That's it. This is one of the more powerful commands. To get a diff with an
    specific revision and path do:
  %table.ccmd
    %tr
      %td.g
        git diff
        %em rev
        %em path
      %td
        svn diff -r
        %em rev
        %em path
  %p
    Git embeds special information in
    the diffs about adds, removals and mode changes:
  %table.ccmd
    %tr
      %td.g git apply
      %td patch -p0
  %p
    That will apply the patch while telling Git about and performing
    those "meta-changes".
  %p There is a more concise representation of changes available:
  %table.ccmd
    %tr
      %td.g git status
      %td svn status
  %p
    This will show the concise changes summary as well as list any files
    that you haven't either ignored or told Git about. In addition,
    it will also show at the top which branch you are in.
  %p
    While we are at the status command, over time plenty of the
    "Untracked files" will get in there, denoting files not tracked by Git.
    Wait a moment if you want to add them, run
    %code.g git clean
    if you want to get rid of all of them, or add them to the
    %code.g .gitignore
    file if you want to keep them around untracked (works the same as the
    %code svn:ignore
    property in SVN).
  %p To restore a file from the last revision:
  %table.ccmd
    %tr
      %td.g
        git checkout
        %em path
      %td
        svn revert
        %em path
  %p You can restore everything or just specified files.
  %p
    So, just like in SVN, you need to tell Git when you add, move or
    remove any files:
  %table.ccmd
    %tr
      %td.g
        git add
        %em file
        = succeed "git" do
          %br/
        rm
        %em file
        = succeed "git" do
          %br/
        mv
        %em file
      %td
        svn add
        %em file
        = succeed "svn" do
          %br/
        rm
        %em file
        = succeed "svn" do
          %br/
        mv
        %em file
  %p
    You can also recursively add/remove whole directories and so on;
    Git's cool!
  %p
    So, it's about time we commit our changes. Big surprise
    about the command:
  %table.ccmd
    %tr
      %td.g git commit -a
      %td svn commit
  %p
    to commit all the changes or, as with Subversion,
    you can limit the commit only to specified files
    and so on. A few words on the commit message: it is
    %em customary
    to have a short commit summary as the first line of the message,
    because various tools listing commits frequently show only the
    first line of the message.  You can specify the commit message
    using the
    %code -m
    parameter as you are used, but
    you can pass several
    %code -m
    arguments and they will create
    separate paragraphs in the commit message:
  %p
    If you don't pass any
    %code -m
    parameter or pass
    the
    %code -e
    parameter, your favorite
    %code $EDITOR
    will get run and you can compose your commit message there,
    just as with Subversion. In addition, the list of files to be committed
    is shown.
  %p
    And as a bonus, if you pass it the
    %code -v
    parameter
    it will show the whole patch being committed in the editor
    so that you can do a quick last-time review.
  %p
    By the way, if you screwed up committing, there's not much you
    can do with Subversion, except using some enigmatic
    %code svnadmin
    subcommands.  Git does it better - you can amend your latest commit
    (re-edit the metadata as well as update the tree) using
    = succeed "," do
      %code.g git commit --amend
    or toss your latest
    commit away completely using
    = succeed "," do
      %code.g git reset HEAD^
    this will not change the working tree.
  %h2#browse Browsing
  %p
    Now that we have committed some stuff, you might want to review
    your history:
  %table.ccmd
    %tr
      %td.g
        git log
        %br>/
        git blame
        %em file
      %td
        svn log | less
        %br>/
        svn blame
        %em file
  %p
    The log command works quite similar in SVN and Git; again,
    %code git log
    is quite powerful, please look through
    its options to see some of the stuff it can do.
  %p
    The blame command is more powerful as it can detect the movement of lines,
    even with file copies and renames. But there is a
    big chance that you probably want to do something different! Usually,
    when using annotate you are looking for the origin of some piece of
    code, and the so-called
    %em pickaxe
    of Git is much more comfortable
    tool for that job (
    %code
      git log -S
      %em string
    shows the
    commits which add or remove any file data matching
    = succeed ")." do
      %em string
  %p
    You can see the contents of a file, the listing of a directory or
    a commit with:
  %table.ccmd
    %tr
      %td.g
        git show
        = succeed ":" do
          %em rev
        %em path/to/file
        = succeed "git&amp;nbsp;show&amp;nbsp;" do
          %br/
        = succeed ":" do
          %em rev
        %em path/to/directory
        = succeed "git" do
          %br/
        show
        %em rev
      %td
        svn cat
        %em url
        = succeed "svn" do
          %br/
        list
        %em url
        = succeed "svn" do
          %br/
        log -r
        %em rev
        %em url
        = succeed "svn" do
          %br/
        diff -c
        %em rev
        %em url
  %h2#branch Tagging and branching
  %p
    Subversion marks certain checkpoints in history through copies, the copy is
    usually placed in a directory named tags.  Git tags are much more powerful.
    The Git tag can have an arbitrary description attached (the first
    line is special as in the commit case), some people actually store
    the whole release announcements in the tag descriptions. The identity
    of the person who tagged is stored (again following the same rules
    as identity of the committer). You can tag other objects than commits (but
    that is conceptually rather low-level operation).
    And the tag can be cryptographically PGP signed to verify the identity
    (by Git's nature of working, that signature also confirms the validity
    of the associated revision, its history and tree). So, let's do it:
  %table.ccmd
    %tr
      %td.g
        git tag -a
        %em name
      %td
        svn copy http://example.com/svn/trunk
        http://example.com/svn/tags/
        %em name
  %p To list tags and to show the tag message:
  %table.ccmd
    %tr
      %td.g
        git tag -l
        %br>/
        git show
        %em tag
      %td
        svn&nbsp;list&nbsp;http://example.com/svn/
        %em tags/
        = succeed "svn&amp;nbsp;log" do
          %br/
        \--limit&nbsp;1&nbsp;http://example.com/svn/tags/
        %em tag
  %p
    Like Subversion, Git can do branches (surprise surprise!). In Subversion,
    you basically copy your project to a subdirectory. In Git, you tell it,
    well, to create a branch.
  %table.ccmd
    %tr
      %td.g
        git branch
        %em branch
        = succeed "git&amp;nbsp;checkout&amp;nbsp;" do
          %br/
        %em branch
      %td
        svn copy http://example.com/svn/trunk
        http://example.com/svn/branches/
        %em branch
        = succeed "svn" do
          %br/
        switch
        http://example.com/svn/branches/
        %em branch
  %p
    The first command creates a branch, the second command switches
    your tree to a certain branch. You can pass an extra argument to
    %code git branch
    to base your new branch on a different
    revision than the latest one.
  %p
    You can list your branches conveniently using the aforementioned
    %code git-branch
    command without arguments the listing of branches.
    The current one is denoted by an "*".
  %table.ccmd
    %tr
      %td.g git branch
      %td svn list http://example.com/svn/branches/
  %p To move your tree to some older revision, use:
  %table.ccmd
    %tr
      %td.g
        git checkout
        %em rev
        = succeed "git" do
          %br/
        checkout
        %em prevbranch
      %td
        svn update -r
        %em rev
        = succeed "svn" do
          %br/
        update
  %p
    or you could create a temporary branch. In Git you can make commits on
    top of the older revision and use it as another branch.
  %h2#merge Merging
  %p
    Git supports merging between branches much better than Subversion - history
    of both branches is preserved over the merges and repeated merges
    of the same branches are supported out-of-the-box. Make sure you are on
    one of the to-be-merged branches and merge the other one now:
  %table.ccmd
    %tr
      %td.g
        git merge
        %em branch
      %td
        svn merge -r 20:HEAD
        http://example.com/svn/branches/
        %em branch
        %br/
        %em
          (assuming the branch was created in revision 20 and
          you are inside a working copy of trunk)
  %p
    If changes were made on only one of the branches since the last merge,
    they are simply replayed on your other branch (so-called
    = succeed ")." do
      %em fast-forward merge
    If changes were made on both branches, they are merged intelligently
    (so-called
    = succeed "):" do
      %em three-way merge
    if any changes conflicted,
    %code git merge
    will report them and let you resolve them, updating the rest of the tree
    already to the result state; you can
    %code git commit
    when you resolve
    the conflicts. If no changes conflicted, a commit is made automatically with
    a convenient log message (or you can do
    %code.g
      git merge --no-commit
      %em branch
    to review the merge
    result and then do the commit yourself).
  %p
    Aside from merging, sometimes you want to just pick one commit from
    a different branch. To apply the changes in revision
    %em rev
    and commit
    them to the current branch use:
  %table.ccmd
    %tr
      %td.g
        git cherry-pick
        %em rev
      %td
        svn merge -c
        %em rev
        %em url
  %h2#remote Going Remote
  %p
    So far, we have neglected that Git is a
    %em distributed
    version
    control system. It is time for us to set the record straight - let's grab
    some stuff from remote sites.
  %p
    If you are working on someone else's project, you usually want to
    %em clone
    its repository instead of starting your own. We've already mentioned that at the top
    of this document:
  %table.ccmd
    %tr
      %td.g
        git clone
        %em url
      %td
        svn&nbsp;checkout&nbsp;
        %em url
  %p
    Now you have the default branch (normally
    = succeed ")," do
      %code master
    but in addition you got all the remote branches and tags.
    In clone's default setup, the default local branch tracks
    the
    %em origin
    remote, which represents the default branch in the
    remote repository.
  %p
    %em> Remote branch
    , you ask? Well, so far we have worked
    only with local branches. Remote branches are a mirror image of branches
    in remote repositories and you don't ever switch to them directly or write
    to them. Let me repeat - you never mess with remote branches. If you want
    to switch to a remote branch, you need to create a corresponding local
    branch which will "track" the remote branch:
  %table.ccmd
    %tr
      %td.g
        git checkout -b
        %em branch
        origin/
        %em branch
      %td
        svn&nbsp;switch&nbsp;
        %em url
  %p
    You can add more remote branches to a cloned repository, as well as just
    an initialized one, using
    = succeed "." do
      %code.g
        git remote add
        %em remote
        %em url
    The command
    %code.g git remote
    lists all the remotes
    repositories and
    %code.g
      git remote show
      %em remote
    shows
    the branches in a remote repository.
  %p
    Now, how do you get any new changes from a remote repository?
    You fetch them:
    = succeed "." do
      %code.g git fetch
    At this point they are in your repository and you can examine them using
    %code
      git log
      %em origin
    (
    %code
      git log HEAD..
      %em origin
    to see just the changes you don't have in your branch), diff them, and obviously, merge them - just do
    = succeed "." do
      %code
        git merge
        %em origin
    Note that if you don't specify a branch
    to fetch, it will conveniently default to the tracking remote.
  %p
    Since you frequently just fetch + merge the tracking remote branch,
    there is a command to automate that:
  %table.ccmd
    %tr
      %td.g git pull
      %td svn update
  %h2#share Sharing the Work
  %p
    Your local repository can be used by others to
    %em pull
    changes, but
    normally you would have a private repository and a public repository.
    The public repository is where everybody pulls and you... do the
    opposite?
    %em Push
    your changes? Yes!
    We do
    %code.g
      git push
      %em remote
    which will push
    all the local branches with a corresponding remote branch - note that this works
    generally only over SSH (or HTTP but with special webserver setup).
    It is highly recommended to setup a SSH key and an SSH agent mechanism
    so that you don't have to type in a password all the time.
  %p
    One important thing is that you should push only to remote branches
    that are not currently checked out on the other side (for the same
    reasons you never switch to a remote branch locally)! Otherwise the
    working copy at the remote branch will get out of date and confusion
    will ensue. The best way to avoid that is to push only to remote
    repositories with no working copy at all - so called
    %em bare
    repositories which are commonly used for public access or developers'
    meeting point - just for exchange of history where a checked out copy
    would be a waste of space anyway. You can create such a repository.
    See
    %a{:href => "/docs/user-manual.html#setting-up-a-public-repository"} Setting up a public repository
    for details.
  %p
    Git can work with the same workflow as Subversion, with a group of developers
    using a single repository for exchange of their work. The only change
    is that their changes aren't submitted automatically but they have
    to push (however, you can setup a post-commit hook that will push for you
    every time you commit; that loses the flexibility to fix up a screwed
    commit, though). The developers must have either an entry in htaccess
    (for HTTP DAV) or a UNIX account (for SSH). You can restrict their
    shell account only to Git pushing/fetching by using the
    %code.g git-shell
    login shell.
  %p
    You can also exchange patches by mail. Git has very good support
    for patches incoming by mail. You can apply them by feeding mailboxes
    with patch mails to
    = succeed "." do
      %code.g git am
    If you
    want to
    %em send
    patches use
    %code.g git format-patch
    and
    possibly
    = succeed "." do
      %code.g git send-email
  %p
    If you have any questions or problems which are not obvious from
    the documentation, please contact us at the
    %strong Git mailing list
    at
    = succeed "." do
      %a{:href => "mailto:git@vger.kernel.org"} git@vger.kernel.org
    We hope you enjoy using Git!
